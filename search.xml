<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES11新增属性解析</title>
    <url>/2020/11/25/ES11%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ES11新增属性解析"><a href="#ES11新增属性解析" class="headerlink" title="ES11新增属性解析"></a>ES11新增属性解析</h1><p>ES2020(ES11)引入了以下新特性（个人觉得比较实用的以粗体形式展示）：</p>
<ul>
<li><strong>String的<code>matchAll</code>方法</strong></li>
<li>动态导入语句<code>import()</code></li>
<li><code>import.meta</code></li>
<li><code>export * as ns from &#39;module&#39;</code></li>
<li><strong><code>Promise.allSettled</code></strong></li>
<li><strong>新的数据类型<code>BigInt</code></strong></li>
<li><strong><code>GlobalThis</code></strong></li>
<li><strong><code>Nullish coalescing Operator</code></strong></li>
<li><strong><code>Optional Chaining</code></strong></li>
</ul>
<h1 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll"></a><strong>matchAll</strong></h1><p><code>matchAll()</code>方法返回一个包含所有匹配正则表达式的结果的迭代器。使用<code>for...of</code>遍历或者使用操作符<code>...</code>、<code>Array.from</code>将其转换成数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/[0-3]/g</span>;</span><br><span class="line"><span class="keyword">const</span> data = <span class="string">'2020'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(data.matchAll(reg));<span class="comment">//data.matchAll 的返回值是一个迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log([...data.matchAll(reg)]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0: ["2", index: 0, input: "2020", groups: undefined]</span></span><br><span class="line"><span class="comment"> * 1: ["0", index: 1, input: "2020", groups: undefined]</span></span><br><span class="line"><span class="comment"> * 2: ["2", index: 2, input: "2020", groups: undefined]</span></span><br><span class="line"><span class="comment"> * 3: ["0", index: 3, input: "2020", groups: undefined]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="Dynamic-import"><a href="#Dynamic-import" class="headerlink" title="Dynamic import"></a><strong>Dynamic import</strong></h1><p>标准用法的<code>import</code>导入的模块时静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p>
<p>在<code>import()</code>（也就是动态<code>import</code>）之前，当我们需要根据条件导入模块时，不得不使用<code>require()</code>。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(XXX) &#123;</span><br><span class="line">    <span class="keyword">const</span> menu = <span class="built_in">require</span>(<span class="string">'./menu'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如今可以替换为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(XXX) &#123;</span><br><span class="line">    <span class="keyword">const</span> menu = <span class="keyword">import</span>(<span class="string">'./menu'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>@babel/preset-env</code>已经包含了<code>@babel/plugin-syntax-dynamic-import</code>，因此如果要使用<code>import()</code>语法，只需要配置<code>@babel/preset-env</code>即可。</p>
<p><strong>提示：请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好地初始化依赖，而且更有利于静态分析工具和<code>tree shaking</code>发挥作用。</strong></p>
<p>另外，<code>import()</code>返回的是一个<code>promise</code>对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// menu.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    menu: <span class="string">'menu'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> menu = <span class="keyword">import</span>(<span class="string">'./menu'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(menu); <span class="comment">//Promise &#123;&lt;pending&gt;</span></span><br><span class="line">    menu.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data));<span class="comment">//Module &#123;default: &#123;menu: "menu"&#125;, __esModule: true, Symbol(Symbol.toStringTag): "Module"&#125;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="export-as-ns-from-‘module’"><a href="#export-as-ns-from-‘module’" class="headerlink" title="export * as ns from ‘module’"></a><strong>export * as ns from ‘module’</strong></h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//menu.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">'./info'</span>;</span><br></pre></td></tr></table></figure>



<p>可以理解为是将下面两条语句合并为一句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">'./info'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; ns &#125;;</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，<code>export * as ns from &#39;./info&#39;</code>并不会真正导入模块，因此在该模块（menu.js）中，我们是获取不到ns的。</p>
<h1 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a><strong>Promise.allSettled</strong></h1><p><code>Promise.all</code>或者<code>Promise.race</code>有的时候并不能满足我们的需求。比如，我们需要在所有的<code>promise</code>都结束的时候做一些操作，而并不在乎它们是成功还是失败。在没有<code>Promise.allSettled</code>之前，我们需要自己去写实现。</p>
<p><code>Promise.allSettled()</code>方法返回一个在<strong>所有给定的<code>promise</code>都已经<code>fulfilled</code>或<code>rejected</code>后的<code>promise</code>，并带有一个对象数组，每个对象表示对应的<code>promise</code>结果。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">100</span>, <span class="string">'info'</span>));</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">200</span>, <span class="string">'name'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled([promise1, promise2, promise3]).</span><br><span class="line">    then(<span class="function">(<span class="params">results</span>) =&gt;</span> <span class="built_in">console</span>.log(result));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        &#123; status: 'fulfilled', value: 100 &#125;,</span></span><br><span class="line"><span class="comment">        &#123; status: 'rejected', reason: 'info' &#125;,</span></span><br><span class="line"><span class="comment">        &#123; status: 'fulfilled', value: 'name' &#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><strong>BigInt</strong></h1><p><code>BigInt</code>是一种数字类型，它可以表示任意精度格式的整数。在此之前，JS中安全的最大数字是2^53-1，可在控制台输入<code>Number.MAX_SAFE_INTEGER</code>查看。超过这个值，<strong>JS没有办法精确表示</strong>。另外，大于或等于2的1024次方的数值，<strong>JS无法表示</strong>，会返回<code>Infinity</code>。</p>
<p><code>BigInt</code>则解决了这两个问题。<code>BigInt</code>只用来表示整数，没有位数限制，任何位数的整数都可以精确表示。为了和<code>Number</code>类型进行区分，<code>BigInt</code>类型的数据必须添加后缀n。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Number类型在超过9009199254740991后，计算结果即出现问题</span></span><br><span class="line"><span class="keyword">const</span> num1 = <span class="number">90091992547409910</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num1 + <span class="number">1</span>); <span class="comment">//90091992547409900</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BigInt 计算结果正确</span></span><br><span class="line"><span class="keyword">const</span> num2 = <span class="number">90091992547409910n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2 + <span class="number">1n</span>); <span class="comment">//90091992547409911n</span></span><br></pre></td></tr></table></figure>



<p>还可以使用<code>BigInt</code>对象来初始化<code>BigInt</code>实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(BigInt(<span class="number">999</span>)); <span class="comment">// 999n 注意：没有 new 关键字！！！</span></span><br></pre></td></tr></table></figure>



<p>需要说明的是，<code>BigInt</code>和<code>Number</code>是两种数据类型，不能直接进行四则运算，不过可以进行比较操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">99n</span> == <span class="number">99</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99n</span> === <span class="number">99</span>); <span class="comment">//false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99n</span> + <span class="number">1</span>);<span class="comment">//TypeError: Cannot mix BigInt and other types, use explicit conversionss</span></span><br></pre></td></tr></table></figure>



<h1 id="GlobalThis"><a href="#GlobalThis" class="headerlink" title="GlobalThis"></a><strong>GlobalThis</strong></h1><p>JS中存在一个顶层对象，但是，顶层对象在各种实现里是不统一的。</p>
<p>从不同的JS环境中获取全局对象需要不同的语句。在<code>Web</code>中，可以通过<code>window</code>、<code>self</code>取得全局对象，但是在<code>Web Workers</code>中，只有<code>self</code>可以。在<code>Node.js</code>中，它们都无法获取，必须使用<code>global</code>。</p>
<p>在<code>globalThis</code>之前，我们需要这样去获取全局对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES2020中引入<code>globalThis</code>作为顶层对象，在任何环境中，都可以简单地通过<code>globalThis</code>拿到顶层对象。</p>
<h1 id="Nullish-coalescing-Operator"><a href="#Nullish-coalescing-Operator" class="headerlink" title="Nullish coalescing Operator"></a><strong>Nullish coalescing Operator</strong></h1><p>ES2020新增了一个运算符??。当左操作数为<code>null</code>或者<code>undefined</code>时，返回其右侧操作数，否则返回左侧操作数。</p>
<p>使用||操作符，当左侧的操作数为<code>0</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>false</code>、<code>&#39;&#39;</code>时，都会使用右侧的操作数。如果使用||来为某些变量设置默认值，可能会遇到意料之外的行为。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultValue = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> value = someValue || defaultValue;</span><br><span class="line"><span class="comment">//当 someValue 转成 boolean 值为 false 时，value 的值都是 defaultValue</span></span><br></pre></td></tr></table></figure>

<p>当someValue的值为0时，我们其实期望value值为0，但是它被错误分配成100。</p>
<p>??操作符可以规避以上问题，它只有在左操作数为<code>null</code>或者是<code>undefined</code>时，才会返回右操作数。</p>
<h1 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a><strong>Optional Chaining</strong></h1><p>可选链操作符?.允许读取位于连接对象链深处的属性的值，而不必明确验证链中每一个引用是否有效。</p>
<p>例如，我们要访问info对象的animal的reptile的tortoise。但是我们不确定animal，reptile是否存在，因此我们需要这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tortoise = info.animal &amp;&amp; info.animal.reptile &amp;&amp; info.animal.reptile.tortoise;</span><br></pre></td></tr></table></figure>

<p>因为null.reptile或undefined.reptile会抛出错误：<code>TypeError: Cannot read property &#39;reptile&#39; of undefined/null</code>。如果我们需要访问的属性更深，那么这句代码会越来越长。</p>
<p>而有了可选链操作符?.，我们在访问reptile之前，不再需要校验info.animal的值。同样，在访问info.animal.reptile.tortoise之前，也不需要校验info.animal.reptile的值。</p>
<p>上面的代码简化为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tortoise = info.animal?.reptile?.tortoise;</span><br></pre></td></tr></table></figure>

<p>JS在尝试访问info.animal.reptile之前，会隐式检查并确定info.animal的值不是null或undefined，如果其值是null或undefined，那么表达式短路计算直接返回undefined。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 圣杯布局和双飞翼布局</title>
    <url>/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="CSS-圣杯布局和双飞翼布局"><a href="#CSS-圣杯布局和双飞翼布局" class="headerlink" title="CSS 圣杯布局和双飞翼布局"></a>CSS 圣杯布局和双飞翼布局</h1><p>两个常见的前端布局。圣杯布局和双飞翼布局作为经典的三栏式布局是面试中的常客。两种布局达到效果上基本相同，都是<strong>两边两栏宽度固定，中间栏宽度自适应</strong>。在HTML结构上<strong>中间栏在最前面</strong>保证了最先渲染中间提升性能（因为这两种布局都比较老，我认为在现代浏览器中这点儿性能优化效果并不是很大），并且兼容性良好。两种布局的实现方法前半部分相同，后半部分的实现各有利弊，下面会简单介绍两者的区别。</p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>, <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line">            background-color: skyblue;</span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:60px</span>;  <span class="comment">/*文字水平垂直居中*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;  <span class="comment">/*因为内部都是浮动元素，所以要设置overflow来撑起父元素*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span> 100<span class="selector-tag">px</span>;  <span class="comment">/*左右内边距为100px*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">            background-color: peachpuff; </span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">            line-height: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            background-color: lightgreen;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100</span>%;  <span class="comment">/*让left前移一行*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">left</span><span class="selector-pseudo">:-100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            background-color: pink;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100px</span>; <span class="comment">/*right只需要前移right的宽度即可*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;  <span class="comment">/*container设置了padding,所以要相对定位移动才能将left和right移动到对应的位置*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">right</span><span class="selector-pseudo">:-100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/1.png" class>



<p>实现原理：</p>
<ol>
<li><p>设置父元素<code>container</code>为<code>overflow:hidden</code>，撑起父元素，子元素<code>main</code>、<code>left</code>、<code>right</code>均设为<code>float:left</code>，浮动起来。效果如下：</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/2.png" class>
</li>
<li><p>为了让<code>main</code>模块自适应，将其设为100%</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/3.png" class>
</li>
<li><p>为了让<code>left</code>和<code>right</code>模块跑上去，设置<code>left</code>模块的<code>margin:-100%</code>，可以理解为：负的话就是向上前进，正值的话就是直接的间隔；<code>right</code>模块就设置为<code>margin:-100px</code>，大小为<code>right</code>模块的宽度</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/4.png" class>
</li>
<li><p>为了使<code>main</code>模块往里收，设置<code>.container{ padding: 0 100px}</code>，即设置左右内边距。</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/5.png" class>



</li>
</ol>
<ol start="5">
<li><p>利用相对定位移动left和right</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/6.png" class>





</li>
</ol>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>, <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line">            background-color: skyblue;</span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">            background-color: peachpuff;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.inner-main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:100px</span>;  <span class="comment">/*通过在main内部再设置一个div来进行左右模块的间隔布局*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-right</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            background-color: lightgreen;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            background-color: yellow;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/7.png" class>

<p>实现原理：</p>
<p>双飞翼布局则不设置<code>container</code>里的<code>padding</code>属性，而是通过在<code>main</code>模块中添加<code>inner-main</code>模块，然后对这个<code>div</code>进行<code>margin-left</code>和<code>margin-right</code>计算。</p>
<h2 id="圣杯布局和双飞翼布局的主要区别："><a href="#圣杯布局和双飞翼布局的主要区别：" class="headerlink" title="圣杯布局和双飞翼布局的主要区别："></a>圣杯布局和双飞翼布局的主要区别：</h2><ul>
<li>圣杯布局是设置<code>container</code>的<code>padding</code>属性以及<code>left</code>和<code>right</code>模块的<code>position:relative</code>，<code>left:-100px</code>或<code>right:-100px</code></li>
<li>双飞翼布局则不设置<code>container</code>里的<code>padding</code>属性，而是通过在<code>main</code>模块中添加<code>inner-main</code>模块，然后对这个<code>div</code>进行<code>margin-left</code>和<code>margin-right</code>计算</li>
</ul>
<p>参考：<a href="https://segmentfault.com/a/1190000004579886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004579886</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this解析</title>
    <url>/2020/01/13/JavaScript-this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h4><p><code>this</code>提供了一种更优雅的方式来隐式“传递”一个对象引用。</p>
<p>看下面的例子：</p>
<p>没有使用this的情况下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> me=&#123;</span><br><span class="line">    name:<span class="string">"Kyle"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you=&#123;</span><br><span class="line">    name:<span class="string">"Reader"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> greeting=<span class="string">"Hello, I'm "</span>+identify(context);</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">identify(you); <span class="comment">//READER</span></span><br><span class="line">speak(me); <span class="comment">//hello, I'm KYLE</span></span><br></pre></td></tr></table></figure>



<p>使用了this的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting=<span class="string">"Hello, I'm "</span>+identify.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me); <span class="comment">//KYLE</span></span><br><span class="line">identify.call(you); <span class="comment">//READER</span></span><br><span class="line">speak.call(me); <span class="comment">//Hello, I'm KYLE</span></span><br><span class="line">speak.call(you); <span class="comment">//Hello, I'm READER</span></span><br></pre></td></tr></table></figure>

<p>表达上更加的简洁。如果不使用this的话，就需要给identify()和speak()显式传入一个上下文对象。</p>
<br>

<h4 id="this绑定对象的规则"><a href="#this绑定对象的规则" class="headerlink" title="this绑定对象的规则"></a>this绑定对象的规则</h4><p>我们可以顺序应用下面四条规则来判断this的绑定对象：</p>
<ol>
<li>如果是由<code>new</code>调用，绑定到新创建的对象。</li>
<li>如果是由<code>call</code>或者<code>apply</code>、<code>bind</code>调用，绑定到指定的对象上。</li>
<li>如果是由上下文对象调用（即this是对象中的方法里使用的），绑定到那个上下文对象上。</li>
<li>如果是默认情况下，严格模式绑定到undefined，否则绑定到全局对象上。</li>
</ol>
<p>但是ES6中的箭头函数并不会使用者四条标准的绑定规则。箭头函数会继承外层函数调用的this绑定。<br><br></p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a><code>new</code>绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar=<span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>我们使用<code>new</code>来调用foo(…)时，会构造一个新对象并把它绑定到foo(…)调用中的this上。<br><br><br><br></p>
<h4 id="显式绑定call、apply、bind"><a href="#显式绑定call、apply、bind" class="headerlink" title="显式绑定call、apply、bind"></a>显式绑定<code>call</code>、<code>apply</code>、<code>bind</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><code>call</code>用来将函数foo中的this绑定到obj上。<br><br><br><br></p>
<h4 id="隐式绑定（上下文对象调用）"><a href="#隐式绑定（上下文对象调用）" class="headerlink" title="隐式绑定（上下文对象调用）"></a>隐式绑定（上下文对象调用）</h4><p>如果<code>this</code>所在的函数是对象中的方法的话，this就会指向这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><code>foo</code>此时是obj对象的一个方法，所以<code>this</code>就会指向obj。</p>
<p>但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">	a:<span class="number">42</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	obj2:obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo();  <span class="comment">//42</span></span><br></pre></td></tr></table></figure>
<br>

<p>隐式丢失也是<code>this</code>隐式绑定中常见的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar=obj.foo;  <span class="comment">//函数别名！</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops, global"</span>;  <span class="comment">//a是全局对象的属性</span></span><br><span class="line">bar();  <span class="comment">//“oops, global”</span></span><br></pre></td></tr></table></figure>
<p>此时<code>bar</code>是<code>obj.foo</code>的一个引用，但实际上它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<br>

<p>回调函数丢失<code>this</code>绑定是也是非常常见的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	fn();  <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops global"</span>;  <span class="comment">//全局对象属性</span></span><br><span class="line">doFoo(obj.foo);  <span class="comment">//"oops global"</span></span><br></pre></td></tr></table></figure>
<p>函数<code>doFoo</code>传入了函数作为参数，并在<code>doFoo</code>中调用。我们可以把它看做将函数copy到了<code>doFoo</code>函数体中，调用的时候<code>this</code>指向的是全局作用域。<br><br><br><br></p>
<h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。</p>
<p>例一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar=obj.foo;  <span class="comment">//函数别名！把函数体赋值了</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops,global"</span>;  <span class="comment">//a是全局对象的属性</span></span><br><span class="line">bar(); <span class="string">"oops, global"</span></span><br></pre></td></tr></table></figure>

<p>bar实际上它引用的是foo函数本身。</p>
<p>例二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops, global"</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line">doFoo(obj.foo); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>

<p>参数传递实际上是一种隐式赋值，因此我们传入函数时也会被隐式赋值。</p>
<p>例三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops, global"</span>;</span><br><span class="line">setTimeout(obj.foo,<span class="number">100</span>); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>

<p>回调函数丢失this绑定是非常常见的！</p>
<p>栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="string">"a"</span>,</span><br><span class="line">    cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log( <span class="keyword">this</span>.id );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> id = <span class="string">"b"</span></span><br><span class="line">obj.cool(); <span class="comment">// a</span></span><br><span class="line">setTimeout( obj.cool, <span class="number">100</span> ); <span class="comment">// b</span></span><br></pre></td></tr></table></figure>







<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">foo();  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，函数调用应用了this的默认绑定，this指向全局对象。</p>
<p>如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，<code>this</code>会绑定到<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">foo();  <span class="comment">//TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<br>
<br>

<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的<code>this</code></h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">	a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">	a:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar=foo.call(obj1);</span><br><span class="line">bar.call(obj2);  <span class="comment">//2,不是3！</span></span><br></pre></td></tr></table></figure>
<p><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于<code>foo()</code>的<code>this</code>绑定到<code>obj1</code>，所以bar（引用箭头函数）的<code>this</code>也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改。</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>
<p><code>foo</code>调用时传入的是什么对象，this就指向谁。<strong>如果是普通函数，执行时this应该指向全局对象window，这时应该输出21</strong>（严格模式则输出undefined）。</p>
<p>如果foo函数内部是普通函数的话：</p>
<p><img src="/images/loading.png" data-original="C:%5CUsers%5Calice%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200205154039804.png" alt="image-20200205154039804"></p>
<p>由此可以看出，foo函数的<code>this</code>是指向<code>call</code>传入的对象<code>{id:42}</code>，但是foo函数内部的<code>setTimeout</code>函数中的<code>this</code>是指向全局的。</p>
<br>

<p>参考书籍：《你不知道的JavaScript》 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript之变量提升</title>
    <url>/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>今天面试的时候被问到了变量提升的问题，一脸懵逼，掌握得不够熟练，写篇博客来总结一下。</p>
<h2 id="JS代码解析规则"><a href="#JS代码解析规则" class="headerlink" title="JS代码解析规则"></a>JS代码解析规则</h2><ul>
<li>第一步为解释：先扫描所有的JS代码，把所有声明提升到顶端。</li>
<li>第二步为执行：执行就是操作一类的。</li>
</ul>
<br>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>例一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为有变量提升，上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><h4 id="函数声明的两种方式"><a href="#函数声明的两种方式" class="headerlink" title="函数声明的两种方式"></a>函数声明的两种方式</h4><ul>
<li><p>函数声明式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>函数字面量式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：函数字面量式的提升和变量提升一样，都是只提升声明，不提升赋值，比如上面代码中函数字面量式，只会把<code>var bar</code>提升上去，但是函数声明式是会将整个函数体都提升上去。</strong></p>
<br>

<p>例二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();  <span class="comment">//aaa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为存在函数声明提升，函数声明提升会直接把整个函数提升到执行环境的最顶端。相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>



<p><strong>注意：变量提升只提升变量名，而函数提升是会提升整个函数体。函数提升在变量提升之前。</strong></p>
<br>

<p>例三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//foo is not a function</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/1.png" class>



<p>因为进行了变量提升（函数字面量式），上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo();</span><br><span class="line">foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS解析在遇到foo()时会默认当做函数来解析，所以会输出foo is not a function。</p>
<br>

<p>例四：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">var</span> foo=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/2.png" class>



<p>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">//foo()&#123;console.log(10);&#125;</span></span><br><span class="line">foo=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>第一个console.log(foo)之所以输出函数体，是因为<code>var foo</code>只是声明（提升了的声明），并没有赋值，所以它会调用上面的函数体。</p>
<br>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>先看一道经典面试题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(v1);</span><br><span class="line"><span class="keyword">var</span> v1 = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);</span><br><span class="line">	<span class="keyword">var</span> v1 = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(v1);</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;undefined</span><br><span class="line">&#x2F;&#x2F;undefined</span><br><span class="line">&#x2F;&#x2F;200</span><br><span class="line">&#x2F;&#x2F;100</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1;</span><br><span class="line"><span class="built_in">console</span>.log(v1); <span class="comment">//undefined</span></span><br><span class="line">v1=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v1;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);  <span class="comment">//undefined</span></span><br><span class="line">	v1=<span class="number">200</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);  <span class="comment">//200</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(v1);  <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，如果内部没有声明v1的时候，函数才会到全局作用域去查找变量的赋值。但是如果函数作用域内部定义了的话，就不会到全局作用域去找。参照作用域链的定义。</strong></p>
<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/3.png" class>

<br>

<p>看一道字节面试时候的题目：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'byte'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">'dance'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="string">'bytedance'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;dance</span><br><span class="line">&#x2F;&#x2F;byte</span><br></pre></td></tr></table></figure>

<p>上面代码实际效果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line">	<span class="keyword">if</span>(a===<span class="literal">undefined</span>)&#123;</span><br><span class="line">		a=<span class="string">'dance'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		a=<span class="string">'bytedance'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a=<span class="string">'byte'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>在当前作用域有对变量进行声明的时候，是不会去上一级作用域去寻找变量的声明的。</p>
<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/4.png" class>

<p>因为console.log(a)在当前函数作用域找到了<code>var a;</code>，即a的定义，所以它不会去全局作用域去找a的声明（及值）。</p>
<p>上面的代码也是这个道理，<code>a===undefined</code>会找到当前函数作用域的<code>var a;</code>的定义，所以a的值为undefined。</p>
<br>

<p>参考：<a href="https://blog.csdn.net/qq_39712029/article/details/80951958" target="_blank" rel="noopener">https://blog.csdn.net/qq_39712029/article/details/80951958</a></p>
<p>​            <a href="https://blog.csdn.net/Demo_18/article/details/78493489" target="_blank" rel="noopener">https://blog.csdn.net/Demo_18/article/details/78493489</a></p>
<br>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js——Express和koa框架对比</title>
    <url>/2020/04/07/Node-js%E2%80%94%E2%80%94Express%E5%92%8Ckoa%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<blockquote>
<p>此文参考：阿里技术协会《Node.js框架之<code>express</code>与<code>koa</code>对比分析》</p>
<p><a href="https://yq.aliyun.com/articles/3062" target="_blank" rel="noopener">https://yq.aliyun.com/articles/3062</a></p>
</blockquote>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407140734.png" style="zoom:200%;">

]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块化编程</title>
    <url>/2020/01/14/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h1><p>目录：</p>
<ul>
<li>AMD</li>
<li>CMD</li>
<li><code>commom.js</code></li>
<li>ES6 Module</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是<strong>依赖前置，提前执行</strong>。AMD一开始是<code>CommonJS</code>规范中的一个草案，即异步模块加载机制。后来由该草案的作者以<code>RequireJS</code>实现了AMD规范，所以一般说AMD也是指<code>RequireJS</code>。</p>
<h4 id="AMD的基本语法"><a href="#AMD的基本语法" class="headerlink" title="AMD的基本语法"></a><code>AMD</code>的基本语法</h4><p>通过<code>define</code>来定义一个模块，使用<code>require</code>可以导入定义的模块。</p>
<p>用<code>define</code>定义无依赖的模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="comment">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>用<code>define</code>定义有依赖的模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">"alpha"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"> alpha </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        verb : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> alpha.verb() + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>用<code>require</code>进行模块加载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">　math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="AMD的特点"><a href="#AMD的特点" class="headerlink" title="AMD的特点"></a><code>AMD的特点</code></h4><p>对于依赖的模块，AMD推崇<strong>依赖前置，提前执行。</strong>也就是定义模块和加载模块都要在一开始就把依赖写好。例如<code>define</code>函数当中的<code>[&quot;alpha&quot;]</code>，就是定义模块当中的依赖；<code>require</code>函数当中的<code>[&quot;math&quot;]</code>是加载模块当中的依赖。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD是<strong>依赖就近，延迟执行</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//依赖一开始就写好</span></span><br><span class="line">    a.test();</span><br><span class="line">    b.test();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.test();</span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//软依赖</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>CMD</code>是在用到了某个模块的时候再去<code>require</code>，类似按需加载。</p>
<h4 id="CMD的特点"><a href="#CMD的特点" class="headerlink" title="CMD的特点"></a><code>CMD的特点</code></h4><p>对于依赖的模块，CMD推崇<strong>依赖就近，延迟执行</strong>。也就是说，只有到<code>require</code>时依赖模块才执行。</p>
<p>摘自：<a href="https://segmentfault.com/a/1190000004873947" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004873947</a></p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><code>CommonJS</code></h2><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>通过<code>module.exports</code>或者<code>exports</code>来输出模块</li>
<li>通过<code>require</code>来导入模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"></span><br><span class="line">a();<span class="comment">//"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a2.js</span></span><br><span class="line">exports.num = <span class="number">1</span>;</span><br><span class="line">exports.obj = &#123;<span class="attr">xx</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2.js</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="built_in">require</span>(<span class="string">'./a2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2);<span class="comment">//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="CommonJS的特点"><a href="#CommonJS的特点" class="headerlink" title="CommonJS的特点"></a><code>CommonJS</code>的特点</h4><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块都是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果。如果想要再次执行，可清楚缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化不会影响这个值</li>
</ul>
<h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><h4 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h4><ul>
<li><code>export</code>或<code>export default</code>来输出模块</li>
<li><code>import</code>来导入模块</li>
</ul>
<p>（<code>export default</code>就是能够为导入的模块自定义名称，这样就不用知道模块在原本的<code>js</code>文件当中的名字，按名字导入了）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'lin'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">var</span> job = <span class="string">'ninja'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, age, job&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, job&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, age, job);<span class="comment">// lin 13 ninja</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a2.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'default '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./a2.js'</span>;</span><br><span class="line">customName(); <span class="comment">// 'default'</span></span><br></pre></td></tr></table></figure>



<h4 id="ES6-Module的特点（对比CommonJS）"><a href="#ES6-Module的特点（对比CommonJS）" class="headerlink" title="ES6 Module的特点（对比CommonJS）"></a>ES6 Module的特点（对比<code>CommonJS</code>）</h4><ul>
<li><code>CommonJS</code>模块是运行时加载，ES6 Module是编译时输出接口；</li>
<li><code>CommonJS</code>加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口（对应名字单独加载，加载这个模块想=需要的）；</li>
<li><code>CommonJS</code>输出是值的拷贝，ES6 Module输出的是值的引用，被输出模块的内部的改变会影响引用的改变；</li>
<li><code>CommonJS</code> <code>this</code>指向当前模块，ES6 Module <code>this</code>指向<code>undefined</code>;</li>
</ul>
<p>参考：<a href="https://juejin.im/post/5db95e3a6fb9a020704bcd8d" target="_blank" rel="noopener">https://juejin.im/post/5db95e3a6fb9a020704bcd8d</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Math.floor()和~~运算符的异同</title>
    <url>/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>今天在用JavaScript实现大数相加的时候，发现网上的解法当中有使用<code>~~</code>运算符，之前没有见过。在网上一查，说是<code>Math.floor()</code>的更好的一种表示方法，运行速度更快。但是将大数相加的代码中的<code>~~</code>换成<code>Math.floor()</code>发觉得不到正确的答案，所以想来分析一下异同。</p>
<h2 id="和"><a href="#和" class="headerlink" title="~和~~"></a><code>~</code>和<code>~~</code></h2><h4 id="运算符"><a href="#运算符" class="headerlink" title="~运算符"></a><code>~</code>运算符</h4><p>用于将整数变为<code>-(N+1)</code>。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~2 &#x3D;&#x3D;&#x3D; -3; &#x2F;&#x2F;true</span><br><span class="line">~1 &#x3D;&#x3D;&#x3D; -2; &#x2F;&#x2F;true</span><br><span class="line">~0 &#x3D;&#x3D;&#x3D; -1; &#x2F;&#x2F;true</span><br><span class="line">~-1 &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="~~运算符"></a><code>~~</code>运算符</h4><p><code>~~</code>是<code>Math.floor()</code>的一个替代，相同的操作但是更快。可以使用它将任何浮点数转换为整数（下取整）。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~2 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2</span><br><span class="line">~~2.4 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2</span><br><span class="line">~~3.9 &#x3D;&#x3D;&#x3D; Math.floor(3); &#x2F;&#x2F;true, 3</span><br></pre></td></tr></table></figure>



<p><code>~~</code>和<code>Math.floor()</code>在性能上的不同：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Browser</th>
<th>Math.floor()</th>
<th>Bitwise double NOT ~~</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>Firefox 7.0.1</td>
<td>42ms</td>
<td>29ms</td>
</tr>
<tr>
<td>#2</td>
<td>Firefox 7.0.1</td>
<td>44ms</td>
<td>28ms</td>
</tr>
<tr>
<td>#3</td>
<td>Chrome 15</td>
<td>63ms</td>
<td>64ms</td>
</tr>
<tr>
<td>#4</td>
<td>Chrome 15</td>
<td>63ms</td>
<td>68ms</td>
</tr>
<tr>
<td>#5</td>
<td>IE8</td>
<td>265ms</td>
<td>192ms</td>
</tr>
<tr>
<td>#6</td>
<td>IE8</td>
<td>324ms</td>
<td>190ms</td>
</tr>
</tbody></table>
<br>



<h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><p>在大数相加时，使用<code>~~</code>能够的到正确的结果：</p>
<img src="/images/loading.png" data-original="/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/1.png" class>



<p>但是使用<code>Math.floor()</code>时，结果是：</p>
<img src="/images/loading.png" data-original="/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/2.png" class>



<p>主要是因为当a数组已经pop完毕之后，再对a执行pop操作时，输出的是undefined。而<code>~~</code>操作undefined和<code>Math.floor()</code>操作undefined是会得出不同的结果的：</p>
<img src="/images/loading.png" data-original="/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/3.png" class>

<p>所以才会导致上面的结果。</p>
<br>

<p>参考：<a href="http://rocha.la/JavaScript-bitwise-operators-in-practice" target="_blank" rel="noopener">http://rocha.la/JavaScript-bitwise-operators-in-practice</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node——Gulp基于流的自动化构建工具</title>
    <url>/2020/04/03/Node%E2%80%94%E2%80%94Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="用Gulp实现自动化"><a href="#用Gulp实现自动化" class="headerlink" title="用Gulp实现自动化"></a>用Gulp实现自动化</h2><p>Gulp是基于流的构建系统。我们可以通过对这些流的引导来创建构建过程，除了<strong>转译</strong>和<strong>缩码</strong>，还能做很多事情。</p>
<p>Gulp之所以能实现高度重用，主要归功于两项技术：使用插件和自定义构建任务。Gulp的构建过程是一个流，所以这些任务和插件是可以一个接一个拼在一起的。</p>
<h2 id="把Gulp添加到项目中"><a href="#把Gulp添加到项目中" class="headerlink" title="把Gulp添加到项目中"></a>把Gulp添加到项目中</h2><p>添加Gulp需要用<code>npm</code>安装<code>gulp-cli</code>和<code>gulp</code>两个包。下面这段代码中，全局安装<code>gulp-cli</code>，并创建一个带有<code>Gulp</code>开发依赖项的新Node项目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --global gulp-cli</span><br><span class="line">npm init -y</span><br><span class="line">npm i -save-dev gulp</span><br></pre></td></tr></table></figure>

<p>接着创建<code>gulpfile.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch gulpfile.js</span><br></pre></td></tr></table></figure>

<blockquote>
<p>touch为<code>linux</code>指令</p>
</blockquote>
<p>现在用Gulp构建一个小型的React项目。这里会用到<code>gulp-babel</code>、<code>gulp-sourcemaps</code>和<code>gulp-concat</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save-dev gulp-sourcemaps gulp-babel babel-preset-es2015</span><br><span class="line">npm i --save-dev gulp-concat react react-dom babel-preset-react</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意的是，安装<code>gulp-babel</code>的时候要安装7版本的，后续还要安装<code>babel-core</code>。如果直接安装，是安装8版本，<code>babel-core</code>是7，就会出错。</p>
</blockquote>
<h2 id="Gulp任务的创建及运行"><a href="#Gulp任务的创建及运行" class="headerlink" title="Gulp任务的创建及运行"></a>Gulp任务的创建及运行</h2><p>创建Gulp任务需要在<code>gulpfile.js</code>中编写Node代码，调用<code>Gulp</code>的API。<code>Gulp</code>的API可以做很多事情，比如查找文件，把对文件进行某种转换的插件拼到一起等。</p>
<p>打开<code>gulpfile.js</code>设置一个构建任务，用<code>gulp.src</code>查找JSX文件，用Babel处理<code>ES6</code>和<code>React</code>，然后把这些文件拼到一起。</p>
<p><code>gulpfile.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp=<span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> sourcemaps=<span class="built_in">require</span>(<span class="string">'gulp-sourcemaps'</span>);</span><br><span class="line"><span class="keyword">const</span> babel=<span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> concat=<span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'app/*.jsx'</span>)</span><br><span class="line">        .pipe(sourcemaps.init())</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets:[<span class="string">'es2015'</span>,<span class="string">'react'</span>]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(concat(<span class="string">'all.js'</span>))</span><br><span class="line">        .pipe(sourcemaps.write(<span class="string">'.'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist'</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gulp.src</code>：<code>Gulp</code>自带的文件聚集工具，查找所有的<code>React</code> jsx文件</li>
<li><code>sourcemaps.init()</code>：开始监视源文件，为调试构建源码映射</li>
<li><code>concat(&#39;all.js&#39;)</code>：把所有源码文件拼到一个<code>all.js</code>中</li>
<li><code>soucemaps.write(&#39;.&#39;)</code>：单独写入源码映射文件</li>
<li><code>gulp.dest(&#39;dist&#39;)</code>：将所有文件放到<code>dist/</code>目录下</li>
</ul>
<p>创建一个名为<code>app/index.jsx</code>的文件，就可以试验一下<code>Gulp</code>了。可以用下面这段JSX代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;Hello,world!&lt;<span class="regexp">/h1&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('example')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>



<p>在终端运行<code>gulp</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[10:21:44] Using gulpfile ~\Desktop\大三\实习\笔记\Node.js\gulp_test\gulpfile.js</span><br><span class="line">[10:21:44] Starting &#39;default&#39;...</span><br><span class="line">[10:21:44] Finished &#39;default&#39; after 213 ms</span><br></pre></td></tr></table></figure>



<p>目录：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200403115724.png" alt></p>
<p>打包生成的<code>all.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react2 = _interopRequireDefault(_react);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _reactDom = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _reactDom2 = _interopRequireDefault(_reactDom);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; &#125;</span><br><span class="line"></span><br><span class="line">_reactDom2.default.render(_react2.default.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'Hello,world'</span></span><br><span class="line">), <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>));</span><br><span class="line"><span class="comment">//# sourceMappingURL=all.js.map</span></span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Gulp中，用JavaScript表示构建阶段很容易。并且我们可以用<code>gulp.task()</code>往这个文件里添加自己的任务。这些任务通常都遵循相同的模式。</p>
<ol>
<li>源文件：收集输入文件</li>
<li>转译：让它们依次通过一个个对它们进行转换的插件</li>
<li>合并：把这些文件合到一起，创建一个整体构建文件</li>
<li>输出：设定文件的目标地址或移动输出文件</li>
</ol>
<blockquote>
<p>在前面那个例子中，<code>sourcemaps</code>是个特例，因为它需要两次pipe：第一次是配置，最后一次是输出文件。</p>
</blockquote>
<br>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node——串行化/并行化流程控制</title>
    <url>/2020/04/01/Node%E2%80%94%E2%80%94%E4%B8%B2%E8%A1%8C%E5%8C%96-%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="异步逻辑的顺序化"><a href="#异步逻辑的顺序化" class="headerlink" title="异步逻辑的顺序化"></a>异步逻辑的顺序化</h2><p>在异步程序的执行过程中，有些任务可能会随时发生，跟程序中的其他部分在做什么没关系，什么时候做这些任务都不会出问题。但有些任务只能在某些特定的任务之前或之后做。</p>
<p>让一组异步任务顺序执行的概念被Node社区称为<strong>流程控制</strong>。这种控制分为两类：<strong>串行</strong>和<strong>并行</strong>。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/0401_1.jpg" alt></p>
<ul>
<li>串行任务：需要一个接着一个执行的任务</li>
<li>并行任务：不需要一个接着一个执行的任务。这些任务彼此之间开始和结束时间并不重要，<strong>但在后续逻辑执行前它们应该全部执行完成</strong>。</li>
</ul>
<br>



<h2 id="实现串行化流程控制"><a href="#实现串行化流程控制" class="headerlink" title="实现串行化流程控制"></a>实现串行化流程控制</h2><p>为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组起到队列的作用：完成一个任务后按顺序从数组中取出下一个。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/0401_2.JPG" alt></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>做一个小程序，让它从一个随机选择的RSS预订源中获取一篇文章的标题和URL，并显示出来。RSS预订源列表放在一个文本文件中。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;rss_feeds.txt</span><br><span class="line">http:&#x2F;&#x2F;www.read.org.cn&#x2F;feed</span><br><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;feed&#x2F;blog.xml</span><br></pre></td></tr></table></figure>

<p>这个<code>rss_feeds.txt</code>放在文件夹<code>sequence</code>中。</p>
<p>从<code>npm</code>存储库中下载两个辅助模块。在<code>sequence</code>文件目录下，<code>terminal</code>中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install --save request@2.60.0</span><br><span class="line">npm install --save htmlparser@1.7.7</span><br></pre></td></tr></table></figure>

<p><code>request</code>模块是个经过简化的HTTP客户端，你可以用它获取RSS数据。<code>htmlparser</code>模块能把原始的RSS数据转换成<code>JavaScript</code>数据结构。</p>
<p>然后再目录下创建<code>index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> request=<span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlparser=<span class="built_in">require</span>(<span class="string">'htmlparser'</span>);</span><br><span class="line"><span class="keyword">const</span> configFilename=<span class="string">'./rss_feeds.txt'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保包含RSS预订源URL列表的文件存在</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkForRSSFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.exists(configFilename,(exists)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(!exists)&#123;</span><br><span class="line">            <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Missing RSS file:<span class="subst">$&#123;configFilename&#125;</span>`</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        next(<span class="literal">null</span>,configFilename);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取并解析包含预订源URL的文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readRSSFile</span>(<span class="params">configFilename</span>)</span>&#123;</span><br><span class="line">    fs.readFile(configFilename,(err,feedList)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            <span class="keyword">return</span> next(err);</span><br><span class="line">        &#125;</span><br><span class="line">        feedList=feedList.toString().replace(<span class="regexp">/^\s+|\s+$/g</span>,<span class="string">''</span>).split(<span class="string">'\n'</span>);</span><br><span class="line">        <span class="comment">//从预订源URL数组中随机选择一个预订源URL</span></span><br><span class="line">        <span class="keyword">const</span> random=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*feedList.length); </span><br><span class="line">        next(<span class="literal">null</span>,feedList[random]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向选定的预订源发送HTTP请求以获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadRSSFeed</span>(<span class="params">feedUrl</span>)</span>&#123;</span><br><span class="line">    request(&#123;<span class="attr">uri</span>:feedUrl&#125;,(err,res,body)=&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> next(err);</span><br><span class="line">        <span class="keyword">if</span>(res.statusCode!==<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Abnormal response status code'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        next(<span class="literal">null</span>,body);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将预订源数据解析到一个条目数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseRSSFeed</span>(<span class="params">rss</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler=<span class="keyword">new</span> htmlparser.RssHandler();</span><br><span class="line">    <span class="keyword">const</span> parser=<span class="keyword">new</span> htmlparser.Parser(handler);</span><br><span class="line">    parser.parseComplete(rss);</span><br><span class="line">    <span class="keyword">if</span>(!handler.dom.items.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No RSS items found'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> item=handler.dom.items.shift();</span><br><span class="line">    <span class="comment">//如果有数据，显示第一个预订源条目的标题和URL</span></span><br><span class="line">    <span class="built_in">console</span>.log(item.title);</span><br><span class="line">    <span class="built_in">console</span>.log(item.link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把所有要做的任务按执行顺序添加到一个数组中</span></span><br><span class="line"><span class="keyword">const</span> tasks=[</span><br><span class="line">    checkForRSSFile,</span><br><span class="line">    readRSSFile,</span><br><span class="line">    downloadRSSFeed,</span><br><span class="line">    parseRSSFeed</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//负责执行任务的next函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err,result</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> currentTask=tasks.shift(); <span class="comment">//从任务数组中取出下个任务</span></span><br><span class="line">    <span class="keyword">if</span>(currentTask)&#123;</span><br><span class="line">        currentTask(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">next(); <span class="comment">//开始执行</span></span><br></pre></td></tr></table></figure>

<p>串行化执行的实现是通过一个数组<code>tasks</code>去承载要执行的任务。首先通过<code>tasks.shift()</code>方法从<code>tasks</code>数组中取出第一个任务<code>checkForRSSFile</code>，在执行这个任务的时候，它内部又调用了<code>next</code>方法，使得我们能够执行下一个任务，以此类推。这个负责执行任务的<code>next</code>函数会多次执行。</p>
<p>执行<code>node index.js</code>，输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">《聪明人用方格笔记术》“黄金三分法”</span><br><span class="line">http:&#x2F;&#x2F;www.read.org.cn&#x2F;html&#x2F;2438-cong-ming-ren-yong-fang-ge-bi-ji-shu-huang-jin-san-fen-fa.html</span><br></pre></td></tr></table></figure>

<br>



<h2 id="实现并行化流程控制"><a href="#实现并行化流程控制" class="headerlink" title="实现并行化流程控制"></a>实现并行化流程控制</h2><p>为了让异步任务并行执行，仍然是要把任务放在数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续逻辑。</p>
<p>这里的例子就做一个简单的程序，读取几个文本文件的内容，并输出单词在整个文件中出现的次数。我们会用异步的<code>readFile</code>函数读取文本文件的内容，所以几个文件的读取可以并行执行。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/0401_3.JPG" alt></p>
<p>这是目录组成：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200401115608.png" alt></p>
<p><code>1.txt</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do you love me</span><br></pre></td></tr></table></figure>

<p><code>2.txt</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes i do love you</span><br></pre></td></tr></table></figure>



<p><code>word_count.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> tasks=[];</span><br><span class="line"><span class="keyword">const</span> wordCounts=&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> filesDir=<span class="string">'../text'</span>;</span><br><span class="line"><span class="keyword">let</span> completedTasks=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIfComplete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    completedTasks++;</span><br><span class="line">    <span class="keyword">if</span>(completedTasks===tasks.length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> wordCounts)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;index&#125;</span>:<span class="subst">$&#123;wordCounts[index]&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addWordCount</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">    wordCounts[word]=(wordCounts[word])?wordCounts[word]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countWordsInText</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> words=text.toString().toLowerCase().split(<span class="regexp">/\W+/</span>).sort();</span><br><span class="line">    words.filter(<span class="function"><span class="params">word</span>=&gt;</span>word).forEach(<span class="function"><span class="params">word</span>=&gt;</span>addWordCount(word));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readdir(filesDir,(err,files)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//task函数声明，是立即执行的，获取filename</span></span><br><span class="line">        <span class="keyword">const</span> task=(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                fs.readFile(file,(err,text)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> err;</span><br><span class="line">                    &#125;</span><br><span class="line">                    countWordsInText(text);</span><br><span class="line">                    checkIfComplete();</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(<span class="string">`<span class="subst">$&#123;filesDir&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">        <span class="comment">//将当前tast push到tasks数组中</span></span><br><span class="line">        tasks.push(task);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//开始并行执行所有任务</span></span><br><span class="line">    tasks.forEach(<span class="function"><span class="params">task</span>=&gt;</span>task());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>执行<code>node word_count.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do:2</span><br><span class="line">i:1</span><br><span class="line">love:2</span><br><span class="line">yes:1</span><br><span class="line">you:2</span><br><span class="line">me:1</span><br></pre></td></tr></table></figure>

<br>

]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise实现任务顺序执行&amp;并行执行&amp;发起ajax请求</title>
    <url>/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="Promise实现任务并行执行"><a href="#Promise实现任务并行执行" class="headerlink" title="Promise实现任务并行执行"></a>Promise实现任务并行执行</h2><p>使用<code>Promise.all</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'hi'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p=<span class="built_in">Promise</span>.all([p1,p2]);</span><br><span class="line">p.then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result));</span><br></pre></td></tr></table></figure>

<br>



<h2 id="Promise实现任务顺序执行"><a href="#Promise实现任务顺序执行" class="headerlink" title="Promise实现任务顺序执行"></a>Promise实现任务顺序执行</h2><p>在<code>.then</code>里要<code>return</code>一个<code>new Promise</code>，这样后续才能继续使用<code>.then</code>执行后续操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		resolve(<span class="string">"one"</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resolve(<span class="string">"two"</span>);</span><br><span class="line">		&#125;,<span class="number">3000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/images/loading.png" data-original="/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/1.png" class>

<br>



<h2 id="Promise封装ajax请求"><a href="#Promise封装ajax请求" class="headerlink" title="Promise封装ajax请求"></a>Promise封装ajax请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHttpClient</span>(<span class="params">method,url,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">            xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft XMLHttp'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> method=method||<span class="string">'GET'</span>;</span><br><span class="line">        <span class="keyword">var</span> data=data||<span class="literal">null</span>;</span><br><span class="line">        xhr.open(method,url,<span class="literal">true</span>);</span><br><span class="line">        xhr.onReadyStateChange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;=<span class="number">300</span>)||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">                    resolve(xhr.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">myHttpClient(<span class="string">'GET'</span>,url,<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>思想就是：将整个使用<code>XMLHttpRequest</code>去发起异步网络请求的操作封装在<code>new Promise</code>当中，执行函数返回一个Promise，那后续可以使用<code>.then</code>来执行后续的操作。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React hooks: useRef, useImperativeHandle</title>
    <url>/2020/12/14/React-hooks-useRef-useImperativeHandle/</url>
    <content><![CDATA[<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p><code>Refs</code>提供了一种方式，允许我们访问<strong>DOM节点</strong>或<strong>在render方法中创建的React元素</strong>。</p>
<p>在典型的React数据流中，<code>props</code>是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的props来重新渲染它。</p>
<p>但是在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个React实例，也可能是一个DOM元素。</p>
<h2 id="何时使用Refs"><a href="#何时使用Refs" class="headerlink" title="何时使用Refs"></a>何时使用Refs</h2><ul>
<li>管理焦点（受控组件），文本选择或媒体播放</li>
<li>触发强制动画</li>
<li>集成第三方DOM库</li>
</ul>
<h2 id="ref值根据节点的类型而有所不同"><a href="#ref值根据节点的类型而有所不同" class="headerlink" title="ref值根据节点的类型而有所不同"></a>ref值根据节点的类型而有所不同</h2><ul>
<li>当<code>ref</code>属性用于HTML元素时，<code>React.createRef()</code>创建的<code>ref</code>接收底层DOM元素作为其<code>current</code>属性（比如<code>div</code>）。</li>
<li>当<code>ref</code>属性用于自定义class组件时，<code>ref</code>对象接收组件的挂载实例作为其<code>current</code>属性。</li>
<li><strong>不能在函数组件上使用<code>ref</code>属性</strong>，因为它们没有实例。如果想要在函数组件中使用<code>ref</code>，可以使用<code>forwardRef</code>（可与<code>useImperativeHandle</code>结合使用）。不管怎样，你可以<strong>在函数组件内部使用ref属性</strong>，只要它指向一个DOM元素或class组件。</li>
</ul>
<br>



<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p><strong><code>useRef</code>最为传统的用法就是存储一个DOM节点的引用</strong>。当这个DOM节点更新时，这个引用也会更新。我们可以通过<code>current</code>属性来访问DOM节点。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> domRef = useRef()</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      doSomething(domRef.current) <span class="comment">// access the DOM node here</span></span><br><span class="line">    &#125;, []);</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;div ref=&#123;domRef&#125;&gt;</span><br><span class="line">    		&lt;Components /&gt;</span><br><span class="line">		&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>还有一种常用的用法是在父子组件中使用，通过结合<code>useRef</code>和<code>forwardRef</code>方法，父组件能够访问子组件内部的DOM节点</strong>。</p>
<p><code>Refs</code>允许某些组件接收<code>ref</code>，并向下传递给子组件。比如在下面这个实例中，<code>FancyButton</code>使用<code>React.forwardRef</code>来传递给它的<code>ref</code>，然后转发到它渲染的DOM <code>button</code>，此时在父组件中就可以使用<code>ref.current</code>来访问<code>button</code>的DOM节点：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"FancyButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Parent = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ 你可以直接获取 DOM button 的 ref</span></span><br><span class="line"><span class="regexp"> const ref = React.createRef();</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> return (</span></span><br><span class="line"><span class="regexp"> 	&lt;FancyButton ref=&#123;ref&#125;&gt;</span></span><br><span class="line"><span class="regexp">    	Click me!</span></span><br><span class="line"><span class="regexp">  	&lt;/</span>FancyButton&gt;  </span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码的逐步解释：</p>
<ol>
<li>通过调用<code>React.createRef</code>创建了一个<code>React</code> <code>ref</code>并将其赋值给<code>ref</code>变量</li>
<li>通过制定<code>ref</code>为<code>JSX</code>属性，将其向下传递给<code>&lt;FancyButton ref={ref}&gt;</code></li>
<li><code>React</code>传递<code>ref</code>给<code>forwardRef</code>内函数<code>(props, ref) =&gt; ...，</code>作为其第二个参数</li>
<li>向下转发该<code>ref</code>参数到<code>&lt;button ref={ref}&gt;</code>，将其指定为JSX属性</li>
<li>当<code>ref</code>挂载完毕，<code>ref.current</code>将指向<code>&lt;button&gt;</code>DOM节点</li>
</ol>
<p>注意：</p>
<ol>
<li>第二个参数ref只在使用<code>React.forwardRef</code>定义组件时存在。常规函数和class组件不接收<code>ref</code>参数，且<code>props</code>中也不存在<code>ref</code>。所以用<code>forwardRef</code>定义组件是一个比较特殊的用法。</li>
<li>如果想要在高阶组件中使用<code>ref</code>，需要多一步透传，见<a href="https://react.docschina.org/docs/forwarding-refs.html" target="_blank" rel="noopener">官网例子</a></li>
</ol>
<br>

<h1 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a><strong>useImperativeHandle</strong></h1><p><code>useImperativeHandle</code>方法可以让我们通过ref将一些变量和函数<strong>从子组件传递给父组件</strong>。父组件可以选择使用它或者将这个ref又传递给另一个子组件。</p>
<p>我们都知道，React是单向数据流的，数据是从父组件通过props传递到子组件的，所以<strong><code>useImperativeHandle</code>和<code>forwardRef</code>相结合实现信息从子组件传递给父组件</strong>，这是一个比较新颖的用法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useRef, forwardRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> ChildOne = forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    useImperativeHandle(ref, () =&gt; (&#123;</span><br><span class="line">        count,</span><br><span class="line">    &#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> updateCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setCount(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(count + <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;updateCount&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChildTwo = forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> checkCount = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"-&gt;"</span>, ref.current.count);</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;checkCount&#125;</span>&gt;</span>Count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = useRef();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ChildOne ref=&#123;ref&#125; /&gt;</span><br><span class="line">            &lt;ChildTwo ref=&#123;ref&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们在<code>Parent</code>中初始化<code>ref</code>，然后传递给两个子组件。</p>
<p>子组件1有自己的<code>state</code>，使用<code>useState</code> <code>hook</code>来控制，同时它有一个<code>updateCount</code>方法来增加<code>count</code>数量。</p>
<p>子组件1通过<code>useImperativeHandle</code>这个<code>hook</code>让父组件能够访问<code>count</code>，<code>useImperativeHandle</code>方法以<code>ref</code>作为第一个参数，以一个匿名函数作为第二个参数，这个匿名函数返回一个包含<code>count</code>变量的对象。</p>
<p>现在父组件能够访问<code>count</code>，并传递给子组件2。当点击子组件2时，输出<code>ref.current.count</code>。</p>
<p>这是一个信息流从子组件传递到父组件，再从父组件传递给子组件的例子。与此同时，我们可以注意到，因为我们使用了<code>useRef</code>，所以父组件是没有发生任何的重新渲染（re-render）。</p>
<br>

<p>对<code>useRef</code>和<code>useImperativeHandle</code>简单实践的代码地址：<a href="https://github.com/delaprada/Refs-practice" target="_blank" rel="noopener">https://github.com/delaprada/Refs-practice</a></p>
<p>参考：</p>
<p><a href="https://react.docschina.org/docs/forwarding-refs.html" target="_blank" rel="noopener">https://react.docschina.org/docs/forwarding-refs.html</a></p>
<p><a href="https://medium.com/@binyamin/react-hooks-useref-useimperativehandle-uselayouteffect-ede6f40f393e" target="_blank" rel="noopener">https://medium.com/@binyamin/react-hooks-useref-useimperativehandle-uselayouteffect-ede6f40f393e</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目中如何用Node作后端代理获取接口数据</title>
    <url>/2020/04/06/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8Node%E4%BD%9C%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%90%86%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>在做音乐APP项目的时候，发觉QQ音乐的有些接口是没有办法直接获取其中的数据的，因为它指定了请求的<code>host</code>和<code>referer</code>，所以我们需要用<code>Node</code>在其中做一层代理，去“欺骗”<code>QQ</code>，这样就能够获取数据。有点像跨域的思想，只不过跨域是用代理作为跳板，转发请求，不存在跨域问题；这里是用Node Server发起请求，将请求的<code>referer</code>和<code>host</code>改为接口允许访问的<code>referer</code>和<code>host</code>，来“欺骗”QQ。</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200406101554.png" style="zoom: 67%;">





<h2 id="怎么配置Node代理"><a href="#怎么配置Node代理" class="headerlink" title="怎么配置Node代理"></a>怎么配置Node代理</h2><p>我们使用<code>Vue.cli</code>搭项目的脚手架的时候，<code>build/webpack.dev.conf.js</code>文件中有个<code>devServer</code>这里就可以用来配置。以前是有单独的文件<code>dev-server.js</code>，最新版本的<code>Vue.cli</code>放弃了这个。</p>
<p>首先要在<code>devServer</code>中添加<code>before(app){}</code>，将我们的操作放在<code>before(app){}</code>中。<code>webpack 3</code> 内置了 <code>express</code>，<code>app</code> 就是 <code>express()</code> 返回的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    before(app)&#123;</span><br><span class="line">      app.get(<span class="string">'/api/getDiscList'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> url=<span class="string">'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'</span>;</span><br><span class="line">        axios.get(url,&#123;</span><br><span class="line">          headers:&#123;</span><br><span class="line">            referer:<span class="string">'https://c.y.qq.com'</span>,</span><br><span class="line">            host:<span class="string">'c.y.qq.com'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          params:req.query</span><br><span class="line">        &#125;).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">          res.json(response.data)</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>Node</code>服务器接收到来自<code>/api/getDiscList</code>的<code>get</code>请求时，就会执行后面的回调函数，用<code>axios</code>向<code>QQ</code>的<code>URL</code>发起请求，关键是要指定请求的头部<code>headers</code>，设定<code>referer</code>和<code>host</code>，这个<code>referer</code>和<code>host</code>是URL &lt;’<a href="https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&#39;&gt;" target="_blank" rel="noopener">https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&#39;&gt;</a> 允许访问的<code>referer</code>和<code>host</code>。</p>
<h2 id="向Node代理服务器发起请求"><a href="#向Node代理服务器发起请求" class="headerlink" title="向Node代理服务器发起请求"></a>向Node代理服务器发起请求</h2><p>我们使用模块化开发的时候，就可以在方法当中使用<code>axios</code>向<code>Node</code>代理服务器发起请求，返回一个<code>Promise</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDiscList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url=<span class="string">'/api/getDiscList'</span>;</span><br><span class="line">    <span class="keyword">const</span> data=<span class="built_in">Object</span>.assign(&#123;&#125;,commonParams,&#123;</span><br><span class="line">        platform:<span class="string">'yqq'</span>,</span><br><span class="line">        hostUin:<span class="number">0</span>,</span><br><span class="line">        sin:<span class="number">0</span>,</span><br><span class="line">        ein:<span class="number">29</span>,</span><br><span class="line">        sortId:<span class="number">5</span>,</span><br><span class="line">        needNewCode:<span class="number">0</span>,</span><br><span class="line">        categoryId:<span class="number">10000000</span>,</span><br><span class="line">        rnd:<span class="built_in">Math</span>.random(),</span><br><span class="line">        format:<span class="string">'json'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios.get(url,&#123;</span><br><span class="line">        params:data</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res.data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="组件当中的设置"><a href="#组件当中的设置" class="headerlink" title="组件当中的设置"></a>组件当中的设置</h2><p>首先是要导入方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getDiscList&#125; <span class="keyword">from</span> <span class="string">'api/recommend'</span></span><br></pre></td></tr></table></figure>

<p>我们在<code>created</code>生命周期阶段执行方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">        <span class="keyword">this</span>._getRecommend();</span><br><span class="line">        <span class="keyword">this</span>._getDiscList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">        _getDiscList()&#123;</span><br><span class="line">            getDiscList().then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.code===ERR_OK)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(res.data.list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行<code>npm run dev</code>，可在控制台看到数据：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200406103659.png" alt></p>
<br>

]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo categories和tags页面不显示解决办法</title>
    <url>/2019/12/25/hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>﻿官网也有给出具体步骤，但是有坑<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Hexo官网教程</a></p>
<h4 id="第一步-在终端窗口下，定位到-Hexo-站点目录下。使用-hexo-new-page指令新建一个页面，命名为-categories-："><a href="#第一步-在终端窗口下，定位到-Hexo-站点目录下。使用-hexo-new-page指令新建一个页面，命名为-categories-：" class="headerlink" title="第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ："></a>第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd hexo <span class="comment">//根目录</span></span><br><span class="line">hexo <span class="keyword">new</span> page categories <span class="comment">//tags和这个操作一致</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="第二步-找到新建的页面，添加type"><a href="#第二步-找到新建的页面，添加type" class="headerlink" title="第二步 找到新建的页面，添加type"></a>第二步 找到新建的页面，添加type</h4><p>新建的页面一般在source/categories/index.md中，添加以下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">45</span></span><br><span class="line">type: <span class="string">"categories"</span></span><br><span class="line">layout: <span class="string">"categories"</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="第三步-给你的页面添加分类"><a href="#第三步-给你的页面添加分类" class="headerlink" title="第三步 给你的页面添加分类"></a>第三步 给你的页面添加分类</h4><p>找到你的页面，在页面上方添加如下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: 利用gitpages+hexo搭建自己的博客</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">55</span></span><br><span class="line">categories:</span><br><span class="line">- Hexo</span><br><span class="line">tags:</span><br><span class="line">- 前端</span><br></pre></td></tr></table></figure>

<p>但此时部署到github上后，打开网页点击分类和标签页面还是出现404！</p>
<br>

<h4 id="第四步-解决方案"><a href="#第四步-解决方案" class="headerlink" title="第四步 解决方案"></a>第四步 解决方案</h4><p>实属官方坑人系列！！<br>主题配置文件_config.yml中的menu：<br>把 / 后面的空格全部去掉（刚开始的时候默认后面是加了空格导致点击页面出现404）<br><img src="/images/loading.png" data-original="hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/1.png" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue之计算属性的应用</title>
    <url>/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>昨天面试的时候被问到了Vue计算属性相关的代码题，又是一脸懵逼呀…赶紧来总结一下。</p>
<p>面试官先出了第一道题，点击div时输出是什么？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"b += 1"</span>&gt;</span>&#123;&#123;c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        c() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.a;</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出是3。</p>
<p>首先，computed中的属性都是以函数的形式声明的，看看官网的例子：</p>
<img src="/images/loading.png" data-original="/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/1.png" class>

<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original message: &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">Computed reversed message: &quot;olleH&quot;</span><br></pre></td></tr></table></figure>

<p>computed属性它所依赖的数据是data当中的，是要使用this来去获取的。所以计算属性c中的<code>this.b</code>和<code>this.a</code>其实是data当中的属性值。执行点击事件之后，b是会发生变化的，所以在计算属性c中输出<code>this.b</code>是会发生变化的，所以在控制台会输出3。因为计算属性c<code>return</code>的是<code>this.a</code>，所以<code></code>的值是不变的，是1。</p>
<p>接着面试官又出了第二道题，此时又输出什么？（其实面试官人真的好好，他的表述是此时会输出么？他这么问的话我就会倾向于回答不会输出）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"b += 1"</span>&gt;</span>&#123;&#123;c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        c() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span> <span class="keyword">this</span>.a;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>答案是不输出。此时c连渲染都不会发生。</p>
<p>最后面试官又问了第三道题，此时会输出什么？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"b += 1"</span>&gt;</span>absdflj<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        c() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.a;</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时这个计算属性并没有写在页面上，所以是不会监听c的值，此时控制台没有输出，页面显示的是：<code>absdflj</code>。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用指令及美化博客页面</title>
    <url>/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><p>Hexo的命令总体来说比较简单，安装成功之后只需要记住常用的四种即可。在当前blog文件夹根目录下右键点击git bash：</p>
<ul>
<li><code>hexo s</code>：server启动服务器</li>
<li><code>hexo clean</code>：clean清除缓存文件（db.json）和已生成的静态文件（public）</li>
<li><code>hexo generate</code>或<code>hexo g</code>：generate生成静态文件</li>
<li><code>hexo deploy</code>或<code>hexo d</code>：deploy部署网站，部署网站前需预先生成静态文件</li>
</ul>
<p>一般更改完后执行三条指令：<code>hexo clean</code>，<code>hexo generate</code>，<code>hexo deploy</code>即可（按顺序）</p>
<p>如果要进行文件压缩，在<code>hexo generate</code>指令后，执行<code>gulp</code>指令。</p>
<p>参考<a href="https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/" target="_blank" rel="noopener">https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/</a></p>
<h2 id="hexo各种美化"><a href="#hexo各种美化" class="headerlink" title="hexo各种美化"></a>hexo各种美化</h2><h3 id="新建page"><a href="#新建page" class="headerlink" title="新建page"></a>新建page</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章名称&quot;</span><br></pre></td></tr></table></figure>

<p>会在source文件夹下_post中新建文件夹和.md文件</p>
<h3 id="侧栏增加标签和分类页面"><a href="#侧栏增加标签和分类页面" class="headerlink" title="侧栏增加标签和分类页面"></a>侧栏增加标签和分类页面</h3><h4 id="创建标签页面"><a href="#创建标签页面" class="headerlink" title="创建标签页面"></a>创建标签页面</h4><ul>
<li><p>创建标签页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2017-12-02 21:01:24</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h4><ul>
<li><p>创建分类页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2017-12-02 21:01:24</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="文章中插入图片"><a href="#文章中插入图片" class="headerlink" title="文章中插入图片"></a>文章中插入图片</h3><ol>
<li><p>将图片放置在页面对应的文件夹中</p>
</li>
<li><p>在文章中引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名称 %&#125;</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h3 id="设置站点图标"><a href="#设置站点图标" class="headerlink" title="设置站点图标"></a>设置站点图标</h3><ol>
<li><p>先在images文件夹下放入你的图标</p>
</li>
<li><p>在主题配置页面_config.yml中搜索<code>favicon</code>，找到以下位置，并将路径修改为你的图标：</p>
<img src="/images/loading.png" data-original="/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/1.png" class>

</li>
</ol>
<p>部署之后就可以看到效果了，查看效果：<a href="http://delaprada.com">http://delaprada.com</a></p>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><ol>
<li>在images文件夹中放入你的头像图片</li>
<li>在主题配置页面中修改avatar为你的图片地址：</li>
</ol>
<img src="/images/loading.png" data-original="/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/2.png" class>



<h3 id="首页文章不显示全文只显示摘要"><a href="#首页文章不显示全文只显示摘要" class="headerlink" title="首页文章不显示全文只显示摘要"></a>首页文章不显示全文只显示摘要</h3><p>修改<code>/themes/next/_config.yml</code>主题配置文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scroll_to_more: true        #如果文章有摘要,会自动滚动到摘要下面</span><br><span class="line">save_scroll: true           #通过cookies来缓存阅读进度</span><br><span class="line">excerpt_description: true   #自动摘录描述作为序言</span><br><span class="line">auto_excerpt:               #设置阅读全文</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150                 #摘要次数</span><br><span class="line">read_more_btn: true         #阅读全文按钮</span><br></pre></td></tr></table></figure>



<h3 id="修改文章底部的带-的标签"><a href="#修改文章底部的带-的标签" class="headerlink" title="修改文章底部的带#的标签"></a>修改文章底部的带#的标签</h3><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将#改为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>（如果想换成其他图标可到font-awesome中文网查看）</p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p>在<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>，并加入以下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> <span class="keyword">not</span> is_index %&#125;</span><br><span class="line">        &lt;div style="text-align:center;color: #ccc;font-size:15px;"&gt;-------本&amp;nbsp;文&amp;nbsp;		结&amp;nbsp;束&amp;nbsp;&amp;nbsp;&lt;i class="fa fa-heart" aria-hidden="true"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;感			&amp;nbsp;谢&amp;nbsp;您&amp;nbsp;的&amp;nbsp;阅&amp;nbsp;读-------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在post-body标签之后，post-footer标签之前，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">    	&#123;% include &#39;passage-end-tag.swig&#39; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="修改网页背景颜色和侧栏上方brand的颜色"><a href="#修改网页背景颜色和侧栏上方brand的颜色" class="headerlink" title="修改网页背景颜色和侧栏上方brand的颜色"></a>修改网页背景颜色和侧栏上方brand的颜色</h3><p>打开<code>themes/next/layout/source/css/_custom/custom.styl</code>，加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改网页背景颜色</span><br><span class="line">body &#123;</span><br><span class="line">    background-color: #F0F8FF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer a &#123;</span><br><span class="line">    color:#eee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改网站头部颜色</span><br><span class="line">.headband &#123;</span><br><span class="line">    height: 3px;</span><br><span class="line">    background: #ADD8E6;</span><br><span class="line">&#125;</span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: 20px 0;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background: #ADD8E6;</span><br><span class="line">&#125;</span><br><span class="line">.site-title &#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="侧边栏社交设置和友情链接"><a href="#侧边栏社交设置和友情链接" class="headerlink" title="侧边栏社交设置和友情链接"></a>侧边栏社交设置和友情链接</h3><p>修改主题配置页面：<code>themes/next/_config.yml</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">site_state: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to <span class="built_in">end</span> users.</span><br><span class="line"># Value before `||` delimeter is the target permalink.</span><br><span class="line"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span><br><span class="line">social:</span><br><span class="line">  CSDN: https:<span class="comment">//blog.csdn.net/weixin_41973410 || copyright</span></span><br><span class="line">  GitHub: https:<span class="comment">//github.com/delaprada || github</span></span><br><span class="line"></span><br><span class="line">social_icons:  #这里是上面社交链接的对应图标</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  CSDN: copyright</span><br><span class="line">  Github: github</span><br><span class="line">  icons_only: <span class="literal">false</span></span><br><span class="line">  transition: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># Follow me on GitHub banner in right-top corner.</span><br><span class="line"># Usage: `permalink || title`</span><br><span class="line"># Value before `||` delimeter is the target permalink.</span><br><span class="line"># Value after `||` delimeter is the title <span class="keyword">and</span> aria-label name.</span><br><span class="line">#github_banner: https:<span class="comment">//github.com/Fitz1318 || Follow me on GitHub</span></span><br><span class="line"></span><br><span class="line"># Blog rolls  #这里时设置一些相关链接 我这里设置了一些推荐阅读的网站</span><br><span class="line">#links_icon: link</span><br><span class="line">links_title: 实用网站</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: <span class="keyword">inline</span></span><br><span class="line">links:</span><br><span class="line">  W3Cschool: http:<span class="comment">//www.w3school.com.cn/</span></span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>https SSL/TLS握手过程</title>
    <url>/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="SSL-TLS-握手过程详解"><a href="#SSL-TLS-握手过程详解" class="headerlink" title="SSL/TLS 握手过程详解"></a>SSL/TLS 握手过程详解</h1><p>http协议是明文传输，不确认通信方，不保证传输数据完整的协议。它带来了三大风险：</p>
<blockquote>
<p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p>
</blockquote>
<p>http协议是明文传输，在安全性方面比较差。https协议使用了SSL/TLS协议来进行加密。SSL/TLS握手是为了安全地协商出一份<strong>对称加密</strong>的秘钥。</p>
<img src="/images/loading.png" data-original="/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/1.jpg" class>



<h2 id="SSL-TLS握手过程"><a href="#SSL-TLS握手过程" class="headerlink" title="SSL/TLS握手过程"></a>SSL/TLS握手过程</h2><img src="/images/loading.png" data-original="/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/2.jpg" class>



<ol>
<li>Client Hello</li>
</ol>
<p>握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数<strong>Random1</strong>，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。</p>
<ol start="2">
<li>Server Hello</li>
</ol>
<p>第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。</p>
<p>注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。</p>
<ol start="3">
<li>Certificate</li>
</ol>
<p>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<ol start="4">
<li>Server Hello Done</li>
</ol>
<p>Server Hello Done通知客户端Server Hello过程结束。</p>
<ol start="5">
<li>Certificate Verify</li>
</ol>
<p>客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。</p>
<blockquote>
<p>https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的</p>
</blockquote>
<ol start="6">
<li>Client Key Exchange</li>
</ol>
<p>上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。</p>
<p>至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是<strong>使用这个秘钥进行对称加密</strong>。</p>
<p>为什么要使用三个随机数？</p>
<p>这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。</p>
<blockquote>
<p>最重要理解前六步</p>
</blockquote>
<ol start="7">
<li>Change Cipher Spec（Client）</li>
</ol>
<p>这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。</p>
<ol start="8">
<li>Encrypted Handshake Message(Client)</li>
</ol>
<p>这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。</p>
<ol start="9">
<li>Change Cipher Spec(Server)</li>
</ol>
<p>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</p>
<ol start="10">
<li>Encrypted Handshake Message(Server)</li>
</ol>
<p>这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p>
<p>Application Data</p>
<p><strong>到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输</strong>。</p>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>​            <a href="https://juejin.im/post/584b76d3a22b9d0058d5036f" target="_blank" rel="noopener">https://juejin.im/post/584b76d3a22b9d0058d5036f</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2安装与使用</title>
    <url>/2021/01/03/pm2%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>我们在启动一个<code>server.js</code>时一般会使用指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure>

<p>但是在终端关闭之后，服务就会停止了。所以此时可以利用PM2管理工具，安装后执行执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start ./server.js</span><br></pre></td></tr></table></figure>

<p>此时关闭终端服务也不会停止。下面就介绍一下这个工具。</p>
<h2 id="什么是PM2"><a href="#什么是PM2" class="headerlink" title="什么是PM2"></a>什么是PM2</h2><p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，例如性能监控、自动重启、负载均衡等，而且使用起来非常简单。</p>
<br>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install pm2@latest -g</span><br><span class="line">or</span><br><span class="line">yarn global add pm2</span><br></pre></td></tr></table></figure>

<br>

<h2 id="启动一个app"><a href="#启动一个app" class="headerlink" title="启动一个app"></a>启动一个app</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js</span><br></pre></td></tr></table></figure>

<p>同时也可以轻松地启动其他应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start bashscript.sh</span><br><span class="line">pm2 start python-app.py --watch</span><br><span class="line">pm2 start binary-file -- --port 1520</span><br></pre></td></tr></table></figure>



<p>一些可以传入cli的参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Specify an app name</span></span><br><span class="line">--name &lt;app_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Watch and Restart app when files change</span></span><br><span class="line">--watch</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set memory threshold for app reload</span></span><br><span class="line">--max-memory-restart &lt;200MB&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify log file</span></span><br><span class="line">--<span class="built_in">log</span> &lt;log_path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pass extra arguments to the script</span></span><br><span class="line">-- arg1 arg2 arg3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delay between automatic restarts</span></span><br><span class="line">--restart-delay &lt;delay <span class="keyword">in</span> ms&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prefix logs with time</span></span><br><span class="line">--time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do not auto restart app</span></span><br><span class="line">--no-autorestart</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify cron for forced restart</span></span><br><span class="line">--cron &lt;cron_pattern&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Attach to application log</span></span><br><span class="line">--no-daemon</span><br></pre></td></tr></table></figure>

<br>

<h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><p>重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 restart app_name</span><br></pre></td></tr></table></figure>

<p>0秒停机重载进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 reload app_name</span><br></pre></td></tr></table></figure>

<p>停止进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 stop app_name</span><br></pre></td></tr></table></figure>

<p>删除进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 stop app_name</span><br></pre></td></tr></table></figure>

<p>除了<code>app_name</code>以外，我们还可以传入：</p>
<ul>
<li><code>all</code>：对所有进程执行该操作</li>
<li><code>id</code>：对id对应的进程执行该操作</li>
</ul>
<p>查看进程状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure>

<br>

<h2 id="环境配置声明"><a href="#环境配置声明" class="headerlink" title="环境配置声明"></a>环境配置声明</h2><p>PM2可以让使用者管理工作流。它可以让你通过一个进程文件来调整你的行为、选择、环境变量、每个应用的日志文件。对于微服务应用来说是最有用的。</p>
<p>配置文件支持<code>js</code>、<code>JSON</code>、<code>YAML</code>格式。</p>
<h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><p>生成一个进程文件模板：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 ecosystem</span><br></pre></td></tr></table></figure>

<p>执行指令后会生成一个模板<code>ecosystem.config.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name: <span class="string">"app"</span>,</span><br><span class="line">    script: <span class="string">"./app.js"</span>,</span><br><span class="line">    env: &#123;</span><br><span class="line">      NODE_ENV: <span class="string">"development"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    env_production: &#123;</span><br><span class="line">      NODE_ENV: <span class="string">"production"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你编辑完这个文件之后可以通过cli重新执行该文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 [start|restart|stop|delete] ecosystem.config.js</span><br></pre></td></tr></table></figure>



<p>在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。</p>
<p>对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过<code>env_xx</code>来声明不同环境的配置，然后在启动应用时，通过<code>--env</code>参数指定运行的环境。</p>
<p>在配置文件中，通过<code>env</code>选项声明多个环境配置：</p>
<ul>
<li><code>env</code>为默认的环境配置（生产环境），<code>env_dev</code>、<code>env_test</code>则分别是开发环境和测试环境。可以看到，不同环境下的<code>NODE_ENV</code>、<code>REMOTE_ADDR</code>字段的值是不同的。</li>
<li>在应用中，可以通过<code>process.env.REMOTE_ADDR</code>等来读取配置中生命的变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span>,</span><br><span class="line">    <span class="string">"REMOTE_ADDR"</span>: <span class="string">"http://www.example.com/"</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">"env_dev"</span>: &#123;</span><br><span class="line">    <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span>,</span><br><span class="line">    <span class="string">"REMOTE_ADDR"</span>: <span class="string">"http://wdev.example.com/"</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">"env_test"</span>: &#123;</span><br><span class="line">    <span class="string">"NODE_ENV"</span>: <span class="string">"test"</span>,</span><br><span class="line">    <span class="string">"REMOTE_ADDR"</span>: <span class="string">"http://wtest.example.com/"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="启动时指明环境"><a href="#启动时指明环境" class="headerlink" title="启动时指明环境"></a>启动时指明环境</h3><p>假设通过下面启动脚本（开发环境），那么，此时<code>process.env.REMOTE_ADDR</code>的值就是相应的 <a href="http://wdev.example.com/" target="_blank" rel="noopener">http://wdev.example.com/</a> ，可以自己试验下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js --env dev</span><br></pre></td></tr></table></figure>

<br>

<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>命令如下，表示开启三个进程。如果传参为<code>-i max</code>，则会根据机器当前核数自动开启尽可能多的进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js -i 3</span><br><span class="line">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>

<br>

<h2 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h2><p>除了可以打开日志文件查看日志外，还可以通过<code>pm2 logs</code>来查看实时日志。这点对于线上问题排查非常重要。</p>
<p>比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 logs</span><br></pre></td></tr></table></figure>

<br>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>useRef vs useState: 我们是否需要重渲染</title>
    <url>/2020/12/28/useRef-vs-useState-%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%87%8D%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="TL-DR（Too-Long-Don’t-Read）"><a href="#TL-DR（Too-Long-Don’t-Read）" class="headerlink" title="TL;DR（Too Long, Don’t Read）"></a>TL;DR（Too Long, Don’t Read）</h1><ul>
<li><code>useState</code>会导致<code>re-render</code>；<code>useRef</code>不会</li>
<li><code>useState</code>和<code>useRef</code>在重渲染后都会记住它们之前的值</li>
</ul>
<p>开始学习<code>React</code>并不难，难点在于理解<code>React</code>的生命周期以及<code>re-render</code>。在<code>hook</code>这些新的<code>api</code>出现之后，我们脑海中会产生更多关于<code>React</code>的<code>re-render</code>（即虚拟DOM是在什么时候怎么样进行协调<code>reconciliation</code>的）的问题。</p>
<blockquote>
<p>Reconciliation（协调）是指仅在DOM树的diff发生变化时进行重渲染。</p>
</blockquote>
<p>我们为什么需要知道什么时候进行重渲染：</p>
<ol>
<li><code>re-render</code>是基于最新的变化（<code>latest changes</code>）来更新UI层</li>
<li><code>re-render</code>导致DOM树协调是影响性能（<code>performance factor</code>）的一大因素</li>
</ol>
<br>

<h1 id="什么导致re-render"><a href="#什么导致re-render" class="headerlink" title="什么导致re-render"></a>什么导致<code>re-render</code></h1><p><code>React</code>的<code>re-render</code>给我们展示了，我们通过事件（<code>events</code>）、请求（<code>requests</code>）、定时器（<code>timers</code>）等方式对数据层做出的改变。但它们并不是真正的触发者（<code>triggers</code>）——<code>state</code>的改变才是真正的触发者（触发<code>re-render</code>）。这个是合理的，因为事件、请求最终都是通过更新<code>state</code>来触发<code>re-render</code>。</p>
<p>当组件是嵌套着的时候，我们便很难准确判断<code>state</code>改变是怎么触发UI层的变化的。这也是经常困惑新手的点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">const</span> handleInputChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;Input value=&#123;value&#125; onChange=&#123;handleInputChange&#125; /&gt;</span><br><span class="line">      &lt;Button&gt;Button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>App</code>组件由两个子组件<code>Input</code>和<code>Button</code>，你觉得当用户在<code>input</code>中输入内容时DOM树的哪一部分会发生重渲染呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">&#123; value, onChange &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<br>

<h1 id="解释一下嵌套组件"><a href="#解释一下嵌套组件" class="headerlink" title="解释一下嵌套组件"></a>解释一下嵌套组件</h1><p>嵌套组件是最困扰新手们的点了。他们总是会想着<code>props</code>也会触发<code>re-render</code>，我时常会听到：“但<code>Input</code>没有<code>state</code>，它只有<code>props</code>。但它<code>re-render</code>了，为什么？”</p>
<p>为了证明<code>Input</code>真的<code>re-render</code>，我们通过<code>React&#39;s dev tool</code>来检测。点击<code>settings/gear icon</code>，点击<code>Highlight Update</code>键。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201228100723.png" alt></p>
<p>当我们在<code>input</code>中输入内容时，会发现<code>App</code>、<code>Input</code>、<code>Button</code>都提示在<code>re-render</code>，<strong>这种<code>re-render</code>的触发只是因为改变了其中一个子组件<code>Input</code>的内容</strong>。这种更新准确来说并不是<code>input</code>内容变化所导致的，而是因为<code>App</code>组件中的<code>state</code> <code>value</code>发生变化导致的。</p>
<p>因此我们可以得出结论：只要<code>App</code>的<code>state</code>发生变化，每个<code>App</code>的子组件都会<code>re-render</code>。也有例外，如果我们使用<code>PureComponent</code>或者<code>shouldComponentUpdate</code>显式地表明<code>Input</code>和<code>Button</code>不会<code>re-render</code>，则子组件<code>Input</code>和<code>Button</code>不会<code>re-render</code>。</p>
<p>除了使用<code>PureComponent</code>和<code>shouldComponentUpdate</code>以外，有两种办法能够控制<code>re-render</code>。第一种办法是将<code>state</code>逻辑从<code>App</code>挪到<code>Input</code>子组件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">const</span> handleInputChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleInputChange&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这么做的话，<code>App</code>就不会更新，因为<code>state</code>挪到了子组件<code>Input</code>中。<code>App</code>不会更新也意味着<code>Button</code>也不会更新。</p>
<p>这里关键的一点是——尽管协调（<code>reconciliation</code>）能够使得<code>React</code>变得更快，在一些复杂的DOM场景下也会导致性能瓶颈。所以，不要盲目地优化（<code>do not blindly optimize</code>）。</p>
<br>

<h1 id="在不re-render的情况下保存数据"><a href="#在不re-render的情况下保存数据" class="headerlink" title="在不re-render的情况下保存数据"></a>在不<code>re-render</code>的情况下保存数据</h1><p>在数据发生变化和UI更新时，<code>state</code>会保存着数据。在有些情况下，UI的更新是没有什么必要的。</p>
<p>非受控组件避免在<code>state</code>中保存数据，它们会选择在<code>refs</code>中保存数据。下面的例子使用<code>ref</code>来处理表格场景：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="string">""</span>);</span><br><span class="line">  <span class="keyword">const</span> valueRef = React.useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(valueRef.current.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h4&gt;Value: &#123;value&#125;&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input ref=&#123;valueRef&#125; /</span>&gt;</span><br><span class="line">      &lt;Button onClick=&#123;handleClick&#125;&gt;Button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们没有在<code>input</code>中使用<code>state</code>来存储其<code>value</code>，所以当我们填写表格的时候是没有<code>re-render</code>。只有当我们点击<code>button</code>时，才将<code>ref</code>中的<code>current.value</code>赋值给<code>state</code>中的<code>value</code>。</p>
<p>所以<code>ref</code>不只可以用于访问DOM节点，还可以用来存储数据。</p>
<p>受控组件是非受控组件的反义词，它们是使用<code>state</code>作为数据存储的组件。受控组件并不差（<code>bad</code>），实际上，它们是最为推荐的。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/" target="_blank" rel="noopener">https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>乱序数组的三种方法</title>
    <url>/2020/03/28/%E4%B9%B1%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天面试的时候被问到实现乱序数组的最简便的方法，自己只知道使用<code>Math.random()</code>和结果数组的笨方法…总结一下。</p>
<br>

<h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a><code>sort()</code>方法</h2><p>数组的<code>sort()</code>方法是按照<code>return</code>的值的正负来去做排序判定，所以实现的思路可以是使得返回的值随机正负。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randArr</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Math</span>.random()<span class="number">-0.5</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Math.random()</code>是生成0.0（包含）~1.0（不包含）之间的随机数。</p>
<p>但这么做是一个伪排序。参考：<a href="https://zhuanlan.zhihu.com/p/33260052" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33260052</a></p>
<p>有大神做过测试，进行10000次乱序操作后，<strong>元素大概率停留在自己的初始位置上</strong>。</p>
<p><img src="/images/loading.png" data-original="http://q7zfh0r3l.bkt.clouddn.com/blog/20200330/riRRTr2KjVrB.jpg?imageslim" alt="mark"></p>
<br>



<h2 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h2><p>思路是：</p>
<ul>
<li>找到数组的最后一个元素</li>
<li>从数组开头到最后一个元素之间，找到随机的一个数</li>
<li>交换两个元素的位置</li>
<li>此时最后一个元素已经是乱序后的结果</li>
<li>指向最后一个元素的索引前移</li>
<li>直到指向索引为0</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//洗牌算法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randArr3</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length=arr.length;</span><br><span class="line">    <span class="keyword">var</span> r=length;</span><br><span class="line">    <span class="keyword">var</span> rand=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r)&#123;</span><br><span class="line">        rand=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(r--));</span><br><span class="line">        [arr[r],arr[rand]]=[arr[rand],arr[r]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>



<h2 id="Math-random-结果数组"><a href="#Math-random-结果数组" class="headerlink" title="Math.random()+结果数组"></a><code>Math.random()</code>+结果数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randArr2</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=[];</span><br><span class="line">    <span class="keyword">var</span> len=arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*arr.length);</span><br><span class="line">        res.push(arr[index]);</span><br><span class="line">        arr.splice(index,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>











]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件绑定 事件监听 事件委托</title>
    <url>/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>为了让JavaScript对用户的操作作出响应，首先要对DOM元素绑定事件处理函数。</p>
<p>三种常用的绑定事件的方法：</p>
<ol>
<li>在DOM元素中直接绑定</li>
<li>在JavaScript代码中绑定</li>
<li>绑定事件监听函数</li>
</ol>
<h3 id="在DOM元素中直接绑定"><a href="#在DOM元素中直接绑定" class="headerlink" title="在DOM元素中直接绑定"></a>在DOM元素中直接绑定</h3><p>我们可以在DOM元素上绑定<code>onclick</code>、<code>onmouseover</code>、<code>onmouseout</code>、<code>onmousedown</code>、<code>onmouseup</code>、<code>ondblclick</code>、<code>onkeydown</code>、<code>onkeypress</code>、<code>onkeyup</code>等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"hello()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello world!"</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="在JavaScript代码中绑定事件"><a href="#在JavaScript代码中绑定事件" class="headerlink" title="在JavaScript代码中绑定事件"></a>在JavaScript代码中绑定事件</h3><p>在JavaScript代码中（即<code>script</code>标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello world!"</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h3><p>绑定事件的另一种方法是用 <code>addEventListener()</code> 或 <code>attachEvent()</code>来绑定事件监听函数。</p>
<p>事件监听的优点：</p>
<ol>
<li>可以绑定多个事件</li>
</ol>
<p>常规的事件绑定（例如<code>onclick</code>）只执行最后绑定的事件，会产生事件覆盖。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn3 = <span class="built_in">document</span>.getElementById(<span class="string">"btn3"</span>);</span></span><br><span class="line"><span class="actionscript">btn3.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 1"</span>); <span class="comment">//不执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript">btn3.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 2"</span>); <span class="comment">//执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>使用<code>addEventListener</code>的话两个事件都会执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn4"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn4 = <span class="built_in">document</span>.getElementById(<span class="string">"btn4"</span>);</span></span><br><span class="line"><span class="actionscript">btn4.addEventListener(<span class="string">"click"</span>,hello1);</span></span><br><span class="line"><span class="actionscript">btn4.addEventListener(<span class="string">"click"</span>,hello2);</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hello1</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 1"</span>); <span class="comment">//执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hello2</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 2"</span>);  <span class="comment">//执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>关于事件监听，有3个事件阶段（事件流包括三个状态）：<strong>捕获阶段</strong>，目标阶段，<strong>冒泡阶段</strong>。<strong>这三个阶段也叫作事件流。</strong></p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>当一个事件触发后，从window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。<strong>所有经过的节点，都会触发对应事件</strong>。</p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>当事件到达目标节点后，会沿着捕获阶段路线原路返回。同样，<strong>所有经过的节点，都会触发对应的事件</strong>。</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/1.png" class>

<p>通过栗子来理解两个事件机制：</p>
<p>假设有body和body节点下的div1均有绑定了一个点击事件。</p>
<p>效果：</p>
<ul>
<li>当为事件捕获(<code>useCapture:true</code>)时,先执行body的事件,再执行div的事件</li>
<li>当为事件冒泡(<code>useCapture:false</code>)时,先执行div的事件,再执行body的事件（默认是false，在事件冒泡阶段执行）</li>
</ul>
<p><code>useCapture</code>：用于指定事件是否在捕获或冒泡阶段执行</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/3.png" class>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//当useCapture为默认false时,为事件冒泡</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="actionscript">    body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//结果:打印div1  打印body</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//当useCapture为true时,为事件捕获</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="actionscript">    body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="actionscript">    div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//结果:打印body   打印div1</span><br></pre></td></tr></table></figure>



<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><strong>利用冒泡原理，把事件加到父元素或祖先元素上，触发执行效果</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.target)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> div3 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="actionscript">        div3.setAttribute(<span class="string">'class'</span>,<span class="string">'div3'</span>)</span></span><br><span class="line"><span class="actionscript">        div3.innerHTML = <span class="string">'div3'</span>;</span></span><br><span class="line">        div.appendChild(div3)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然没有给div1和div2添加点击事件，但是无论是点击div1还是div2都会打印当前节点（<code>console.log(e.target)</code>）。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。</p>
<p>举个栗子：</p>
<p>分别点击div1、div2、div3：</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/2.png" class>

<p><strong>无论后代新增了多少个节点，一样具有点击事件的功能。但是如果是传统的事件绑定的话无法对动态添加的元素而动态地添加事件</strong>。</p>
<h4 id="事件委托的优点"><a href="#事件委托的优点" class="headerlink" title="事件委托的优点"></a>事件委托的优点</h4><ol>
<li>提高性能：每一个函数都会占用内存空间。只需要添加一个事件处理程序代理所有事件，所占用的内存空间更少。</li>
<li>动态监听：使用事件委托可以自动绑定动态添加的元素。即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。</li>
</ol>
<p>参考：<a href="https://www.cnblogs.com/soyxiaobi/p/9498357.html" target="_blank" rel="noopener">https://www.cnblogs.com/soyxiaobi/p/9498357.html</a></p>
<p>​            <a href="http://blog.xieliqun.com/2016/08/12/event-delegate/" target="_blank" rel="noopener">http://blog.xieliqun.com/2016/08/12/event-delegate/</a></p>
<br>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是哈希hash</title>
    <url>/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/</url>
    <content><![CDATA[<h1 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h1><h2 id="什么是Hash"><a href="#什么是Hash" class="headerlink" title="什么是Hash"></a>什么是Hash</h2><p>通过一些计算，把关键码值映射到数组中的位置来访问记录，这个过程称为散列（hash）。</p>
<p>重要组成：</p>
<ul>
<li>hash函数：把关键码值映射到位置的函数称为散列函数。用h表示。</li>
<li>hash表：存放记录的数组称为散列表。用HT表示。</li>
<li>槽（slot）：散列表中的一个位置称为一个槽。</li>
</ul>
<p>设计hash表的目标是：使得对于任何关键码值K和某个散列函数h，<code>i=h(K)</code>是表中满足0&lt;=h(K)&lt;M（M为HT中槽的数目）的一个槽，并且记录在<code>HT[i]</code>存储的关键码值与K相等。</p>
<h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>在实际情况中，我们根据散列方法组织的数据库必须把存储的记录存放在不大的散列表中，以避免浪费过多的空间。这样的话，有可能有多个关键码值计算出来的h(K)是一样的，但又不能同时放在同一个槽中，此时就要使用冲突解决策略。</p>
<h3 id="冲突解决策略"><a href="#冲突解决策略" class="headerlink" title="冲突解决策略"></a>冲突解决策略</h3><p>冲突解决策略一般分为两类：</p>
<ul>
<li>开散列方法（open hashing；也称为单链方法）</li>
<li>闭散列方法（closed hashing；也称为开地址方法）</li>
</ul>
<h4 id="开散列方法"><a href="#开散列方法" class="headerlink" title="开散列方法"></a>开散列方法</h4><p>开散列方法的最简单形式把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放在这个槽的链表内。</p>
<img src="/images/loading.png" data-original="/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/1.png" class>



<h4 id="闭散列方法"><a href="#闭散列方法" class="headerlink" title="闭散列方法"></a>闭散列方法</h4><p>闭散列方法把所有记录直接存储到散列表中。每条关键码值标记为k<sub>R</sub>，记录R有一个基槽，就是h(k<sub>R</sub>)，即由散列函数计算出来的槽。如果要插入一条记录R，而另一条记录已经占据了R的基槽，那么就把R存储在表的其他槽内。</p>
<h5 id="桶式散列"><a href="#桶式散列" class="headerlink" title="桶式散列"></a>桶式散列</h5><ul>
<li>一种实现闭散列的方法是把散列表中的槽分成多个桶(bucket)。把散列表中的M个槽分成B个桶，每个桶中包含M/B个槽。</li>
<li>散列函数把每一条记录分配到某个桶的第一个槽中。</li>
<li>如果这个槽已经被占用，那么就顺序地沿着桶查找，直到找到一个空槽。</li>
<li>如果一个桶全部被占满了，那么就把这条记录存储在表后具有无限容量的溢出桶（overflow bucket）中。</li>
</ul>
<img src="/images/loading.png" data-original="/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/2.png" class>



<h4 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h4><p>最常用的散列方法。当发生冲突时，从当前基槽开始往后查找，有空位则将记录放进去。例如，2037原本应放在7的槽中，但是7已经被占用，所以往后查找空位，8是空的，于是将2037放进去。</p>
<img src="/images/loading.png" data-original="/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/3.png" class>



<p>但是这种方法会导致基本聚集。例如在上例中，下一条记录放到第2个槽的概率就是6/10了，因为取模后值为7,8,9,0,1,2都会放到第2个槽中。在理想情况下，表中的每个空槽都应该有相同的机会接受到下一个要插入的记录。</p>
<h3 id="改进的冲突解决方法"><a href="#改进的冲突解决方法" class="headerlink" title="改进的冲突解决方法"></a>改进的冲突解决方法</h3><p>如何避免基本聚集呢？</p>
<p>一种可能的改进方式是仍然使用线性探查，但是跳过一些槽，而且每次跳过常数c个而不是1个槽。这会生成探查函数：<code>P(K,i)=ci</code>。</p>
<p>例如，如果常数c是2的话：如果基槽被占用的话，第一次会找基槽+2的位置，看是否被占用，如果被占用了，第二次会找基槽+4的位置，如果还是被占用，则找基槽+6的位置，以此类推。即从基槽开始的偏移量将会为2,4,6。</p>
<p>另一种方法是使用二次探查函数（对于某些常数c1,c2,c3）：<code>p(K,i)=c1i&lt;sup&gt;2&lt;/sup&gt;+c2i+c3</code>。一个最简单的变体就是<code>p(K,i)=i&lt;sup&gt;2&lt;/sup&gt;</code>。</p>
<p>例如，对于一个长度M=101的散列表，假定对于关键码k1和k2，h(k1)=30，h(k2)=29。k1的探查序列为30,31,34,39；k2的探查序列为29,30,33,38。这样，尽管k2会在第二步探查k1的基槽，这两个关键码的探查序列此后就立即分开了。</p>
<h4 id="双散列方法"><a href="#双散列方法" class="headerlink" title="双散列方法"></a>双散列方法</h4><p>即由两个散列函数，一个散列函数用于计算基槽，另一个散列函数用于确定线性探查中的常数。即线性探查此时的形式为：<code>p(K,i)=i*h2(K)</code>。</p>
<p>例如，假定散列表的长度是M=101，有3个关键码k1，k2，k3，h(k1)=30，h(k2)=28，h(k3)=30，h2(k1)=2，h2(k2)=5，h2(k3)=5。那么k1的探查序列为：30,32,34,36等；k2的探查序列为：28,33,38,43等；k3的探查序列为：30,35,40,45等。这样关键码之间就不会共享同一段探查序列了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>使用JSONP实现跨域</title>
    <url>/2020/03/29/%E4%BD%BF%E7%94%A8JSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><ul>
<li>同源策略是浏览器的一个安全功能</li>
<li>同源指的是：协议，域名，端口号都相同</li>
<li>同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源</li>
</ul>
<h3 id="同源策略限制的内容有："><a href="#同源策略限制的内容有：" class="headerlink" title="同源策略限制的内容有："></a>同源策略限制的内容有：</h3><ul>
<li><code>cookie</code>、<code>localStorage</code>等存储性内容</li>
<li>DOM节点</li>
<li><code>AJAX</code>请求发送后，非同源会被浏览器拦截</li>
</ul>
<blockquote>
<p>但是有三个标签时允许跨域加载资源的：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<p>这就是<code>JSONP</code>的来源</p>
</blockquote>
<h2 id="JSONP实现跨域"><a href="#JSONP实现跨域" class="headerlink" title="JSONP实现跨域"></a><code>JSONP</code>实现跨域</h2><p>基本思想：网页通过添加一个<code>&lt;script&gt;</code>元素（因为<code>src</code>属性），向服务器请求<code>json</code>数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。但只支持<code>GET</code>请求。</p>
<p>实践代码：</p>
<p>创建一个<code>JSONP</code>文件夹，在其中添加<code>template.html</code>以及<code>server.js</code>。</p>
<p><code>template.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>jsonp testing<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span><span class="params">(&#123;url,params,callback&#125;)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> script=<span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">            params=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(params));</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> arrs=[];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params)&#123;</span></span><br><span class="line"><span class="javascript">                arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            arrs.push(<span class="string">`callback=<span class="subst">$&#123;callback&#125;</span>`</span>);</span></span><br><span class="line"><span class="javascript">            script.src=<span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">'&amp;'</span>)&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>[callback]=<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line">                resolve(data);</span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.removeChild(script);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    jsonp(&#123;</span><br><span class="line"><span class="actionscript">        url:<span class="string">'http://localhost:3000/say'</span>,</span></span><br><span class="line">        params:&#123;</span><br><span class="line"><span class="actionscript">            wd:<span class="string">'I love you'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        callback:<span class="string">'show'</span></span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>server.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">router.get(<span class="string">'/say'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//要响应回去的数据</span></span><br><span class="line">  <span class="keyword">let</span> data = &#123;</span><br><span class="line">    username : <span class="string">'zs'</span>,</span><br><span class="line">    password : <span class="number">123456</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123;wd , callback&#125; = req.query;</span><br><span class="line">  <span class="built_in">console</span>.log(wd);</span><br><span class="line">  <span class="built_in">console</span>.log(callback);</span><br><span class="line">  <span class="comment">// 调用回调函数 , 并响应</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">app.use(router);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码实现的就是我们的<code>html</code>文档，使用<code>jsonp</code>方法向<code>http://localhost:3000/say</code>发起请求。当服务器监听到请求之后，将响应的数据放在指定名字的回调函数中传回来，然后调用<code>callback</code>回调函数执行<code>resolve(data)</code>。因为<code>jsonp</code>函数返回的是一个<code>Promise</code>对象，所以之后可以调用<code>.then</code>执行后续的<code>console.log</code>操作。</p>
<p>结果：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/3.png" alt></p>
<br>



<p>如果是<code>AJAX</code>请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onReadyStateChange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>&amp;&amp;xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">    	alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(<span class="string">'get'</span>,<span class="string">'http://localhost:3000/say'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>



<p>就会报跨域的错误：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/1.png" alt="img"></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2020/01/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>柯里化的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<p>看一个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用了<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。</p>
<p>因为一次性地调用它有点繁琐，所以使用一个特殊的<code>curry</code>帮助函数使得这类函数的定义和调用更加容易。</p>
<p><strong>一些柯里函数实例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="built_in">require</span>(<span class="string">'lodash'</span>).curry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = curry(<span class="function"><span class="keyword">function</span>(<span class="params">what, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.match(what);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">match(<span class="regexp">/\s+/g</span>, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br><span class="line"></span><br><span class="line">match(<span class="regexp">/\s+/g</span>)(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br></pre></td></tr></table></figure>

<p>以上两种方法都可以执行。第二种方法是比较常见的柯里化方法。先传递一部分参数（题目中为正则表达式）来调用函数，然后返回一个函数（题目中为<code>str.match()</code>来处理剩下的函数）。（题目中是匹配空格）</p>
<p>以上的形式可以更加具体化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasSpaces = match(<span class="regexp">/\s+/g</span>);</span><br><span class="line"><span class="comment">// function(x) &#123; return x.match(/\s+/g) &#125;</span></span><br><span class="line"></span><br><span class="line">hasSpaces(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br></pre></td></tr></table></figure>



<p><strong>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</strong></p>
<p><strong>再举一个非常常见的例子：</strong></p>
<p>如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>.test(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果想要验证是否是邮箱呢？这么封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEmail</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">targetString, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(targetString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">'14900000088'</span>);</span><br><span class="line">check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>);</span><br></pre></td></tr></table></figure>

<p>这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _check = createCurry(check);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPhone = _check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure>

<p>最后在使用的时候就会变得更加直观与简洁了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkPhone(<span class="string">'183888888'</span>);</span><br><span class="line">checkEmail(<span class="string">'xxxxx@test.com'</span>);</span><br></pre></td></tr></table></figure>



<p><strong>再看一个前端面试中常考的题目：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何实现add(2)(3)(4) &#x3D; 9</span><br></pre></td></tr></table></figure>

<p>函数柯里化解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a+b+c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = fn.length;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> _args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">        args = <span class="built_in">Array</span>.prototype.concat.call(_args, args);</span><br><span class="line">        <span class="comment">// 当接收到的参数小于fn所需参数个数时，继续接收参数</span></span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> curry.call(_this, fn, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = curry(myAdd);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>));  <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.loh(add(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>));   <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>但是这个例子不具有普遍性。如果传入的参数不是3个的话不能这么用。</p>
<p>所以有了下面的进化之后的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString()                <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>).toString()             <span class="comment">// 10</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>).toString()          <span class="comment">// 15</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>).toString()                <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>



<p>参考的博客说隐式转换的原因是因为函数进行计算的时候会变为字符串，但理解了代码之后觉得并不是这么回事。每次调用函数的时候执行的是这个语句体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个语句体实际上是用于将所有传入的实参放进数组<code>args</code>中。最后执行<code>toString</code>方法的时候是将数组<code>args</code>的每个元素通过reduce函数求和，返回求和的值。单纯执行<code>_adder</code>函数和执行<code>toString()</code>函数做的事情是不一样的。</p>
<p>看到一个面试题目：</p>
<p>实现一个sum函数使得sum(1, 2, 3).valueOf()和sum(1)(2)(3).valueOf()执行输出的结果都等于6 。</p>
<p>解法和上面一致，只需要把<code>toString()</code>改为<code>valueOf()</code>就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args=[].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> _adder=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    _adder.valueOf=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).valueOf());</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).valueOf());</span><br></pre></td></tr></table></figure>





<p><strong>为什么要进行隐式转化？</strong></p>
<p>因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>);     <span class="comment">// 输出结果 function fn() &#123; return 20 &#125;10</span></span><br></pre></td></tr></table></figure>

<p>我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<p>除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure>



<p>参考博客：</p>
<p> <a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">https://www.jianshu.com/p/5e1899fe7d6b</a> </p>
<p><a href="https://www.cnblogs.com/hmchen/p/11564394.html" target="_blank" rel="noopener">https://www.cnblogs.com/hmchen/p/11564394.html</a></p>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分析parseInt()</title>
    <url>/2020/01/18/%E5%88%86%E6%9E%90parseInt/</url>
    <content><![CDATA[<h3 id="parseInt-公式"><a href="#parseInt-公式" class="headerlink" title="parseInt()公式"></a><code>parseInt()公式</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。要被解析的字符串。</td>
</tr>
<tr>
<td>radix</td>
<td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</td>
</tr>
</tbody></table>
<br>



<h3 id="parseInt-071-和parseInt-quot-071-quot-的区别"><a href="#parseInt-071-和parseInt-quot-071-quot-的区别" class="headerlink" title="parseInt(071)和parseInt(&quot;071&quot;)的区别"></a><code>parseInt(071)和parseInt(&quot;071&quot;)的区别</code></h3><p><code>parseInt(&quot;071&quot;)</code>就是简单将字符串转换为数字：</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E5%88%86%E6%9E%90parseInt/1.png" class>

<ul>
<li><p>如果 string 以 “0x” 开头，<code>parseInt()</code> 会把 string 的其余部分解析为十六进制的整数。</p>
</li>
<li><p>如果 string 以 1 ~ 9 的数字开头，<code>parseInt()</code> 将把它解析为十进制的整数。</p>
</li>
<li><p>以0开头也是转换为十进制。也有说转换为十六进制或者八进制，但是在chrome中实践是十进制。</p>
</li>
</ul>
<img src="/images/loading.png" data-original="/2020/01/18/%E5%88%86%E6%9E%90parseInt/2.png" class>



<p><code>parseInt(071)</code>就是将071用八进制进行转换：</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E5%88%86%E6%9E%90parseInt/3.png" class>

<br>



<h3 id="判断-‘1’-’2’-’3’-map-parseInt-的输出"><a href="#判断-‘1’-’2’-’3’-map-parseInt-的输出" class="headerlink" title="判断[‘1’,’2’,’3’].map(parseInt)的输出"></a>判断[‘1’,’2’,’3’].map(<code>parseInt</code>)的输出</h3><p>你可能觉得会是[1,2,3]，但实际上是[1,<code>NaN</code>,<code>NaN</code>]。我们来仔细分析一下：</p>
<p><strong>map的函数格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map((item, index, thisArr) &#x3D;&gt; ( newArr ))</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>item: callback 的第一个参数，数组中正在处理的当前元素</li>
<li>index: callback 的第二个参数，数组中正在处理的当前元素的索引</li>
<li><code>thisArr</code>: callback 的第三个参数，map 方法被调用的数组</li>
</ul>
<p><strong><code>parseInt</code>的格式</strong></p>
<p>上面讲到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure>



<p>通过上述对 map 和 <code>parseInt</code> 函数的分析可以知道，执行方法时，map给<code>parseInt</code>传递了三个参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(item, index, thisArr)</span><br></pre></td></tr></table></figure>

<p>因此，索引<code>index</code>会传入<code>parseInt</code>函数当做基数<code>radix</code>。</p>
<p>其中第三个参数会被 <code>parseInt</code> 忽略，因此会依次执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// radix 为 0，默认以十进制解析字符串，返回 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// radix 为 1，不在 2 ~ 36 之间，返回 NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN</span></span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://www.cnblogs.com/wx1993/p/8417817.html" target="_blank" rel="noopener">https://www.cnblogs.com/wx1993/p/8417817.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>利用gitpages+hexo搭建自己的博客</title>
    <url>/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始开始着手搭建到完成大概花了一个下午的时间，采坑不少，在此记录一下</p>
<h2 id="第一步-准备工作"><a href="#第一步-准备工作" class="headerlink" title="第一步 准备工作"></a>第一步 准备工作</h2><p>node.js下载好，github有已注册的账号<br>在github中新建一个repository，命名为：你的github名称.github.io（下面是我的仓库名称）：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.png" class>

<p>（有些博客直接让我们fork它们的项目，个人感觉这么做不太好，很多东西自己动手做一遍更好）</p>
<h2 id="第二步-安装Hexo"><a href="#第二步-安装Hexo" class="headerlink" title="第二步 安装Hexo"></a>第二步 安装Hexo</h2><p>Hexo就是一个博客框架，官网上也有安装教程<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官网</a></p>
<p><strong>step1</strong>：windows系统鼠标右键git bash，输入两个安装指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g   &#x2F;&#x2F;用于安装hexo</span><br><span class="line">npm install hexo-deployer-git --save   &#x2F;&#x2F;用于安装hexo部署到git page的deployer</span><br></pre></td></tr></table></figure>



<p><strong>step2</strong>：创建hexo文件夹<br>hexo安装完成之后，在电脑中新建一个hexo文件夹：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/2.png" class>

<p>右键点击git bash，输入两个命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install   &#x2F;&#x2F;安装所有package.json里的包</span><br></pre></td></tr></table></figure>
<p>执行完成后，hexo文件夹中会多出一些文件：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/3.png" class>



<p>如果想看本地效果的话，执行以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate  &#x2F;&#x2F;自动将md文件生成静态html，css文件</span><br><span class="line">hexo server  &#x2F;&#x2F;启动本地hexo服务器（localhost:4000）</span><br></pre></td></tr></table></figure>


<p>打开 localhost:4000就可以看到页面啦：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/4.png" class>

<p>（页面会不太一样，我的配了一下主题）</p>
<h2 id="第三步-了解hexo文件夹中的-config-yml"><a href="#第三步-了解hexo文件夹中的-config-yml" class="headerlink" title="第三步 了解hexo文件夹中的_config.yml"></a>第三步 了解hexo文件夹中的_config.yml</h2><p>hexo文件夹中比较重要的文件是：_config.yml：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/5.png" class>



<p>它是一个全局配置文件，包括和github上传链接都在这里配置，例如title之类的：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/6.png" class>





<h2 id="第四步-本地上传到github"><a href="#第四步-本地上传到github" class="headerlink" title="第四步 本地上传到github"></a>第四步 本地上传到github</h2><p><strong>step1</strong>：执行命令，安装deploy.git插件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>



<p><strong>step2</strong>：在主题配置文件_config.yml中修改仓库地址，在_config.yml最下面一行（注意每个冒号后面都有一个空格）</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/7.png" class>



<p><strong>step3</strong>：配置提交github认证方式<br>执行指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>直接提交到github仓库中，如果没有认证github和本地的关系，会提示输入用户名和密码</p>
<p>此时打开github的项目会发现原本是空的项目现在有了刚刚上传的文件</p>
<h2 id="第五步-添加域名"><a href="#第五步-添加域名" class="headerlink" title="第五步 添加域名"></a>第五步 添加域名</h2><p>在阿里云中购买了一个.com的域名（加优惠一年23块，虽然比其他贵一些但是觉得.com好听一些(#^ . ^#)）</p>
<p><strong>step1</strong>：cmd ping一下github.io获得真实ip地址</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/8.png" class>



<p><strong>step2：</strong>然后再域名操作栏点击解析，添加记录</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/9.png" class>

<p>注意要两个都要添加（之前一开始只添加了www不知道为啥就显示不出来）</p>
<p><strong>step3</strong>：去hexo文件夹的source目录下新建名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/10.png" class>



<p><strong>step4：</strong>然后部署</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> hexo clean</span><br><span class="line"><span class="number">2.</span> hexo generate</span><br><span class="line"><span class="number">3.</span> hexo deploy</span><br></pre></td></tr></table></figure>
<p>（每次做出更改建议都部署一遍）</p>
<p><strong>step5：</strong>点击设置，拉到下面，在custom domain中输入你的域名。如果上面的信息不是显示Your site is published at <a href="https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证" target="_blank" rel="noopener">https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证</a></p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/12.png" class>

<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/11.png" class>



<p>输入域名，成功：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/13.png" class>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解异步</title>
    <url>/2020/03/13/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p>所谓”异步”，简单说就是一个任务<strong>不是连续完成的</strong>，可以理解成该<strong>任务被人为分成两段</strong>，<strong>先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</strong>。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	XXX;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"XXX"</span>);</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。<code>setTimeout</code>是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行<code>setTimeout</code>任务的第二部分，执行XXX。</p>
<p>如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。</p>
<br>

<br>



<h3 id="异步编程的解决方案"><a href="#异步编程的解决方案" class="headerlink" title="异步编程的解决方案"></a>异步编程的解决方案</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。<code>callback</code>的意思就是“重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<br>

<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。</p>
<p>Promise的话任务也是分为两个部分，new Promise作为第一部分立即执行，然后将执行权交给其他任务，当执行完毕后才会执行event queue当中的回调函数。</p>
<p><strong>Promise的最大问题是代码冗余</strong>：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p>
<br>

<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul>
<li>第一步，协程<code>A</code>开始执行。</li>
<li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>
<li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li>
<li>第四步，协程<code>A</code>恢复执行。</li>
</ul>
<p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<strong><code>yield</code>命令是异步两个阶段的分界线</strong>。</p>
<p>（其他代码部分属于一个协程，中间的yield部分属于另一个协程）</p>
<p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p>
<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以<strong>交出函数的执行权（即暂停执行）</strong>。</p>
<h5 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h5><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p>
<p>执行这段代码的方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行gen（）的时候，它执行了<code>var url = &#39;https://api.github.com/users/github&#39;;</code>操作，因为遇到了yield，所以交出了当前异步任务的执行权。执行.next()方法的时候才会执行<code>fetch(url)</code>操作，<code>fetch(url)</code>任务执行完毕之后，才会将执行权交还给异步任务，去执行异步任务的第二部分。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序录音功能实现</title>
    <url>/2021/03/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开发小程序过程中，有一个实现录音功能并播放录音，将录音上传至服务器的需求。开发过程中使用了Taro框架，录音功能通过<code>Taro.getRecorderManager()</code>接口实现，上传录音至服务器通过<code>Taro.uploadFile</code>接口实现，播放录音使用<code>Taro.createInnerAudioContext()</code>接口实现。下面就详细介绍整个流程是如何实现的。</p>
<h1 id="小程序录音"><a href="#小程序录音" class="headerlink" title="小程序录音"></a>小程序录音</h1><p>首先获取录音管理器模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> recorderManager = Taro.getRecorderManager();</span><br></pre></td></tr></table></figure>

<p>在组件挂载完毕时注册录音监听事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// 监听录音开始</span></span><br><span class="line">    recorderManager.onStart(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'开始录音'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">// 监听录音暂停</span></span><br><span class="line">    recorderManager.onPause(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'暂停录音'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">// 监听录音继续</span></span><br><span class="line">    recorderManager.onResume(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'继续录音'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="comment">// 监听录音停止</span></span><br><span class="line">    recorderManager.onStop(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.duration &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        Taro.showToast(&#123;</span><br><span class="line">          title: <span class="string">'录音时间太短'</span>,</span><br><span class="line">          duration: <span class="number">1000</span>,</span><br><span class="line">          icon: <span class="string">'none'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'停止录音'</span>);</span><br><span class="line">        fileUpload(res.tempFilePath);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    recorderManager.onError(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      Taro.showToast(&#123;</span><br><span class="line">        title: <span class="string">'录音失败！'</span>,</span><br><span class="line">        duration: <span class="number">1000</span>,</span><br><span class="line">        icon: <span class="string">'none'</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure>
<p>在录音<code>onStop</code>的回调函数中，我们可以获取到录音的临时地址<code>res.tempFilePath</code>，但这个地址是有有效期限的，所以我们需要将这个录音上传至服务器后台，进行保存，后续才能正常使用。</p>
<p><code>onStop</code>回调函数中我们调用了<code>fileUpload</code>函数实现文件上传，<code>fileUpload</code>函数的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileUpload = <span class="function">(<span class="params">tempFilePath</span>) =&gt;</span> &#123;</span><br><span class="line">    Taro.uploadFile(&#123;</span><br><span class="line">      url: <span class="string">'http://127.0.0.1:7001/record'</span>, <span class="comment">// 服务器地址</span></span><br><span class="line">      filePath: tempFilePath,</span><br><span class="line">      name: <span class="string">'file'</span>, <span class="comment">// 这个随便填</span></span><br><span class="line">      header: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'multipart/form-data'</span>, <span class="comment">// 格式必须是这个</span></span><br><span class="line">        Authorization: Taro.getStorageSync(<span class="string">'token'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// formData用于传输除文件以外的一些信息</span></span><br><span class="line">      formData: &#123;</span><br><span class="line">        record_name: <span class="string">'朗诵作品'</span>,</span><br><span class="line">        poem_id: poemInfo.id,</span><br><span class="line">        category: poemInfo.category,</span><br><span class="line">      &#125;,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">        <span class="keyword">const</span> url = res.data;</span><br><span class="line">        playAudio(url); <span class="comment">// 播放录音</span></span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'failed!'</span>);</span><br><span class="line">        <span class="built_in">console</span>.error(error);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的点是：<code>header</code>中的<code>content-type</code>必须是<code>multipart/form-data</code>。</p>
<h1 id="录音事件的处理"><a href="#录音事件的处理" class="headerlink" title="录音事件的处理"></a>录音事件的处理</h1><p>第一次点击<code>handleClick</code>就会触发开始录音，之后会通过当前状态判断是暂停录音还是继续录音。<code>handleComplete</code>用于停止录音。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> curPause = pause;</span><br><span class="line">    setPause(!curPause);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstRecord) &#123;</span><br><span class="line">      setfirstRecord(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">      recorderManager.start(&#123;</span><br><span class="line">        duration: <span class="number">60000</span>,</span><br><span class="line">        sampleRate: <span class="number">44100</span>,</span><br><span class="line">        numberOfChannels: <span class="number">1</span>,</span><br><span class="line">        encodeBitRate: <span class="number">192000</span>,</span><br><span class="line">        format: <span class="string">'mp3'</span>,</span><br><span class="line">        frameSize: <span class="number">50</span>,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Taro.showToast(&#123;</span><br><span class="line">        title: <span class="string">'开始录音'</span>,</span><br><span class="line">        duration: <span class="number">1000</span>,</span><br><span class="line">        icon: <span class="string">'none'</span>,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (curPause) &#123;</span><br><span class="line">        recorderManager.pause(); <span class="comment">// 暂停录音</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recorderManager.resume(); <span class="comment">// 继续录音</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleComplete = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    recorderManager.stop(); <span class="comment">// 停止录音</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="后台实现录音存储并返回录音地址"><a href="#后台实现录音存储并返回录音地址" class="headerlink" title="后台实现录音存储并返回录音地址"></a>后台实现录音存储并返回录音地址</h1><p>网上大多数博客都没有涉及这块内容，下面就介绍一下如何实现，后台框架我用的是阿里的<code>egg.js</code>。</p>
<p>文件上传需要配置的东西可见官方文档：<a href="https://eggjs.github.io/zh/guide/upload.html" target="_blank" rel="noopener">egg.js文件上传</a>。我们这里使用它的第一种<code>File</code>模式来实现。</p>
<p>因为<code>egg.js</code>框架内置了<code>Multipart</code>插件，可以解析上传的<code>multipart/form-data</code>类型的数据。</p>
<p>首先，现在配置文件<code>config.default.js</code>中写入<code>multipart</code>配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> config = (exports = &#123;&#125;);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  config.multipart = &#123;</span><br><span class="line">    mode: <span class="string">'file'</span>,</span><br><span class="line">    fileSize: <span class="string">'50mb'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...config,</span><br><span class="line">    ...userConfig,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>然后，在<code>router.js</code>中定义路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交录音</span></span><br><span class="line">router.post(<span class="string">'/record'</span>, auth, controller.record.postRecord);</span><br></pre></td></tr></table></figure>

<p>在<code>controller</code>目录下定义<code>record.js</code>文件写入如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> postRecord() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> file = ctx.request.files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> &#123; record_name, poem_id, category &#125; = ctx.request.body;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.service.record.postRecord(file, record_name, poem_id, category);</span><br><span class="line"></span><br><span class="line">    ctx.body = res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = RecordController;</span><br></pre></td></tr></table></figure>

<p>在<code>service</code>目录下定义<code>record.js</code>写入具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'egg'</span>).Service;</span><br><span class="line"><span class="keyword">let</span> OSS = <span class="built_in">require</span>(<span class="string">'ali-oss'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aliInfo = &#123;</span><br><span class="line">  <span class="comment">// https://help.aliyun.com/document_detail/31837.html</span></span><br><span class="line">  region: <span class="string">'oss-cn-guangzhou'</span>,</span><br><span class="line">  bucket: <span class="string">'poem-mini-program'</span>,</span><br><span class="line">  accessKeyId: <span class="string">'xxx'</span>, <span class="comment">// 填入阿里云的accessKeyId</span></span><br><span class="line">  accessKeySecret: <span class="string">'xxx'</span>, <span class="comment">// 填入阿里云的accessKeySecret</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = <span class="keyword">new</span> OSS(aliInfo);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> postRecord(file, record_name, poem_id, category) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="keyword">await</span> <span class="keyword">this</span>.uploadOSS(file);</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.updateRecord(url, record_name, poem_id, category);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> uploadOSS(file) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理文件，比如上传到云端</span></span><br><span class="line">      result = <span class="keyword">await</span> client.put(file.filename, file.filepath);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 需要删除临时文件</span></span><br><span class="line">      <span class="keyword">await</span> ctx.cleanupRequestFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> updateRecord(url, record_name, poem_id, category) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'从ctx.locals中取openid'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.locals.openid);</span><br><span class="line">    <span class="keyword">const</span> openid = ctx.locals.openid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户信息记录到数据库中</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.model.Record.create(&#123;</span><br><span class="line">      record_name: record_name,</span><br><span class="line">      record_url: url,</span><br><span class="line">      poem_id: poem_id,</span><br><span class="line">      category: category,</span><br><span class="line">      openid: openid,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = RecordService;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是：</p>
<ul>
<li>需要注册阿里云账号，并在对象存储那里新建一个存储桶用于存放音频，也就是云存储的实现。</li>
<li>需要安装<code>ali-oss</code>npm包，用于连接阿里云对象存储。在后台接收到前端上传的临时文件后，就会将音频上传至阿里云对象存储中（<code>client.put</code>）。</li>
</ul>
<h1 id="播放录音"><a href="#播放录音" class="headerlink" title="播放录音"></a>播放录音</h1><p>细心的小伙伴可以注意到在使用<code>Taro.uploadFile</code>接口上传录音后，在<code>success</code>回调中调用了<code>playAudio</code>函数用于播放音频，接下来讲一下播放音频是如何实现的。</p>
<p>首先，使用<code>Taro.createInnerAudioContext</code>获取<code>audio</code>的上下文对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> innerAudioText = Taro.createInnerAudioContext();</span><br></pre></td></tr></table></figure>

<p>和录音一样，在组件挂载完成时，注册监听事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    innerAudioText.onPlay(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'开始播放'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    innerAudioText.onError(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'播放异常'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure>

<p>在录音文件上传成功后，调用<code>playAudio</code>方法用于播放录音：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> playAudio = <span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">  innerAudioText.autoplay = <span class="literal">true</span>;</span><br><span class="line">  innerAudioText.src = url;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>src</code>被赋予值的时候，录音就会开始播放。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是整个录音功能和录音播放功能实现的整个流程，如有疑问欢迎大家一起交流。</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>易混淆JS题目——this指向 闭包</title>
    <url>/2020/02/18/%E6%98%93%E6%B7%B7%E6%B7%86JS%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94this%E6%8C%87%E5%90%91-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>Q：代码运行结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.b = <span class="number">3</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> a();</span><br><span class="line">a.prototype.b = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">7</span>;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c.b);</span><br></pre></td></tr></table></figure>

<p>解：</p>
<p>整个代码在变量提升之后可以写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.b=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c=<span class="keyword">new</span> a();</span><br><span class="line">a.prototype.b=<span class="number">9</span>;</span><br><span class="line">b=<span class="number">7</span>;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c.b);</span><br></pre></td></tr></table></figure>

<p><strong>注意：函数声明的时候还没有执行！不要弄混了。</strong>当执行<code>c=new a()</code>的时候，会将函数a内部的this指向c，所以<code>c.b</code>此时就是3。<code>a.prototype.b=9</code>没有什么影响。<code>b=7;</code>表示将全局变量b赋值为7。此后执行了函数<code>a()</code>，要注意在默认情况下，函数中this的指向是指向全局作用域的，所以执行函数<code>a()</code>的话是把全局变量b的值变为3。所以输出的是3 3。</p>
<hr>  

<p>Q：以最小的改动解决以下代码的错误（可以使用es6）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">name: <span class="string">" jsCoder"</span>,</span><br><span class="line">skill: [<span class="string">"es6"</span>, <span class="string">"react"</span>, <span class="string">"angular"</span>],</span><br><span class="line">say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.skill.length; i&lt; len; i++)&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'No.'</span> + i + <span class="keyword">this</span>.name);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.skill[i]);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'--------------------------'</span>);</span><br><span class="line">   &#125;, <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>

<p><img src="/images/loading.png" data-original="https://uploadfiles.nowcoder.com/images/20191107/5097896_1573106521909_62B29BD26061B47E81ED3150A290E160" alt="图片说明"></p>
<p>解：</p>
<ul>
<li>第一点：for循环当中有个异步函数，而且异步函数根据for循环<code>i</code>的值依次输出No.1，No.2，No.3，这样的话for循环中<code>i</code>必须使用let去声明，因为使用let才能让异步函数记住每一轮<code>i</code>的值，得到相应的输出结果。</li>
<li>第二点：在对象函数say中，有一个异步函数，它使用了this。源代码的意图是想让这个this表示对象<code>obj</code>，但是对象的方法say的this指向的是<code>obj</code>，但是这个方法内部的函数（使用了闭包）是指向全局变量的！这么写是得不到想要的结果的。所以要将<code>setTimeout</code>函数改为箭头函数，因为箭头函数它会继承上一层作用域的this，所以它会继承say函数的this，就会指向<code>obj</code>了。</li>
</ul>
<p>修改后的代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">" jsCoder"</span>,</span><br><span class="line">    skill: [<span class="string">"es6"</span>, <span class="string">"react"</span>, <span class="string">"angular"</span>],</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,len=<span class="keyword">this</span>.skill.length; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">//闭包！！</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'No.'</span> + (i+<span class="number">1</span>) + <span class="keyword">this</span>.name);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.skill[i]);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'--------------------------'</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>



<hr>

<p>Q：repeat 实现，使用JS实现一个repeat方法，调用这个 repeatedFunc(“helloworld”)，会alert4次 helloworld, 每次间隔3秒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> repeatFunc = repeat(alert, <span class="number">4</span>, <span class="number">3000</span>)</span><br><span class="line">repearFunc(<span class="string">"helloworld"</span>);</span><br></pre></td></tr></table></figure>

<p>解：</p>
<p>这种问题一般要结合闭包来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args=[].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        timer=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==(times<span class="number">-1</span>))&#123;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">            &#125;</span><br><span class="line">            func(args.join(<span class="string">""</span>));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目中说，调用<code>repeatedFunc(&quot;helloworld&quot;)</code>会有相关的结果，所以它应该是在函数中还有一个函数的，所以应该有个闭包。通过闭包可以记住count的值。注意<code>clearTimeout</code>要写在<code>setInterval</code>函数当中，这个和防抖节流不同，因为它只执行了一次函数，它是通过<code>setInterval</code>函数的循环才会输出多次结果，所以要写在里面才能够判断count的值是否已经到达输出次数。</p>
<hr>

<p>Q：实现每隔1s输出一个数组的元素及其索引</p>
<p>解：</p>
<p>这题和上一题的思路类似，但是它没有需要说要调用的时候再去执行，那就不需要写<code>return functionf(){}</code>了。因为<code>setInterval</code>函数已经是output函数的内部函数，有闭包能够记住count的值了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = arr.length;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == length - <span class="number">1</span>) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[count]);</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——最大上升子序列</title>
    <url>/2020/03/14/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>



<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>思路：</p>
<p>动态规划的思想。先初始化每个元素的最大上升子序列长度为1。当前元素的最大上升子序列数应为在它前面比该元素小的元素的最大上升子序列数的最大值+1。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dp=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;j;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[k])&#123;</span><br><span class="line">                dp[j]=<span class="built_in">Math</span>.max(dp[k]+<span class="number">1</span>,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> p=<span class="number">0</span>;p&lt;nums.length;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[p]&gt;res)&#123;</span><br><span class="line">            res=dp[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——合并区间</title>
    <url>/2020/03/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>将每个区间的第一个数字放入<code>start</code>数组中，将每个区间的第二个数字放入<code>end</code>数组中，对<code>start</code>数组和<code>end</code>数组进行排序。判断<code>start[i+1]</code>和<code>end[i]</code>的大小，如果前者小，则说明区间有覆盖，<code>i++</code>；如果前者大，说明区间没有覆盖，可以将这个结果<code>push</code>进结果数组<code>res</code>中，同时<code>j=i+1</code>（<code>j</code>最开始为0）。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start=[];</span><br><span class="line">    <span class="keyword">var</span> end=[];</span><br><span class="line">    <span class="keyword">var</span> res=[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;intervals.length;++i)&#123;</span><br><span class="line">        start.push(intervals[i][<span class="number">0</span>]);</span><br><span class="line">        end.push(intervals[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    end.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">0</span>,m=<span class="number">0</span>;n&lt;intervals.length;++n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==intervals.length<span class="number">-1</span>||start[n+<span class="number">1</span>]&gt;end[n])&#123;</span><br><span class="line">            res.push([start[m],end[n]]);</span><br><span class="line">            m=n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——单词的压缩编码</title>
    <url>/2020/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="单词的压缩编码"><a href="#单词的压缩编码" class="headerlink" title="单词的压缩编码"></a><a href="https://leetcode-cn.com/problems/short-encoding-of-words/" target="_blank" rel="noopener">单词的压缩编码</a></h2><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p>
<p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p>
<p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; words.length &lt;&#x3D; 2000</span><br><span class="line">1 &lt;&#x3D; words[i].length &lt;&#x3D; 7</span><br><span class="line">每个单词都是小写字母 。</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>首先要先读懂题意，如果是单词之间的覆盖，只能是后缀覆盖，而不能是中间覆盖；其次，不一定是相邻的单词之间会出现覆盖，有可能像<code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;, &quot;atime&quot;]</code>跨着来覆盖。</p>
<p>所以我们先按单词的长度进行降序排列，这样先将最大的添加到结果字符串中，后续判断较小的单词只需要使用<code>indexOf</code>方法，就能够判断是否在结果字符串中。</p>
<p>需要注意的是，单词之间的覆盖只能是后缀覆盖，所以使用<code>indexOf</code>判断的时候要加上<code>“#”</code>。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">words</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minimumLengthEncoding = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">    words.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.length-a.length;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> res=<span class="string">""</span>;</span><br><span class="line">    res+=words[<span class="number">0</span>]+<span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;words.length;++i)&#123;</span><br><span class="line">        <span class="comment">//加上#号就控制必须是后缀部分</span></span><br><span class="line">        <span class="keyword">if</span>(res.indexOf(words[i]+<span class="string">"#"</span>)===<span class="number">-1</span>)&#123;</span><br><span class="line">            res+=words[i]+<span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——按摩师</title>
    <url>/2020/03/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%8C%89%E6%91%A9%E5%B8%88/</url>
    <content><![CDATA[<h2 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>动态规划的思想。但是这题和最大上升子序列的动态规划思想不同。这题与背包问题都是要求一个对于整体来说最大的和，但是最大上升子序列是求一个最长的上升子序列，之前的数要比当前的数小才能做一次计算，和是否相邻无关，所以最大上升子序列还需要在内层加多一层循环。</p>
<p>题解：</p>
<p>最初想的方案：</p>
<p>内层多了一个循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> massage = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F=[];</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;nums.length;++m)&#123;</span><br><span class="line">        F[m]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    F[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-2</span>;++j)&#123;</span><br><span class="line">            F[i]=<span class="built_in">Math</span>.max(F[j]+nums[i],F[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;F.length;++t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(F[t]&gt;max)&#123;</span><br><span class="line">            max=F[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>后来看评论优化的题解：</p>
<p><code>dp</code>思想：<code>F[i]=Math.max(F[i-1],F[i-2]+nums[i]);</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> massage = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F=[];</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;nums.length;++m)&#123;</span><br><span class="line">        F[m]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    F[<span class="number">1</span>]=<span class="built_in">Math</span>.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        F[i]=<span class="built_in">Math</span>.max(F[i<span class="number">-1</span>],F[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F[nums.length<span class="number">-1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——岛屿的最大面积</title>
    <url>/2020/03/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积</a></h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure>

<p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure>

<p>对于上面这个给定的矩阵, 返回 0。</p>
<p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p>
<p>思路：<br>和腐烂的橘子的思想类似，使用广度优先遍历，然后queue来实现（JS中用普通数组，使用shift来获取列头元素，不要写错成pop()，c++中队列的pop()和JS中普通数组的shift()才是对应的）。而且要另外维护一个flag数组，用来记录每个数组中的元素是否已经判断过了，如果判断过了的话，就要将flag变为true，下一次不用再去判断。</p>
<p>用JS声明二维数组的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;        <span class="comment">//一维长度为3</span></span><br><span class="line">	a[i] = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;    <span class="comment">//二维长度为5</span></span><br><span class="line">		a[i][j] = i+j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> q=[];</span><br><span class="line">    <span class="keyword">var</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> step=[[<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>]]; <span class="comment">//用来进行广度遍历</span></span><br><span class="line">    <span class="keyword">var</span> flag=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">0</span>;n&lt;grid.length;++n)&#123;</span><br><span class="line">        flag[n]=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;grid[<span class="number">0</span>].length;++m)&#123;</span><br><span class="line">            flag[n][m]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;grid.length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>&amp;&amp;flag[i][j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                q.push([i,j]);</span><br><span class="line">                flag[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(q.length!==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> temp=q.shift();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;step.length;++k)&#123;</span><br><span class="line">                        <span class="keyword">var</span> x=temp[<span class="number">0</span>]+step[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">var</span> y=temp[<span class="number">1</span>]+step[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;grid.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(grid[x][y]==<span class="number">1</span>&amp;&amp;flag[x][y]==<span class="literal">false</span>)&#123;</span><br><span class="line">                                q.push([x,y]);</span><br><span class="line">                                flag[x][y]=<span class="literal">true</span>;</span><br><span class="line">                                count++;</span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;res)&#123;</span><br><span class="line">                    res=count;</span><br><span class="line">                &#125;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——水壶问题</title>
    <url>/2020/03/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener">*”Die Hard”* example</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>当x=3,y=5,z=4的时候怎么倒出4L水：</p>
<ul>
<li>首先装满x，将x中的3L水倒入y中，</li>
<li>然后再装满x，将x的水倒入y中，此时只能倒2L，那x中就剩下1L水</li>
<li>将y中的水倒掉，将x中的1L水倒入</li>
<li>x再装满3L水，倒入y中，此时y就有4L水</li>
</ul>
<p>它的思路就是：x和y的最大公约数是否能够被z整除。与此同时要考虑，x和y加起来的大小是否比z要小，如果小的话就不可能装得下。还要考虑，两个壶为0的情况，因为mod操作是不能mod0的。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">y</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">z</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canMeasureWater = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">        temp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x+y&lt;z)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        temp=y;</span><br><span class="line">        y=x;</span><br><span class="line">        x=temp%x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>&amp;&amp;z!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(z%y==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——版本号比较 随机生成字符串 类型比较</title>
    <url>/2020/03/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="版本号比较"><a href="#版本号比较" class="headerlink" title="版本号比较"></a>版本号比较</h2><p>比较版本号 （类似1.0.1/1.2.0/1.2/0.1）<br>实现一个方法，用于比较两个版本号（version1、version2）<br>如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则<code>x.y.z</code>，xyz均为大于等于0的整数，至少有x位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">str1,str2</span>)</span>&#123;</span><br><span class="line">    str1=str1.split(<span class="string">"."</span>);</span><br><span class="line">    str2=str2.split(<span class="string">"."</span>);</span><br><span class="line">    str1=str1.map(<span class="built_in">Number</span>);</span><br><span class="line">    str2=str2.map(<span class="built_in">Number</span>);</span><br><span class="line">    <span class="keyword">var</span> len;</span><br><span class="line">    <span class="keyword">var</span> len1=str1.length;</span><br><span class="line">    <span class="keyword">var</span> len2=str2.length;</span><br><span class="line">    <span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line">        len=len2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        len=len1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]&gt;str2[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str1[i]&lt;str2[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1===len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(compare(<span class="string">'1.0.1'</span>,<span class="string">'1.0'</span>));</span><br></pre></td></tr></table></figure>





<h2 id="随机生成字符串"><a href="#随机生成字符串" class="headerlink" title="随机生成字符串"></a>随机生成字符串</h2><p>随机生成字符串<br>实现一个随机符串生成函数 <code>randomStr()</code>，要求如下：<br>生成的随机的字符串应该以字母开头，并包含  <code>[a-z][0-9]</code> 这些字符。<br>生成的字符串长度为 8。<br>生成的字符串不能够在程序运行的生命周期中存在重复的情形。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len,chars</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="comment">//因为Math.random()包括0但不包括1，所以可以直接乘上chars.length</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            res+=chars[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">26</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res+=chars[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*chars.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(randomString(<span class="number">8</span>,<span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span>));</span><br></pre></td></tr></table></figure>





<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h3 id="下面代码中-a-在什么情况下会打印-1？"><a href="#下面代码中-a-在什么情况下会打印-1？" class="headerlink" title="下面代码中 a 在什么情况下会打印 1？"></a>下面代码中 a 在什么情况下会打印 1？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">	i:<span class="number">1</span>,</span><br><span class="line">	toString()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>&amp;&amp;a==<span class="number">2</span>&amp;&amp;a==<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——矩阵重叠</title>
    <url>/2020/03/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a><a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">矩形重叠</a></h2><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。<br>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</p>
<p>思路：</p>
<p><img src="/images/loading.png" data-original="./%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/1.jpg" alt="img"></p>
<p>两个矩形，我们只需要关注它们离彼此最近的两个点。两个矩阵只要靠左边矩形的右上角的x比右边矩形左下角的x要小（小于等于）的话，就不会重叠；或者是，靠左边矩形的右下角的y比右边矩形右上角y要大（大于等于）的话，也不会重叠。因为rec1和rec2的顺序不一定就是rec1在左，rec2在右，所以要考虑反过来情况。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">rec1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">rec2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isRectangleOverlap = <span class="function"><span class="keyword">function</span>(<span class="params">rec1, rec2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]||rec2[<span class="number">2</span>]&lt;=rec1[<span class="number">0</span>]||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]||rec2[<span class="number">1</span>]&gt;=rec1[<span class="number">3</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——编辑距离</title>
    <url>/2020/03/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>动态规划的思想。</p>
<ul>
<li>如果<code>word1[i]===word2[j]</code>，<code>dp[i][j]=dp[i-1][j-1]</code>，也就是说<code>word1</code>的第<code>i</code>个单词和<code>word2</code>的第<code>j</code>个单词相同的话，那<code>word1</code>前<code>i</code>个单词要变为<code>word2</code>前<code>j</code>个单词的编辑次数就会等于<code>word1</code>前<code>i-1</code>和单词变为<code>word2</code>前<code>j-1</code>个单词的编辑次数。</li>
<li>如果<code>word1[i]!=word2[j]</code>，那<code>dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1</code><ul>
<li><code>dp[i-1][j-1]</code>表示替换操作，也就是将<code>word1[i]</code>替换为<code>word2[j]</code>，那<code>dp[i][j]</code>就等于<code>dp[i-1][j-1]</code>+1，也就是将<code>word1</code>前<code>i-1</code>个单词变为<code>word2</code>前<code>j-1</code>个单词所要执行的编辑次数+1（一次替换操作）。</li>
<li><code>dp[i-1][j]</code>表示删除操作，就是将<code>word1</code>前<code>i-1</code>个字符变为<code>word2</code>前<code>j</code>个字符所要执行的操作+1（一次删除操作，即将<code>word1</code>的第<code>i</code>个字符删掉）</li>
<li><code>dp[i][j-1]</code>表示插入操作，就是将<code>word1</code>前<code>i</code>个字符变为<code>word2</code>前<code>j-1</code>个字符所要执行的操作+1（一次插入操作，在<code>word1</code>插入一个和<code>word2</code>第<code>j</code>个字符一样的字符）</li>
</ul>
</li>
</ul>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dp=[];</span><br><span class="line">    <span class="keyword">var</span> len1=word1.length;</span><br><span class="line">    <span class="keyword">var</span> len2=word2.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=len1;++i)&#123;</span><br><span class="line">        dp[i]=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=len1;++j)&#123;</span><br><span class="line">        dp[j][<span class="number">0</span>]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;=len2;++k)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][k]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">1</span>;n&lt;=len1;++n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">1</span>;m&lt;=len2;++m)&#123;</span><br><span class="line">            <span class="comment">//这里表示的是word1[n]==word2[m],但是因为n和m是从1开始取的,所以比较的时候要-1</span></span><br><span class="line">            <span class="keyword">if</span>(word1[n<span class="number">-1</span>]==word2[m<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[n][m]=dp[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[n][m]=<span class="built_in">Math</span>.min(dp[n<span class="number">-1</span>][m<span class="number">-1</span>],dp[n][m<span class="number">-1</span>],dp[n<span class="number">-1</span>][m])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——腐烂的橘子</title>
    <url>/2020/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<p> <img src="/images/loading.png" data-original="./%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/oranges.png" alt="img"></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure>




<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; grid.length &lt;&#x3D; 10</span><br><span class="line">1 &lt;&#x3D; grid[0].length &lt;&#x3D; 10</span><br><span class="line">grid&#96;[i][j]&#96; 仅为 0、1 或 2</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>广度优先搜索。广度优先搜索的话一般会使用队列的思想，深度优先搜索使用栈的思想。最主要还有如何去控制节点去上下左右遍历，所以我们要设置一个<code>locs</code>数组为：[[0,-1],[0,1],[1,0],[-1,0]]，在遍历每个队列元素时，都让它去和<code>locs</code>数组的每个元素进行相加减，得到这个元素上下左右的元素，将为1的元素（即新鲜橙子），变为2（即腐烂橙子）。因为我们要计算时间，但又不能将循环次数用来计时，所以我们将时间和节点的x，y坐标一齐作为一个元素进入队列。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> row=grid.length;</span><br><span class="line">    <span class="keyword">var</span> col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">var</span> queue=[];</span><br><span class="line">    <span class="keyword">var</span> locs=[[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">var</span> time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;row;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;col;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                queue.push([i,j,time]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.length!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//这是queue！！不要写成stack,先进先出是用shift</span></span><br><span class="line">        [x,y,time]=queue.shift();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;locs.length;++t)&#123;</span><br><span class="line">            <span class="keyword">var</span> new_x=x+locs[t][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> new_y=y+locs[t][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;row&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;col)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[new_x][new_y]===<span class="number">1</span>)&#123;</span><br><span class="line">                    queue.push([new_x,new_y,time+<span class="number">1</span>]);</span><br><span class="line">                    grid[new_x][new_y]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> p=<span class="number">0</span>;p&lt;row;++p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> q=<span class="number">0</span>;q&lt;col;++q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[p][q]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——零钱兑换</title>
    <url>/2020/03/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>



<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>



<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<p>思路：<br>动态规划的思想，每种硬币都找到当前自身的最优解，从而求出结果为amount时的最优解。在初始化的时候，要为每种金额的硬币声明一个初始的解，这个解应该是个比amount要大的值（因为解最大为amount）。这样我们在做结果判断的时候就可以知道，如果当前解是amount+1就说明没有组合能组成总金额。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    coins.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(coins);</span><br><span class="line">    <span class="keyword">var</span> F=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=amount;++i)&#123;</span><br><span class="line">        F[i]=amount+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=amount;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;coins.length;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;coins[k])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                F[j]=<span class="built_in">Math</span>.min(F[j-coins[k]]+<span class="number">1</span>,F[j]);  <span class="comment">//注意此处是F[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F[amount]!==amount+<span class="number">1</span>?F[amount]:<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染过程</title>
    <url>/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="浏览器渲染的过程主要包括以下5步"><a href="#浏览器渲染的过程主要包括以下5步" class="headerlink" title="浏览器渲染的过程主要包括以下5步"></a>浏览器渲染的过程主要包括以下5步</h2><ol>
<li>浏览器将获取的HTML文档解析为DOM树</li>
<li>处理CSS标记，构成CSS规则树</li>
<li>将DOM树和CSS规则树合并为渲染树（rendering tree），生成渲染树</li>
<li>渲染树布局，确定每个节点对象在页面上的确切大小和位置</li>
<li>将渲染树的各个节点绘制到屏幕上</li>
</ol>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/1.png" class>

<br>



<h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>当浏览器接受到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。注意：DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。</p>
<h3 id="构建CSS规则树"><a href="#构建CSS规则树" class="headerlink" title="构建CSS规则树"></a>构建CSS规则树</h3><p>浏览器解析CSS文件并生成CSS规则树。注意：CSS解析可以与DOM解析同时执行，但与<code>script</code>的执行互斥。</p>
<h3 id="构建渲染树（Render-Tree）"><a href="#构建渲染树（Render-Tree）" class="headerlink" title="构建渲染树（Render Tree）"></a>构建渲染树（Render Tree）</h3><p>通过DOM树和CSS规则树，浏览器可以通过它们构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。</p>
<p>渲染树生成后，还不能渲染到屏幕上。因为渲染到屏幕上需要得到各个节点的位置信息，这就需要布局的处理。</p>
<h3 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h3><p>布局阶段从渲染树的根节点开始遍历，渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。浏览器通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。</p>
<h3 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h3><p>将渲染树绘制到浏览器上。</p>
<h4 id="主流的一些浏览器排版（渲染）引擎"><a href="#主流的一些浏览器排版（渲染）引擎" class="headerlink" title="主流的一些浏览器排版（渲染）引擎"></a>主流的一些浏览器排版（渲染）引擎</h4><table>
<thead>
<tr>
<th>浏览器</th>
<th>排版引擎</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome Opera</td>
<td>Blink</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
</tr>
<tr>
<td>Safari</td>
<td>WebKit</td>
</tr>
</tbody></table>
<br>



<h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p>渲染阻塞的原因：由于JavaScript可以操作DOM来修改DOM结构，可以操作CSS规则树来修改节点样式，这就导致浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直到脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。</p>
<p>现在可以通过在<code>&lt;script&gt;</code>标签上增加属性<code>defer</code>或者<code>async</code>，解决上述问题。这两个属性使得<code>script</code>标签不会阻塞DOM的渲染，<strong>能够异步加载script脚本，不阻塞DOM渲染</strong>。</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a><code>defer</code></h3><p>如果<code>script</code>标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行）</p>
<p>使用方法：</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/2.png" class>



<h3 id="async"><a href="#async" class="headerlink" title="async"></a><code>async</code></h3><p><code>async</code>的设置，会使得<code>script</code>脚本异步加载。<code>async</code>的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/3.png" class>



<p>用图表来展示：</p>
<p><strong>文档渲染 应该为 文档解析</strong></p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/4.png" class>



<h4 id="普通的script"><a href="#普通的script" class="headerlink" title="普通的script"></a>普通的script</h4><p>文档解析的过程中，如果遇到<code>script</code>脚本，就会停止页面的解析进行下载。</p>
<p>资源的下载是在解析过程中进行的，虽说<code>script1</code>脚本会很快的加载完毕，但是他前边的<code>script2</code>并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待<code>script2</code>执行完毕后再执行。<br>当这两个脚本都执行完毕后，才会继续解析页面。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/5.png" class>



<h4 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a><code>defer</code></h4><p>文档解析时，遇到设置了<code>defer</code>的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。<br>会等到所有的<code>defer</code>脚本加载完毕并按照顺序执行，执行完毕后会触发<code>DOMContentLoaded</code>事件。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/6.png" class>



<h4 id="async-1"><a href="#async-1" class="headerlink" title="async"></a><code>async</code></h4><p><code>async</code>脚本会在加载完毕后执行。<br><code>async</code>脚本的加载不计入<code>DOMContentLoaded</code>事件统计，也就是说下图两种情况都是有可能发生的。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/7.png" class>

<br>



<h2 id="浏览器的回流与重绘"><a href="#浏览器的回流与重绘" class="headerlink" title="浏览器的回流与重绘"></a>浏览器的回流与重绘</h2><p><code>回流</code>：对于整个网页重新渲染一遍。</p>
<ul>
<li>会导致回流的操作有：<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生变化</li>
<li>元素尺寸或位置发生变化</li>
<li>元素内容发生变化（文字数量或图片大小等）</li>
<li>元素字体大小变化</li>
<li>添加或删除<strong>可见</strong>的DOM元素</li>
<li>激活<code>css</code>伪类（例如<code>:hover</code>）</li>
</ul>
</li>
</ul>
<p><code>重绘</code>：浏览器只需要对某个元素进行重新绘制即可</p>
<ul>
<li>会导致重绘的操作有：<ul>
<li>修改<code>color</code>/<code>background-color</code>/<code>visibility</code></li>
</ul>
</li>
</ul>
<p>由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流操作一定会伴随重绘，重绘却不一定伴随回流。</p>
<p>那么如何针对回流和重绘写出性能更好的代码呢？</p>
<p><code>CSS</code>：</p>
<ul>
<li>避免使用<code>table</code>布局</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code></li>
<li>避免设置多层内联样式</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li>
<li>避免使用<code>css</code>表达式（例如：<code>calc()</code>）</li>
</ul>
<p><code>JavaScript</code></p>
<ul>
<li>避免频繁操作样式</li>
<li>避免频繁操作DOM。创建一个<code>documentFragment</code>，在它上面应用所有的DOM操作，最后再把它添加到文档中</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h2 id="DOM-CSS-JS之间的关系"><a href="#DOM-CSS-JS之间的关系" class="headerlink" title="DOM CSS JS之间的关系"></a>DOM CSS JS之间的关系</h2><ul>
<li>CSS是不会阻塞DOM的解析的，JS是会阻塞DOM的解析的</li>
<li>CSS是会阻塞DOM的渲染的。如果没有这个策略的话，页面首先会呈现一个原始的模样，待CSS下载完后又变成另一个模样，这样会导致用户体验变差而且渲染是有成本的。</li>
<li>JS是会等待CSS加载完才会执行的（如果CSS文件在JS文件之前声明的话，那JS需要等待CSS文件加载完毕后才会执行）。<ul>
<li>原因：因为JS有时需要查询（获取）元素的一些样式，这些样式是定义在CSS文件里的，所以CSS加载完之后再去执行JS会更好一些。</li>
</ul>
</li>
</ul>
<p>所以<code>&lt;script&gt;</code>最好放在底部，<code>&lt;link&gt;</code>最好放在头部，是因为JS会阻塞DOM树的解析，CSS不会阻塞DOM树的解析。</p>
<p>如果头部同时有<code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>的情况下，最好将<code>&lt;script&gt;</code>放在<code>&lt;link&gt;</code>上面，是因为JS会等待CSS加载完毕后才会执行，但是放在头部的JS一般不会对样式进行查询修改，所以放在前面没有太大影响（比如说引入VUE的CDN的js代码就会在头部，但是和CSS样式是无关的）</p>
<br>

<p>参考：</p>
<p><a href="https://www.cnblogs.com/jiasm/p/7683930.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiasm/p/7683930.html</a></p>
<p><a href="https://www.jianshu.com/p/e6252dc9be32" target="_blank" rel="noopener">https://www.jianshu.com/p/e6252dc9be32</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存过程分析："><a href="#缓存过程分析：" class="headerlink" title="缓存过程分析："></a>缓存过程分析：</h2><ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找请求的结果以及缓存标识</li>
<li>如果没有该请求的缓存结果和缓存标识的话，浏览器会向服务器发起http请求，服务器返回该请求结果和缓存规则</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<img src="/images/loading.png" data-original="/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/1.png" class>

<br>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><h4 id="浏览器缓存分为：强缓存和协商缓存"><a href="#浏览器缓存分为：强缓存和协商缓存" class="headerlink" title="浏览器缓存分为：强缓存和协商缓存"></a>浏览器缓存分为：强缓存和协商缓存</h4><br>

<ul>
<li><p><strong>强缓存</strong>：不会向服务器发送请求，直接从缓存中读取资源。可以通过设置两种http header实现：Expires和Cache-Control。</p>
<ul>
<li><p>Expires是http/1的产物。它用来指定资源到期的时间，Expires是web服务器响应消息头字段，在响应http请求时<strong>告诉浏览器在过期时间之前浏览器可以直接从浏览器缓存取数据，而无需再次请求</strong>。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Thu, 10 Nov 2017 08:45:11 GMT</span><br></pre></td></tr></table></figure>

<p>这个字段设置时有两个缺点：</p>
<ol>
<li>由于是<strong>绝对时间</strong>，用户可能会将客户端本地的时间修改，而导致浏览器判断缓存失效，重新请求该资源。</li>
<li><strong>写法太复杂</strong>，表示时间的字符串多个空格，少个字母都会导致非法属性从而失效</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Cache-control是http/1.1的产物。和Expires的差别在于，Expires是绝对时间，Cache-control表示的是相对时间</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-control</span>: max-age=2592000</span><br></pre></td></tr></table></figure>

<p><code>Cache-control</code>字段常用的值：</p>
<ol>
<li><code>max-age</code>：即最大有效时间</li>
<li><code>must-revalidate</code>：如果超过了<code>max-age</code>的时间，浏览器必须向服务器发送请求，验证资源是否还有效</li>
<li><code>no-cache</code>：<strong>不是不缓存的意思！</strong>表示可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用。<ol start="4">
<li><code>no-store</code>：彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取</li>
</ol>
</li>
<li><code>public</code>：所有内容都可以被缓存（包括客户端和代理服务器，如CDN）</li>
<li><code>private</code>：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li>
</ol>
<p>自从http/1.1开始，Expires逐渐被<code>Cache-control</code>取代。<code>Cache-control</code>是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且<code>Cache-control</code>的可配置性比较强大。</p>
</li>
</ul>
<p>  强缓存判断是否缓存的依据来自于是否超出某个时间或者时间段，而不关心服务器端文件是否已经更新，这可能导致加载文件不是服务器端最新的内容。<strong>那我们如何获知服务器端内容是否已经发生了更新呢？</strong>此时我们需要用到协商缓存策略。</p>
<br>



<ul>
<li><p><strong>协商缓存</strong>：是由服务器来确定缓存资源是否可用，所以客户端与服务器端需要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p>
<p>主要有以下两种标识：</p>
<ul>
<li><p>Last-Modified和If-Modified-Since：</p>
<ul>
<li>Last-Modified：浏览器在第一次访问资源时，<strong>服务器返回资源的同时，在response header中添加Last-Modified的header</strong>，值是这个资源在服务器端的最后修改时间。</li>
<li>If-Modified-Since：浏览器下一次请求这个资源，浏览器检测有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值。服务器再次收到这个资源的请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，可以直接从缓存读取。如果服务器端这个资源在If-Modified-Since之后被修改了，说明文件有更新，返回新的资源文件和200。</li>
</ul>
</li>
</ul>
<img src="/images/loading.png" data-original="/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/2.png" class>



</li>
</ul>
<ul>
<li><p><code>Etag</code>和If-None-Match:</p>
<p><code>Etag</code>和If-None-Match返回的是一个校验码。<code>Etag</code>可以保证每一个资源是唯一的，资源变化都会导致<code>Etag</code>变化。</p>
<p>当浏览器第一次请求资源的时候，服务器会在响应报文中添加<code>Etag</code>（表示资源的标签）。当浏览器再次发起请求的时候，请求报文中会添加If-None-Match字段，其值是上一次响应报文中<code>Etag</code>的值。服务器收到请求报文的时候，会检查If-None-Match的值与当前资源<code>Etag</code>的值是否匹配。如果匹配，也就是资源没有被修改，返回304；如果不匹配，也就是服务器端资源被修改了，返回200，并返回新的资源。</p>
</li>
</ul>
<ul>
<li>为什么有了Last-Modified和If-Modified-Since还要<code>Etag</code>和If-None-Match呢？<ul>
<li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用</li>
<li>某些文件修改非常频繁，比如在秒以下级别的时间内进行修改（比如1s内修改了N次），If-Modified-Since能检查到的粒度只能是秒级别的，这种修改无法判断。</li>
</ul>
</li>
</ul>
<ul>
<li>协商缓存生效：返回304和Not Modified。即服务器端资源并没有更新，可以继续使用浏览器缓存中的结果。</li>
<li>协商缓存失败，返回200和请求结果。即服务器端资源更新了，获取服务器端的返回结果，并把请求结果和缓存标识存入浏览器缓存中</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存机制：</p>
<ul>
<li><strong>强制缓存优先于协商缓存进行</strong></li>
<li><strong>若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和<code>Etag</code> / If-None-Match)</strong></li>
<li><strong>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存</strong>。</li>
<li>Last-Modified/If-Modified-Since 和 <code>Etag</code>/If-None-Match的主要区别就是一个是<strong>通过时间判断资源是否已被更改</strong>，一个是<strong>通过<code>Etag</code>来判断</strong>。<code>Etag</code>/If-None-Match相比于Last-Modified/If-Modified-Since来说更好。</li>
</ul>
<br>

<p>  摘自：<a href="https://www.cnblogs.com/yayaxuping/p/9707471.html" target="_blank" rel="noopener">https://www.cnblogs.com/yayaxuping/p/9707471.html</a></p>
<p>​             <a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect</a></p>
<br>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>由instanceof原生实现理解__proto__和prototype的区别</title>
    <url>/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>前几天面试的时候被问到<code>instanceof</code>的原生实现，当时对<code>__proto__</code>和<code>prototype</code>的区别理解不是很透彻，一直记得的是几个月前在网上的某篇博客上看到的结论：“<code>__proto__</code>：和prototype其实是一个东西，prototype是官方所定义的属性，<code>__proto__</code>是浏览器自己对prototype所做的实现。”后来仔细再查了些文章发现似乎并不是这样。</p>
<br>

<h2 id="proto-和prototype的区别"><a href="#proto-和prototype的区别" class="headerlink" title="__proto__和prototype的区别"></a><code>__proto__</code>和<code>prototype</code>的区别</h2><h3 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h3><p>原型的定义：每个<code>js</code>对象（除了null）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。</p>
<p>比如我们定义一个构造函数<code>Person</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就创建了一个对象（function也是对象），那这个Person构造函数是有它的<code>prototype</code>的。这个Person prototype的构造函数constructor就是这个Person构造函数。我们还可以在这个Person prototype上去定义一些共享的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Alice"</span>;</span><br><span class="line">Person.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello "</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写就在Person prototype上定义了公用的属性<code>name</code>和<code>sayHello</code>。</p>
<p>现在创建两个对象实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</span><br><span class="line">person1.name=<span class="string">"Emma"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//Emma</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">//Alice</span></span><br></pre></td></tr></table></figure>

<p>我们为这个<code>person1</code>定义了它的实例属性name为”Emma”，那<code>person2</code>没有定义它的实例属性，所以它会沿着原型链去找它的原型去找是否有这个属性，因为<code>Person.prototype</code>里定义了<code>name</code>属性，所以输出<code>Alice</code>。</p>
<p>如果<code>Person.prototype</code>中没有定义<code>name</code>属性，那<code>person2.name</code>输出的是<code>undefined</code>，构造函数里的<code>this.name</code>是不起作用的。</p>
<img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class>

<br>



<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/4.png" class>

<p>以上这幅图大致可以说明<code>__proto__</code>和<code>prototype</code>的关系。</p>
<p>现在来说一下我们使用new去创建一个构造函数实例的时候做了些什么：</p>
<p><code>new</code>的原生实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">Parent,...args</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">	obj.__proto__=Parent.prototype;</span><br><span class="line">	<span class="keyword">var</span> res=Parent.apply(obj,args);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> res==<span class="string">"object"</span>?res:obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>new</code>创建一个实例的时候，我们将这个实例的<code>__proto__</code>指向构造函数的原型。</p>
<img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class>

<p><code>__proto__</code>和<code>prototype</code>并不是一样的：</p>
<img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/3.png" class>

<br>



<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.constructor===Person;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这个由上图可以看出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line">person1.constructor===Person; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>但是<code>person1</code>是没有<code>constructor</code>属性的，而是通过原型链去找到<code>Person.prototype</code>上的<code>constructor</code>属性。</p>
<br>

<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a><code>Object.prototype</code></h2><p><code>Object.prototype</code>是没有原型的，<code>Object.prototype</code>就是尽头。</p>
<br>



<h2 id="instanceof的原生实现"><a href="#instanceof的原生实现" class="headerlink" title="instanceof的原生实现"></a><code>instanceof</code>的原生实现</h2><p><code>instanceof</code>在MDN当中的定义就是<code>object instanceof constructor</code>，判断这个<code>constructor</code>的<code>prototype</code>是否在<code>object</code>的原型链上。<code>object</code>原型链上的原型我们可以通过<code>__proto__</code>来去获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> leftval=left.__proto__;  <span class="comment">//实例用__proto__</span></span><br><span class="line">	<span class="keyword">var</span> rightval=right.prototype;  <span class="comment">//构造函数用prototype</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(leftval==<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//Object.prototype.__proto__为null</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(leftval==rightval)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		leftval=leftval.__proto__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>设置display:none对DOM树和渲染树的影响</title>
    <url>/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h2 id="原本的样式"><a href="#原本的样式" class="headerlink" title="原本的样式"></a>原本的样式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">            background-color: lightyellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        display属性testing</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="/images/loading.png" data-original="http://q7zfh0r3l.bkt.clouddn.com/blog/20200330/xAEupl9vw42t.png?imageslim" alt="mark"></p>
<br>

<h2 id="设置display-none对渲染树的影响"><a href="#设置display-none对渲染树的影响" class="headerlink" title="设置display:none对渲染树的影响"></a>设置<code>display:none</code>对渲染树的影响</h2><p>在原本的<code>style</code>中添加上<code>display:none</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.main</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">        <span class="attribute">display</span>:none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>页面上没有显示任何东西：</p>
<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/2.png" class>

<p>所以设置<code>display:none</code>是会将节点从渲染树中摘除的。</p>
<br>



<h2 id="设置display-none对DOM树的影响"><a href="#设置display-none对DOM树的影响" class="headerlink" title="设置display:none对DOM树的影响"></a>设置<code>display:none</code>对DOM树的影响</h2><p>我们在刚才的代码中添加上一段<code>js</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> node=<span class="built_in">document</span>.getElementsByClassName(<span class="string">"main"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(node.innerText);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/3.png" class>

<p>说明DOM树中该节点并没有消失，否则不会获取到DOM上的信息。</p>
<br>



<h2 id="设置display-none对CSS规则树的影响"><a href="#设置display-none对CSS规则树的影响" class="headerlink" title="设置display:none对CSS规则树的影响"></a>设置<code>display:none</code>对CSS规则树的影响</h2><p>我们在div当中添加style样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width:100px"</span>&gt;</span></span><br><span class="line">	display属性testing</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>script</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(node.style.width);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/4.png" class>

<p>说明CSS规则树中该节点的样式没有消失。</p>
<br>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p>如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖（debounce）和节流（throttle）的方式来减少调用频率，同时又不影响实际效果。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>含义：当持续触发事件时，一定时间段内没有在触发事件，事件处理函数才会执行一次；如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>
<img src="/images/loading.png" data-original="/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/1.jpg" class>



<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//取消由 setTimeout() 方法设置的 timeout</span></span><br><span class="line">        <span class="keyword">if</span>(timeout!==<span class="literal">null</span>) </span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>防抖是通过<strong>闭包</strong>实现的，所以timeout是会被缓存的。如果在频繁触发事件之后的一段时间内，又再次触发了事件，那就会使用<code>clearTimeout</code>清除<code>setTimout</code>设置的<code>timout</code>，重新计时。</p>
<p>具体完整代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(fn, wait)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//取消由 setTimeout() 方法设置的 timeout</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span>(timeout!==<span class="literal">null</span>) </span></span><br><span class="line">                    clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(fn, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 处理函数</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 滚动事件</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示4<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示6<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示7<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示8<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示9<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示10<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示11<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示12<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示13<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示14<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示15<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示16<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在网页运行的时候我们会看到，当在滚动页面操作停止后1s，控制台会有输出。这就是防抖。</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>当持续触发事件时，保证每隔一定时间段内只调用一次事件处理函数。</p>
<img src="/images/loading.png" data-original="/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/2.jpg" class>



<p>用定时器实现节流：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle=<span class="function"><span class="keyword">function</span>(<span class="params">func,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args=<span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context,args);</span><br><span class="line">                timer=<span class="literal">null</span>;</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,throttle(handle,<span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>节流也是通过<strong>闭包</strong>实现的。所以会把timer缓存起来，但是由于每次执行<code>setTimeout</code>函数时都设置timer为null，所以每次调用都可以执行if语句当中的内容。同时，下一次滚动事件不会影响上一次的事件处理函数，所以不会重新计时。</p>
<p>将节流代码放入上个例子的具体实现中会发现，执行滚动页面操作后，都会以同一频率在控制台中输出值。</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Decorator用法与实践</title>
    <url>/2020/12/01/Decorator%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>今天看关注的公众号发了一篇关于Decorator在组件当中的应用，觉得比较新颖，因为之前看过的文章都是在类和类的方法里应用的。所以想趁此契机梳理一下Decorator知识。</p>
<p>Decorator特性可能在将来会发生改变，需等到定案之后再对其内容进行更新。</p>
</blockquote>
<br>

<h1 id="什么是Decorator装饰器"><a href="#什么是Decorator装饰器" class="headerlink" title="什么是Decorator装饰器"></a>什么是Decorator装饰器</h1><p>装饰器（<code>Decorator</code>）是一种与类（class）相关的语法，用来注释或修改类和类的方法。它体现了一种<strong>控制反转</strong>的设计思想，可以用来降低代码之间的耦合度，也称作<strong>依赖注入</strong>（常见的控制反转方法）。</p>
<p>装饰器是一种函数，写成<code>@+函数名</code>。它可以放在类和类方法定义的前面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@frozen</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    @configurable(<span class="literal">false</span>)</span><br><span class="line">    @enumerable(<span class="literal">true</span>)</span><br><span class="line">    method() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @throttle(<span class="number">500</span>)</span><br><span class="line">    expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中使用了四个装饰器，一个用在类本身，另外三个用在类方法。这是一种方便的手段来增加或修改类的功能。</p>
<br>

<h1 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">	target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>@testable</code>就是一个装饰器，它修改了<code>MyTestableClass</code>这个类的的行为，为它添加了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>就是<code>MyTestableClass</code>类本身。</p>
<p>装饰器函数的第一个参数就是所要修饰的目标类。如果觉得一个参数不够用，可以在装饰器外面再封装一层函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：装饰器对类的行为的改变，是代码编译时发生的，而不是运行时。</p>
</blockquote>
<p>前面的例子只是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">	target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">'name'</span>, descriptor);</span><br></pre></td></tr></table></figure>

<ul>
<li>装饰器第一个参数是类的原型对象，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况<code>target</code>参数指的是类本身）</li>
<li>第二个参数是所要装饰的属性名</li>
<li>第三个参数是该属性的描述对象</li>
</ul>
<p><code>@log</code>装饰器，可以起到输出日志的作用（这个常常会使用到）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>



<p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'evaluated'</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'executed'</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    @dec(<span class="number">1</span>)</span><br><span class="line">    @dec(<span class="number">2</span>)</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="装饰器不能用于函数"><a href="#装饰器不能用于函数" class="headerlink" title="装饰器不能用于函数"></a>装饰器不能用于函数</h1><p>装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0。因为函数提升，使得实际执行的代码是下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h1><p>在装饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是对象继承的一种替代方案，意在为一个对象之中混入另外一个对象的方法。</p>
<p>一般是通过<code>Object.assign</code>方法实现。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面这个装饰器，为类”混入”各种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">'./mixins'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123; <span class="built_in">console</span>.log(<span class="string">'foo'</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="如何体现依赖注入"><a href="#如何体现依赖注入" class="headerlink" title="如何体现依赖注入"></a>如何体现依赖注入</h1><p>我们从代码中可以发现，如果我们想要为某个类添加一些方法，只需要在类的前面添加一个装饰器即可。在没有装饰器之前我们一般会怎么做呢？我们会定义一个抽象类，在其中定义继承这个抽象类的所有类共有的一些方法，这样的话子类和子类之间的耦合度会比较高。那装饰器这种模式就可以降低类与类之间的耦合度。</p>
<br>

<h1 id="Decorator装饰器在前端组件中的应用"><a href="#Decorator装饰器在前端组件中的应用" class="headerlink" title="Decorator装饰器在前端组件中的应用"></a>Decorator装饰器在前端组件中的应用</h1><p><code>Decorator</code>（装饰器模式）属于结构型模式，是一种拓展对象额外功能的设计模式，别名<code>wrapper</code>。</p>
<blockquote>
<p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，<code>Decorator</code>模式相比生成子类更加灵活。</p>
</blockquote>
<p><code>wrapper</code>经常在前端搭建场景中遇到，当搭建平台加载一个组件时，希望拓展其基础能力，一般会使用<code>wrapper</code>层对组件进行嵌套，<code>wrapper</code>层就是在不改变<code>API</code>的情况下，对第三方组件进行加强。</p>
<p>不同于继承，组合可以在运行时进行，所以称之为“动态添加”，这里的“额外职责”泛指一切功能，比如在按钮点击时进行一些<code>log</code>日志的打印，在绘制<code>text</code>文本框时，额外绘制一个滚动条和边框等等。</p>
<p>“就增加功能来说，<code>Decorator</code>模式相比生成子类更加灵活” 这句话的含义是，组合比继承更灵活，当可拓展的功能很多时，继承方案会产生大量的子类，而组合可以提前写好处理函数，在需要时动态构造，显然是更灵活的。</p>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201201155903.png" alt></p>
<p><code>ConcreteComponent</code>指的是需要被装饰的组件，可以看到，装饰器<code>Decorator</code>与他都继承同一个类，这样能保证<code>API</code>的一致，才保证无论装饰多少层，始终符合<code>Component</code>类型。</p>
<p>装饰器如果有多种，就要将<code>Decorator</code>申明为抽象类，<code>ConcreteDecoratorA</code>、<code>ConcreteDecoratorB</code>分别实现它们，如果只有一种装饰器，可以退化到<code>Decorator</code>自身就是一种实现。</p>
<h2 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    public onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    private _component</span><br><span class="line">    <span class="keyword">constructor</span>(component) &#123;</span><br><span class="line">        <span class="keyword">this</span>._component = component</span><br><span class="line">    &#125;</span><br><span class="line">    public onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        log(<span class="string">'打点'</span>)</span><br><span class="line">        <span class="keyword">this</span>._component.onClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> component = <span class="keyword">new</span> Component()</span><br><span class="line"><span class="comment">// 一个普通的点击</span></span><br><span class="line">component.onClick()</span><br><span class="line"><span class="keyword">const</span> wrapperComponent = <span class="keyword">new</span> Decorator(component)</span><br><span class="line"><span class="comment">// 一个具有打点功能的点击</span></span><br><span class="line">wrapperComponent.onClick()</span><br></pre></td></tr></table></figure>

<p>其实方法很简单，通过组合，我们得到一个能力更强的组件，而实现方式就是利用构造函数保存组件实例，并在复写函数时，增加一些增强实现。</p>
<h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>装饰器的问题也是组合的问题，过多的组合会导致：</p>
<ul>
<li>组合过程的复杂，要生成过多的对象</li>
<li>包装器层次增多，会增加调试成本，我们比较难追溯到一个bug是在哪一层包装导致的</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>装饰器模式是非常常用的模式，<code>Decorator</code>是一个透明的包装，只要保证包装的透明性，就可以最大限度发挥装饰器模式的优势。</p>
<p>最后总结一个装饰器应用图：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201201161148.png" alt></p>
<br>

<h1 id="关于兼容性"><a href="#关于兼容性" class="headerlink" title="关于兼容性"></a>关于兼容性</h1><p>由于是es7的新特性，需要配置babel才能支持装饰器。</p>
<p>配置方法：</p>
<ul>
<li><p><code>babel</code>：7.X版本</p>
</li>
<li><p>依赖安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-proposal-decorators </span><br><span class="line">npm install --save-dev @babel/plugin-proposal-<span class="class"><span class="keyword">class</span>-<span class="title">properties</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置（一般在<code>.babelrc</code>或<code>babel.config.js</code>中进行配置）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123; <span class="string">"loose"</span> : <span class="literal">true</span> &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>异步以及异步编程解决方案</title>
    <url>/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>所谓”异步”，简单说就是一个任务<strong>不是连续完成的</strong>，可以理解成该<strong>任务被人为分成两段</strong>，<strong>先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</strong>。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	XXX;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"XXX"</span>);</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。<code>setTimeout</code>是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行<code>setTimeout</code>任务的第二部分，执行XXX。</p>
<p>如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。</p>
<br>



<h2 id="异步编程方案"><a href="#异步编程方案" class="headerlink" title="异步编程方案"></a>异步编程方案</h2><p>异步编程也有多种解决方案，其演变过程是：回调函数—》<code>Promise</code>—》<code>Generator</code>—》<code>async/await</code>，每个演变都解决了之前的一些痛点。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。<code>callback</code>的意思就是“重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<p>也就是说在执行<code>readFile</code>的时候，执行权交给了主线程执行栈的同步任务，同步任务执行完毕后才会执行这个<code>readFile</code>的回调。</p>
<h3 id="回调函数的缺点"><a href="#回调函数的缺点" class="headerlink" title="回调函数的缺点"></a>回调函数的缺点</h3><p>回调函数会导致回调地狱。</p>
<p>比如现在有多个异步任务，且任务有依赖关系（一个任务需要拿到另一个任务成功后的结果才能开始执行）的时候，回调的方式写出来的代码就会像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getData1(<span class="function"><span class="params">data1</span> =&gt;</span> &#123;</span><br><span class="line">  getData2(data1, data2 =&gt; &#123;</span><br><span class="line">    getData3(data2, data3 =&gt; &#123;</span><br><span class="line">      getData4(data3, data4 =&gt; &#123;</span><br><span class="line">        getData5(data4, data5 =&gt; &#123;</span><br><span class="line">          <span class="comment">// 终于取到data5了</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种多层嵌套的结构就是回调地狱，这种情况下代码的可读性很差。</p>
<br>



<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h2><p>因此就出现了<code>Promise</code>。<code>Promise</code>的关键点就是将回调函数的嵌套改为了链式调用。</p>
<p>我们使用<code>new Promise</code>去创建一个<code>Promise</code>实例，这个<code>Promise</code>实例会传入一个函数作为参数，函数又有两个函数作为参数，分别是：<code>resolve</code>、<code>reject</code>。</p>
<p>执行<code>resolve</code>函数，<code>Promise</code>实例的状态会变为<code>fulfilled</code>，后续就会去执行<code>.then</code>回调函数</p>
<p>执行<code>reject</code>函数，<code>Promise</code>实例的状态会变为<code>rejected</code>，后续就会去执行<code>.catch</code>回调函数，或者<code>.then</code>的第二个回调函数。</p>
<h3 id="3种状态"><a href="#3种状态" class="headerlink" title="3种状态"></a>3种状态</h3><p>Promise实例有三种状态：</p>
<ul>
<li>pending（进行中）</li>
<li>fulfilled（已成功）</li>
<li>rejected（已失败）</li>
</ul>
<p>fulfilled和rejected有可以说是已成功和已失败，这两种状态又归为已完成状态</p>
<h3 id="resolve和reject"><a href="#resolve和reject" class="headerlink" title="resolve和reject"></a>resolve和reject</h3><p>调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调。<strong>resolve和reject两种函数只会执行一种，执行了其中一个之后就不会执行另一个了。</strong></p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//做一些事情</span></span><br><span class="line">    <span class="comment">//然后在某些条件下resolve，或者reject（以下代码）</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* 条件随便写 */</span>)&#123;</span><br><span class="line">       	 resolve()</span><br><span class="line">     &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         reject()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//如果p的状态被resolve了，就进入这里</span></span><br><span class="line">&#125;,()=&gt;&#123;</span><br><span class="line">    <span class="comment">//如果p的状态被reject</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>简单来说，这种<code>.then.then.then</code>的编码方式，就是<code>Promise</code>。</p>
<p>它的异步体现在，<code>new Promise</code>部分是立即执行的，那执行完毕后，就会将执行权交给主线程执行栈的同步任务，同步任务执行完毕后才会去执行<code>.then</code>回调。这里涉及<code>JavaScript</code>事件执行机制<code>Eventloop</code>。</p>
<h4 id="Promise实现多任务顺序执行"><a href="#Promise实现多任务顺序执行" class="headerlink" title="Promise实现多任务顺序执行"></a><code>Promise</code>实现多任务顺序执行</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		resolve(<span class="string">"one"</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resolve(<span class="string">"two"</span>);</span><br><span class="line">		&#125;,<span class="number">3000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>需要注意的是：每个<code>.then</code>中要返回一个<code>new Promise</code>对象，把任务放在<code>Promise</code>中，后续才能继续使用<code>.then</code>去执行后续操作。</p>
<h4 id="Promise实现多任务并行（即A、B任务都执行完毕了才能执行C任务）："><a href="#Promise实现多任务并行（即A、B任务都执行完毕了才能执行C任务）：" class="headerlink" title="Promise实现多任务并行（即A、B任务都执行完毕了才能执行C任务）："></a><code>Promise</code>实现多任务并行（即A、B任务都执行完毕了才能执行C任务）：</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'hi'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p=<span class="built_in">Promise</span>.all([p1,p2]);</span><br><span class="line">p.then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result));</span><br></pre></td></tr></table></figure>

<p>这里主要用到<code>Promise.all</code>这种结构。<code>Promise.all([p1,p2])</code>接受一个数组作为参数，数组的元素都是<code>Promise</code>实例，只有当数组中所有<code>Promise</code>实例的状态都变为<code>fulfilled</code>的时候，这个<code>Promise.all</code>的实例才会变为<code>fulfilled</code>，才能执行后续的<code>.then</code>操作。</p>
<p>和<code>Promise.all</code>相关的还有<code>Promise.race</code>，那<code>Promise.race</code>实例的状态是等于其参数中第一个执行完毕的<code>Promise</code>实例的状态，它有可能是<code>rejected</code>，也有可能是<code>fulfilled</code>。</p>
<h3 id="Promise的缺点"><a href="#Promise的缺点" class="headerlink" title="Promise的缺点"></a><code>Promise</code>的缺点</h3><p><strong>Promise的最大问题是代码冗余</strong>：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p>
<br>



<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a><code>Generator</code></h2><p><code>Generator</code> 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>,<code>Generator</code>就能够解决上述<code>Promise</code>代码冗余的问题。它能够以一种类似同步的写法来执行一些异步操作。</p>
<ul>
<li>形式上<code>Generator</code>函数是一个普通函数，有两个特征：1）<code>function</code>关键字与函数名之间有个星号； 2）函数内部使用<code>yield</code>表达式，定义不同的内部状态</li>
<li>执行<code>Generator</code>函数会返回一个<strong>遍历器对象</strong></li>
<li>调用<code>Generator</code>函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象</li>
<li>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态，输出返回的结果</li>
</ul>
<h3 id="Generator函数的写法"><a href="#Generator函数的写法" class="headerlink" title="Generator函数的写法"></a><code>Generator</code>函数的写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="异步应用"><a href="#异步应用" class="headerlink" title="异步应用"></a>异步应用</h3><p>因为<code>yield</code>能够中断执行代码的特性，可以帮助我们来<strong>控制异步代码的执行顺序</strong>。</p>
<p>例如有两个异步的函数 <code>A</code> 和 <code>B</code>, 并且 <code>B</code> 的参数是 <code>A</code> 的返回值，也就是说，如果 <code>A</code> 没有执行结束，我们不能执行 <code>B</code>。</p>
<p>那这时候我们写一段伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">effect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; param &#125; = <span class="keyword">yield</span> A();</span><br><span class="line">  <span class="keyword">const</span> &#123; result &#125; = <span class="keyword">yield</span> B(param);</span><br><span class="line">  <span class="built_in">console</span>.table(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们如果需要得到 <code>result</code> 那么我们就需要:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = effect()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>

<p><code>co</code>库可以用来每次执行<code>A()/b()</code>的请求结束之后，都会自动执行<code>next()</code>方法。</p>
<h4 id="使用Generator去实现Promise的任务顺序执行："><a href="#使用Generator去实现Promise的任务顺序执行：" class="headerlink" title="使用Generator去实现Promise的任务顺序执行："></a>使用<code>Generator</code>去实现<code>Promise</code>的任务顺序执行：</h4><p>我们再回顾一下<code>Promise</code>版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		resolve(<span class="string">"one"</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resolve(<span class="string">"two"</span>);</span><br><span class="line">		&#125;,<span class="number">3000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><code>Generator</code>版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    g.next(<span class="string">"one"</span>);  <span class="comment">//将参数传给data1</span></span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">data1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"接收到了"</span> + data1);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      g.next(<span class="string">"two"</span>);  <span class="comment">//将参数传给data2</span></span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">mygenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data1 = <span class="keyword">yield</span> f1();</span><br><span class="line">  <span class="keyword">var</span> data2=<span class="keyword">yield</span> f2(data1);</span><br><span class="line">  <span class="built_in">console</span>.log(data2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = mygenerator();</span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure>

<p>看起来就很像同步操作。</p>
<p>这里需要注意的是：执行<code>yield f1()</code>的时候是不会将返回的结果返回给<code>data1</code>的。next方法可以接受参数，这是向 Generator 函数体内输入数据。 第二个next的时候传入参数，就能被变量<code>data1</code>就能够接收到。</p>
<p>而且不能在<code>f1</code>中直接调用<code>g.next()</code>，要在异步函数内调用（这里还不是很懂为什么…）。</p>
<p>执行顺序如下：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200402090134.png" alt></p>
<p>再看个栗子理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">G</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">100</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>, a)  <span class="comment">// a aaa</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="number">200</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>, b)  <span class="comment">// b bbb</span></span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="number">300</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>, c)  <span class="comment">// c ccc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = G()</span><br><span class="line">g.next()    <span class="comment">// value: 100, done: false</span></span><br><span class="line">g.next(<span class="string">'aaa'</span>) <span class="comment">// a aaa   value: 200, done: false   </span></span><br><span class="line">g.next(<span class="string">'bbb'</span>) <span class="comment">//   b bbb  value: 300, done: false</span></span><br><span class="line">g.next(<span class="string">'ccc'</span>) <span class="comment">//c ccc  value: undefined, done: true</span></span><br></pre></td></tr></table></figure>





<h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>使用<code>try...catch</code>。</p>
<br>



<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a><code>async</code>和<code>await</code></h2><p><code>async</code>函数就是<code>Generator</code>的语法糖。</p>
<p><strong>形式上的不同</strong>：</p>
<ul>
<li><code>async</code>函数将<code>Generator</code>函数的星号（*）替换成<code>async</code></li>
<li>将<code>yield</code>替换成<code>await</code></li>
</ul>
<p><strong><code>async</code></strong>函数对<code>Generator</code>函数的改进体现在以下3点：</p>
<ol>
<li><p>内置执行器</p>
<p>也就是说<code>async</code>函数的执行，和普通函数一样，只需要一行就可以。不用像<code>Generator</code>函数需要调用<code>next</code>方法才能真正执行。</p>
<p>例如对于一个<code>async</code>函数来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用时只需要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>更好的语义</p>
<p><code>async</code>和<code>await</code>比起星号和<code>yield</code>，语义更加清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
</li>
</ol>
<ol start="3">
<li><p>返回值是<code>Promise</code></p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
</li>
</ol>
<h3 id="async函数基本用法"><a href="#async函数基本用法" class="headerlink" title="async函数基本用法"></a><code>async</code>函数基本用法</h3><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>先执行了第一个<code>await</code>后的<code>getStockSymbol(name)</code>函数；得到了股票的名称<code>symbol</code>后，将<code>symbol</code>传给第二个<code>await</code>后面的<code>getStockPrice(symbol)</code>作为参数；最后返回股票价格<code>stockPrice</code>。</p>
<h3 id="async-await错误处理"><a href="#async-await错误处理" class="headerlink" title="async/await错误处理"></a><code>async</code>/<code>await</code>错误处理</h3><p><strong><code>try/catch</code></strong></p>
<p>使用try将await语句包含起来，如果await后的语句执行错误，则错误会被catch捕获：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Oops!"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        error.message; <span class="comment">// "Oops!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/image-20200304144402470.png" alt></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"foo"</span>);</span><br><span class="line">        v.thisWillThrow;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">// "TypeError: Cannot read property 'thisWillThrow' of null"</span></span><br><span class="line">        error.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://blog.fundebug.com/2019/07/24/async-await-error-handling-in-js/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/07/24/async-await-error-handling-in-js/</a></p>
<p>​            <a href="https://segmentfault.com/a/1190000012767617" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012767617</a></p>
<h3 id="执行顺序问题"><a href="#执行顺序问题" class="headerlink" title="执行顺序问题"></a>执行顺序问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<p>当<code>async</code>函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了<code>async</code>函数体。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>

<p>执行顺序为：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/image-20200303155340258.png" alt></p>
<p>执行async1的时候遇到await先去执行async2，然后跳出了函数体，去执行后续的代码，然后再回到当前async1函数当中执行await后续语句。</p>
<br>

<br>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node——事件循环</title>
    <url>/2020/04/07/Node%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>异步IO是指操作系统提供的IO（数据进出）能力，比如键盘输入，对应到显示器上会有专门的数据输出接口，这就是我们生活中可见的IO能力；这个接口在向下会进入到操作系统这个层面，在操作系统中，会提供诸多的能力，比如：磁盘的读写，DNS的查询，数据库的连接啊，网络请求的处理，等等。</p>
<p>在不同的操作系统层面，表现的不一致。有的是异步非阻塞的；有的是同步的阻塞的，无论如何，我们都可以看做是上层应用于下层系统之间的数据交互；上层依赖于下层，但是反过来，上层也可以对下层提供的这些能力进行改造。<strong>如果这种操作是异步的，非阻塞的，那么这种就是异步非阻塞的异步IO模型</strong>；<strong>如果是同步的阻塞的，那么就是同步IO模型</strong>。</p>
<p><code>koa</code>就是一个上层的web服务框架，全部由JavaScript实现，他有操作系统之间的交互，全部通过<code>nodejs</code>来实现；如<code>nodejs</code>的 <code>readFile</code>就是一个异步非阻塞的接口，<code>readFileSync</code>就是一个同步阻塞接口。</p>
<br>



<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环是指<code>Node.js</code>执行非阻塞I/O操作，尽管JavaScript是单线程的,但由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行。</p>
<p><code>Node.js</code>是单线程执行的，同时它又是基于<strong>事件驱动</strong>和<strong>非阻塞IO</strong>编程模型。这就使得我们不用等待异步操作结果返回，就可以继续往下执行代码。当异步事件触发之后，就会通知主线程，主线程执行相应事件的回调。</p>
<br>



<h2 id="Node-js架构分析"><a href="#Node-js架构分析" class="headerlink" title="Node.js架构分析"></a>Node.js架构分析</h2><p>说道 Nodejs 架构, 首先要知道<code>Nodejs</code> 与 <code>V8</code> 和 <code>libUV</code> 的关系和作用:</p>
<ul>
<li><strong>V8:</strong> 执行 JS 的引擎. 也就是翻译 JS. 包括我们熟悉的编译优化, 垃圾回收等等.</li>
<li><strong><code>libUV</code>:</strong> 提供 <code>async I/O</code>, 提供消息循环. 可见, 是操作系统 API 层的一个抽象层.</li>
</ul>
<blockquote>
<p>JavaScript引擎是一种专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器中。</p>
<p>V8：是Google开发的JavaScript引擎，用于Google Chrome和Chromium。V8能够即时编译JavaScript，使得JavaScript代码能够高效运行。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407092819.png" alt></p>
<p>以往我们在执行c++的时候，会先进行编译工作，变为可执行文件后，再执行这个可执行文件。这个编译工作是由编译器完成的。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407092540.png" alt></p>
<p>解释器就提供了一种边编译边运行的动态运行方法，而也正因为通过解释器运行的代码是边编译边运行的，所以运行的速度比静态编译的那种慢很多。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407092653.png" alt></p>
<p>所以程序运行的方式分为<strong>静态编译</strong>和<strong>动态编译</strong>。</p>
</blockquote>
<p>回到<code>Node.js</code>架构，<code>Node.js</code>如何组织它们呢？</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407092915.png" alt></p>
<p><code>Node.js</code>通过一层C++ Binding，把JavaScript传给V8，V8解析后交给<code>libUV</code>发起异步IO，并等待消息循环调度。所以，<code>Node.js</code>实现异步机制的核心便是<code>libUV</code>。</p>
<p><code>Node.js</code>启动过程可以分为以下步骤：</p>
<p>1、调用platformInit方法 ，初始化 nodejs 的运行环境。</p>
<p>2、调用 performance_node_start 方法，对 nodejs 进行性能统计。</p>
<p>3、openssl设置的判断。</p>
<p>4、调用v8_platform.Initialize，初始化 libuv 线程池。</p>
<p>5、调用 V8::Initialize，初始化 V8 环境。</p>
<p>6、创建一个nodejs运行实例。</p>
<p>7、启动上一步创建好的实例。</p>
<p>8、开始执行js文件，同步代码执行完毕后，进入事件循环。</p>
<p>9、在没有任何可监听的事件时，销毁 nodejs 实例，程序执行完毕。</p>
<p>以上是<code>Node.js</code>执行一个<code>JavaScript</code>文件的全过程，事件循环是在第八个步骤中。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407093630.png" alt></p>
<p>Nodejs 完全是单线程的. 从进程启动后, 由主线程加载我们的 js 文件(下图中 main.js), 然后进入消息循环. 可见对于 js 程序而言, 完整运行在单线程之中。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407093708.png" alt></p>
<h2 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h2><p><code>Node.js</code>中事件循环分为6个阶段：</p>
<ul>
<li><code>timers</code>：执行<code>setTimeout()</code> 和 <code>setInterval()</code>中到期的回调。</li>
<li><code>I/O callbacks</code>：上一轮循环中有少数的<code>I/Ocallback</code>会被延迟到这一轮的这一阶段执行</li>
<li><code>idle, prepare</code>：仅内部使用</li>
<li><code>poll</code>：最为重要的阶段，执行I/O 回调，在适当的条件下会阻塞在这个阶段</li>
<li><code>check</code>：执行<code>setImmediate</code>的回调</li>
<li><code>close callbacks</code>：执行close事件的回调，例如<code>socket.on(&quot;close&quot;,func)</code></li>
</ul>
<blockquote>
<p>重点关注<code>timers</code>、<code>poll</code>、<code>check</code>三个阶段</p>
</blockquote>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200407093930.png" style="zoom: 50%;">



<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ul>
<li><p><code>node</code>的初始化</p>
<ul>
<li>初始化node环境</li>
<li>执行同步任务（例如<code>console.log</code>）</li>
<li>执行<code>process.nextTick</code>回调</li>
<li>执行<code>microtasks</code>（<code>Promise.then</code>）</li>
</ul>
</li>
<li><p>进入<code>event-loop</code></p>
<ol>
<li><p>进入<code>timers</code>阶段</p>
<ul>
<li>检查timer队列是否有到期的timer回调，如果有，将到期的timer回调按照<code>timerID</code>升序执行</li>
<li>检查是否有<code>process.nextTick</code>任务，如果有，全部执行</li>
<li>检查是否有<code>microtask</code>，如果有，全部执行</li>
<li>退出该阶段</li>
</ul>
</li>
<li><p>进入<code>IO callback</code>阶段</p>
<ul>
<li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段。</li>
<li>检查是否有 <code>process.nextTick</code> 任务，如果有，全部执行。</li>
<li>检查是否有microtask，如果有，全部执行。</li>
<li>退出该阶段。</li>
</ul>
</li>
<li><p>进入<code>idle</code>、<code>prepare</code>阶段：</p>
<p>这两个阶段与我们编程关系不大，暂且按下不表。</p>
</li>
<li><p>进入<code>poll</code>阶段</p>
<p>首先检查是否存在尚未完成的回调，如果存在，分两种情况：</p>
<ul>
<li><p>如果有可用回调（可用回调包含：<strong>到期的定时器</strong>、一些<strong>IO事件</strong>等），执行所有可用回调。</p>
<ul>
<li><p>检查是否有<code>process.nextTick</code>回调，如果有，全部执行</p>
</li>
<li><p>检查是否有 <code>microtaks</code>，如果有，全部执行。</p>
</li>
<li><p>退出该阶段。</p>
</li>
</ul>
</li>
<li><p>如果没有可用回调</p>
<ul>
<li>检查是否有<code>setImmediate</code>回调，如果有，退出<code>poll</code>阶段。如果没有，阻塞在此阶段，等待新的事件通知。</li>
<li>如果不存在尚未完成的回调，退出<code>poll</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>进入<code>check</code>阶段</p>
<ul>
<li>如果有immediate回调，则执行所有immediate回调。</li>
<li>检查是否有 process.nextTick 回调，如果有，全部执行。</li>
<li>检查是否有 microtaks，如果有，全部执行。</li>
<li>退出 check 阶段</li>
</ul>
</li>
<li><p>进入<code>closing</code>阶段</p>
<ul>
<li>如果有immediate回调，则执行所有immediate回调。</li>
<li>检查是否有 process.nextTick 回调，如果有，全部执行。</li>
<li>检查是否有 microtaks，如果有，全部执行。</li>
<li>退出 closing 阶段</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>在事件循环的每个子阶段退出之前都会按顺序执行如下过程：</p>
<ul>
<li>检查是否有 process.nextTick 回调，如果有，全部执行。</li>
<li>检查是否有 microtaks，如果有，全部执行。</li>
<li>退出当前阶段。</li>
</ul>
</blockquote>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="process-nextTick和Promise"><a href="#process-nextTick和Promise" class="headerlink" title="process.nextTick和Promise"></a><code>process.nextTick</code>和<code>Promise</code></h3><p>这个队列先保证所有的 <code>process.nextTick</code> 回调, 然后将所有的 <code>Promise</code> 回调追加在后面. 最终在每个 Phase 结束的时候一次性拿出来执行。</p>
<h3 id="setTimeout-0-vs-setImmediate-到底谁快"><a href="#setTimeout-0-vs-setImmediate-到底谁快" class="headerlink" title="setTimeout(..., 0)vs. setImmediate 到底谁快?"></a><code>setTimeout(..., 0)</code>vs. <code>setImmediate</code> 到底谁快?</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>答案：可能是1 2，也可能是2 1。</p>
<p>首先我们在初始化阶段会将<code>setImmediate</code>添加到<code>check phase</code>中，将<code>setTimeout</code>添加到<code>timer phase</code>中。</p>
<ul>
<li>如果进入<code>timer phase</code>的时间 &gt; 消息循环保存的时间（即将以上两个回调添加到它们各自的<code>phase</code>的时间）<ul>
<li>那在进入<code>timer phase</code>的时候<code>setTimeout</code>的回调已经在里面了，就可以立即执行，然后到<code>check phase</code>的时候再执行<code>setImmediate</code>的回调。此时输出1 2。</li>
</ul>
</li>
<li>如果进入<code>timer phase</code>的时间 &lt; 消息循环保存的时间（即将以上两个回调添加到它们各自的<code>phase</code>的时间）<ul>
<li>那在进入<code>timer phase</code>的时候<code>setTimeout</code>的回调还不在里面，那就会先执行<code>check phase</code>中的<code>setImmediate</code>，然后在下一轮循环中再执行<code>timer phase</code>中的<code>setTimeout</code>。此时输出2 1。</li>
</ul>
</li>
</ul>
<p>如果把代码改为如下，则一定会得到稳定输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(<span class="string">'my-file-path.txt'</span>, () =&gt; &#123;</span><br><span class="line"> setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<p>因为消息在<code>poll phase</code>才会将<code>setImmediate</code>进入<code>check phase</code>，将<code>setTimeout</code>进入<code>timer phase</code>，那<code>poll</code>阶段后就回到<code>check</code>阶段，所以会输出2 1。</p>
<h3 id="判断输出顺序"><a href="#判断输出顺序" class="headerlink" title="判断输出顺序"></a>判断输出顺序</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate1'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setImmediate2'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//then setTimeout2  nextTick  setImmediate1 setImmediate2 setTimeout1</span></span><br></pre></td></tr></table></figure>



<p><code>step1</code>：初始化阶段</p>
<ul>
<li><code>setImmediate</code>进入<code>check phase</code>、<code>Promise.resolve().then</code>进入微任务<code>event queue</code>、<code>setTimeout</code>进入<code>timer phase</code>。</li>
<li>没有<code>process.nextTick</code></li>
<li>执行<code>microtask</code>，输出<code>then</code></li>
<li>结束该阶段</li>
</ul>
<p><code>step2</code>：进入<code>Timer phase</code>（或者<code>poll phase</code>？）</p>
<ul>
<li>执行<code>setTimeout</code></li>
<li>执行<code>console.log(&#39;setTimeout2&#39;)</code>，输出<code>setTimeout2</code></li>
<li><code>setImmediate</code>进入<code>check phase</code></li>
<li>有<code>process.nextTick</code>，输出<code>nextTick</code></li>
</ul>
<p><code>step3</code>：进入<code>check phase</code></p>
<ul>
<li>执行第一个<code>setImmediate</code>，输出<code>setImmediate1</code>，将<code>setTimeout</code>进入<code>Timer phase</code></li>
<li>执行第二个<code>setImmediate</code>，输出<code>setImmediate2</code></li>
</ul>
<p><code>step4</code>：下一个循环，进入<code>Timer phase</code></p>
<ul>
<li>执行<code>setTimeout</code>，输出<code>setTimeout1</code></li>
</ul>
<br>

<p>参考：</p>
<p><a href="https://juejin.im/post/5b61d8e3e51d45191d7a28a8" target="_blank" rel="noopener">https://juejin.im/post/5b61d8e3e51d45191d7a28a8</a></p>
<p><a href="https://www.jianshu.com/p/906eafb41ea6" target="_blank" rel="noopener">https://www.jianshu.com/p/906eafb41ea6</a></p>
<br>

]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node——Connect和Express</title>
    <url>/2020/04/05/Node%E2%80%94%E2%80%94Connect%E5%92%8CExpress/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Connect</code>和<code>Express</code>是两个热门的Node模块。<code>Express</code>就是在<code>Connect</code>的基础上，通过添加高层糖衣扩展和搭建出来的。</p>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><h3 id="创建简单的Connect程序"><a href="#创建简单的Connect程序" class="headerlink" title="创建简单的Connect程序"></a>创建简单的<code>Connect</code>程序</h3><p>指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install connect@3.4.0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在要安装的模块后加@可以指定版本号</p>
</blockquote>
<p>简单的<code>Connect</code>程序应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app&#x3D;require(&#39;connect&#39;)();</span><br><span class="line">app.use((req,res,next)&#x3D;&gt;&#123;</span><br><span class="line">	res.end(&#39;Hello, world!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<p>这个程序会用Hello, World!做出响应。也就是访问<code>http://localhost:3000</code>的时候，页面显示<code>Hello, world!</code>。传给<code>app.use</code>的函数是个中间件，它以文本<code>Hello, world!</code>作为响应结束了请求处理过程。中间件是所有<code>Connect</code>和<code>Express</code>程序的基础。</p>
<h3 id="Connect中间件的工作机制"><a href="#Connect中间件的工作机制" class="headerlink" title="Connect中间件的工作机制"></a><code>Connect</code>中间件的工作机制</h3><p><code>Connect</code>中间件就是<code>JavaScript</code>函数。这个函数一般会有三个参数：请求对象、响应对象、以及一个名为next的回调函数。一个中间件完成自己的工作，要执行后续的中间件时，可以调用这个next回调函数。</p>
<p>在中间件运行之前，<code>Connect</code>会用分派器接管请求对象，然后交给程序中的第一个中间件。</p>
<p>借助中间件API，可以把一些小的构件块组合到一起，实现复杂的处理逻辑。</p>
<h3 id="组合中间件"><a href="#组合中间件" class="headerlink" title="组合中间件"></a>组合中间件</h3><p>Connect中的use方法就是用来组合中间件的。我们先来定义两个中间件函数，然后把它们都添加到程序中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> connect=<span class="built_in">require</span>(<span class="string">'connect'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'%s %s'</span>, req.method, req.url);</span><br><span class="line">	next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">	res.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line">connect()</span><br><span class="line">	.use(logger)</span><br><span class="line">	.use(hello)</span><br><span class="line">	.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>这两个中间件的名称签名不一样：一个有next，一个没有。因为后面这个中间件完成了HTTP响应，再也不需要把控制权交还给分派器了。</p>
<p>use()函数返回的是Connect程序的实例，支持方法链。也可以不写成链式调用的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app=connect();</span><br><span class="line">app.use(logger);</span><br><span class="line">app.use(hello);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果某个中间件不调用<code>next()</code>，那链在它后面的中间件就不会被调用。所以如果logger和hello两个函数的调用顺序反过来，则logger是不会执行的。</p>
<h3 id="使用错误处理中间件"><a href="#使用错误处理中间件" class="headerlink" title="使用错误处理中间件"></a>使用错误处理中间件</h3><p><code>Connect</code>中有一种用来处理错误的中间件变体。跟常规的中间件相比，除了请求和响应对象外，错误处理中间件的参数中还多了一个错误对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Connect中的错误处理中间件</span></span><br><span class="line"><span class="keyword">const</span> env=process.env.NODE_ENV||<span class="string">'development'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span>(<span class="params">err,req,res,next</span>)</span>&#123;</span><br><span class="line">	res.statusCode=<span class="number">500</span>;</span><br><span class="line">	<span class="keyword">switch</span>(env)&#123;</span><br><span class="line">        <span class="comment">//开发模式和生产模式的响应不同</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">'development'</span>:</span><br><span class="line">			<span class="built_in">console</span>.error(<span class="string">'Error:'</span>);</span><br><span class="line">			<span class="built_in">console</span>.error(err);</span><br><span class="line">			res.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/json'</span>);</span><br><span class="line">			res.end(<span class="built_in">JSON</span>.stringify(err));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			res.end(<span class="string">'Server error'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports=errorHandler;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开发环境（development）：开发同学开发时使用的环境，每位开发同学在自己的dev分支上工作，开发到一定程度后，各位同学会合并代码，进行联调。</p>
<p>生产环境（production）：线上环境，用户使用的环境。由特定人员来维护。</p>
</blockquote>
<blockquote>
<p>设置环境变量</p>
<p>UNIX系统中设置环境变量的指令：<br>$ NODE_ENV=production node app</p>
<p>Windows中用这个：</p>
<p>$ set NODE_ENV=production</p>
<p>$ node app</p>
</blockquote>
<p>产品在开发环境中运行时，你可能想要看到尽可能详细的日志；但在生产环境中，你可能想让日志尽量精简，可能还要用gzip进行压缩。</p>
<p>用NODE_ENV设定程序的模式，Connect一般会根据环境变量<code>NODE_ENV(process.env.NODE_ENV)</code>来切换不同服务器环境（比如生产环境和开发环境）下的行为。</p>
<p>当<code>Connect</code>遇到错误时，它会切换，只去调用错误处理中间件。</p>
<p>假设有一个允许用户登录到管理区域的博客程序。如果负责用户路由的中间件引发了一个错误，则中间件<code>blog</code>和<code>admin</code>都会被跳过，因为它们不是错误处理中间件（只有三个参数）。然后<code>Connect</code>看到接受错误参数的<code>errorHandler</code>，就会调用它。中间件看起来像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connect()</span><br><span class="line">	.use(router(<span class="built_in">require</span>(<span class="string">'./routes/user'</span>)))</span><br><span class="line">	.use(router(<span class="built_in">require</span>(<span class="string">'./routes/blog'</span>))) <span class="comment">//跳过</span></span><br><span class="line">	.use(router(<span class="built_in">require</span>(<span class="string">'./routes/admin'</span>)))  <span class="comment">//跳过</span></span><br><span class="line">	.use(errorHandler);</span><br></pre></td></tr></table></figure>

<br>



<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p><code>Express</code>是非常流行的<code>Web</code>框架，以前是在<code>Connect</code>的基础上搭建的。尽管提供了一些基本的功能，比如静态文件服务、URL路由和程序配置等，但它依然是极简的Web框架。</p>
<p>简单的<code>Express</code>程序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app=express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res)=&gt;&#123;</span><br><span class="line">	res.send(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>



<h3 id="生成程序框架"><a href="#生成程序框架" class="headerlink" title="生成程序框架"></a>生成程序框架</h3><p>安装指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure>

<p> 生成程序</p>
<p>用<code>-e或（--ejs）</code>指定要使用的模板引擎是EJS（EJS是一个嵌入JavaScript模板引擎，通过编译生成HTML代码）。执行<code>express -e shoutbox</code>，<code>shoutbox</code>是文件名。一个功能完备的程序会出现在<code>shoutbox</code>目录中。其中会有描述项目和依赖项的<code>package.json</code>文件、程序主文件、<code>public</code>目录，以及一个放路由处理器的目录。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200405154932.png" alt></p>
<br>

<h3 id="Express路由入门"><a href="#Express路由入门" class="headerlink" title="Express路由入门"></a>Express路由入门</h3><p>根据官网定义：</p>
<blockquote>
<p><em>Routing</em> refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on).</p>
</blockquote>
<p>路由的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>app</code>是express的一个实例</li>
<li><code>METHOD</code>是<code>HTTP</code>请求方法（小写）</li>
<li><code>PATH</code>是服务器上的路径</li>
<li><code>HANDLER</code>是在这个路径上发起<code>HTTP</code>请求时执行的回调函数</li>
</ul>
<p>Respond with <code>Hello World!</code> on the homepage:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Respond to POST request on the root route (<code>/</code>), the application’s home page:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a POST request'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Respond to a PUT request to the <code>/user</code> route:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.put(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a PUT request at /user'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Respond to a DELETE request to the <code>/user</code> route:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.delete(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a DELETE request at /user'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="做个简单的留言板程序"><a href="#做个简单的留言板程序" class="headerlink" title="做个简单的留言板程序"></a>做个简单的留言板程序</h4><p>效果：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200405150802.png" alt></p>
<p>步骤：</p>
<ul>
<li>创建消息模型</li>
<li>添加与消息相关的路由</li>
<li>创建消息表单</li>
<li>添加业务逻辑，用提交上来的表单数据创建消息</li>
</ul>
<h5 id="创建消息模型"><a href="#创建消息模型" class="headerlink" title="创建消息模型"></a>创建消息模型</h5><p>在创建消息模型之前，需要先安装<code>Node redis</code>模块。执行命令<code>npm install --save redis</code>。而且要安装<code>Redis</code>，Windows系统可以使用<code>Redis Chocolately</code>。</p>
<blockquote>
<p>安装教程：<a href="https://www.cnblogs.com/julyluo/p/6646155.html" target="_blank" rel="noopener">https://www.cnblogs.com/julyluo/p/6646155.html</a></p>
<p>官网没有windows版本，github下载速度太慢。</p>
<p>Redis就是一个数据库，可以将我们post的留言存储起来。</p>
</blockquote>
<ol>
<li><p>创建保存在线留言板消息条目的模型。</p>
<p>创建<code>models/entry.js</code>文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="keyword">const</span> db = redis.createClient();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">this</span>[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getRange(<span class="keyword">from</span>, to, cb) &#123;</span><br><span class="line">    db.lrange(<span class="string">'entries'</span>, <span class="keyword">from</span>, to, (err, items) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">      <span class="keyword">let</span> entries = [];</span><br><span class="line">      items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        entries.push(<span class="built_in">JSON</span>.parse(item));</span><br><span class="line">      &#125;);</span><br><span class="line">      cb(<span class="literal">null</span>, entries);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  save(cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> entryJSON = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>);</span><br><span class="line">    db.lpush(</span><br><span class="line">      <span class="string">'entries'</span>,</span><br><span class="line">      entryJSON,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);</span><br><span class="line">        cb();</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> count(cb) &#123;</span><br><span class="line">    db.llen(<span class="string">'entries'</span>, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Entry;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>创建消息表单</p>
<p>在<code>app.js</code>中添加如下路由部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/post'</span>, entries.form);</span><br><span class="line">app.post(<span class="string">'/post'</span>, entries.submit);</span><br></pre></td></tr></table></figure>

<p>即：使用get向<code>/post</code>发起http请求时，执行<code>entries.form</code>回调函数。使用post向<code>/post</code>发起http请求时，执行<code>entries.submit</code>回调。</p>
<hr>
这个`entries`是从`routes`中导入的模块。看一下定义：

</li>
</ol>
<p>表单模块部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//routes/entries.js</span></span><br><span class="line">exports.form = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.render(<span class="string">'post'</span>, &#123; <span class="attr">title</span>: <span class="string">'Post'</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里是用<code>views/post.ejs</code>，即表单，去渲染页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;views&#x2F;post.ejs</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;% include menu %&gt; </span><br><span class="line">    &lt;h1&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;Fill in the form below to add a new post.&lt;&#x2F;p&gt; </span><br><span class="line">    &lt;form action&#x3D;&#39;&#x2F;post&#39; method&#x3D;&#39;post&#39;&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;entry[title]&#39; placeholder&#x3D;&#39;Title&#39; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;textarea name&#x3D;&#39;entry[body]&#39; placeholder&#x3D;&#39;Body&#39;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&#39;Post&#39; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>表单中用了形如<code>entry[title]</code>之类的输入控件名称，需要用扩展的消息体解析器来解析。找到<code>app.js</code>将</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;));</span><br></pre></td></tr></table></figure>

<hr>

<ol start="3">
<li><p>实现消息提交功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将代码添加到文件routes/entries.js中，实现用表单提交上来的数据创建消息</span></span><br><span class="line">exports.submit = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = req.body.entry;</span><br><span class="line">  <span class="keyword">const</span> user = res.locals.user;</span><br><span class="line">  <span class="keyword">const</span> username = user ? user.name : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="keyword">new</span> Entry(&#123;</span><br><span class="line">    username: username,</span><br><span class="line">    title: data.title,</span><br><span class="line">    body: data.body</span><br><span class="line">  &#125;);</span><br><span class="line">  entry.save(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">    res.redirect(<span class="string">'/'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用了Common JS进行模块化开发</p>
</blockquote>
<hr>
</li>
<li><p>添加显示消息的首页</p>
<p>在<code>routes/entries.js</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Entry = <span class="built_in">require</span>(<span class="string">'../models/entry'</span>);</span><br><span class="line"></span><br><span class="line">exports.list = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> page = req.page;</span><br><span class="line">  Entry.getRange(<span class="number">0</span>, <span class="number">-1</span>, (err, entries) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</span><br><span class="line">    res.render(<span class="string">'entries'</span>, &#123;</span><br><span class="line">      title: <span class="string">'Entries'</span>,</span><br><span class="line">      entries: entries</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>视图<code>entries.ejs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;% include menu %&gt; </span><br><span class="line">    &lt;% entries.forEach((entry) &#x3D;&gt; &#123; %&gt;</span><br><span class="line">      &lt;div class&#x3D;&#39;entry&#39;&gt;</span><br><span class="line">        &lt;h3&gt;&lt;%&#x3D; entry.title %&gt;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;p&gt;&lt;%&#x3D; entry.body %&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;Posted by &lt;%&#x3D; entry.username %&gt;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;% &#125;) %&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在程序运行之前先在同一目录下创建menu.ejs创建菜单模板文件，后续会用到。目前空白着先。</p>
</blockquote>
<hr>
</li>
<li><p>添加与消息相关的路由</p>
<p>在<code>app.js</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> entries = <span class="built_in">require</span>(<span class="string">'./routes/entries'</span>);</span><br></pre></td></tr></table></figure>

<p>添加路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, entries.list);</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>运行程序</p>
<p>先以管理员身份进入CMD，运行<code>redis-server</code>启用<code>Redis</code>。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200405153803.png" alt></p>
<p>在<code>terminal</code>中运行<code>npm start</code>，访问<code>http://localhost:3000/post</code></p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200405153923.png" alt></p>
<p>点击post后跳转到首页：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/image-20200405153955456.png" alt></p>
</li>
</ol>
<p>完成。</p>
<br>]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>React+Redux 通过axios向接口获取数据的流程</title>
    <url>/2020/04/17/React-Redux-%E9%80%9A%E8%BF%87axios%E5%90%91%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>最近在学习《React Hooks与Immutable数据流实战》小书，想把在React+Redux项目中用axios发起请求的配置流程记录下来，做个总结，加深一些印象。</p>
<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p>首先是将<code>github</code>上网易云音乐接口的<code>node.js</code>项目启动，在项目中都是向这个服务器去发起请求，获取接口数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;启动服务器指令</span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure>

<br>

<h2 id="安装axios"><a href="#安装axios" class="headerlink" title="安装axios"></a>安装<code>axios</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure>



<p>现在在 src/api 目录下新建 config.js 文件，里面编写 axios 的配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseUrl = <span class="string">'http://xxx自己填'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//axios 的实例及拦截器配置</span></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.create (&#123;</span><br><span class="line">  baseURL: baseUrl</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axiosInstance.interceptors.response.use (</span><br><span class="line">  res =&gt; res.data,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log (err, <span class="string">"网络错误"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  axiosInstance</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>baseUrl</code>的话就是服务器的基地址，比如<code>http://localhost:3000</code>，那请求的一些接口数据就会在这个<code>baseUrl</code>的不同路由下，比如<code>banner</code>数据会通过<code>http://localhost:3000/banner</code>接口获取。</p>
</li>
<li><p><code>axios.create</code>：创建一个axios实例，可以添加一些基本配置。</p>
<blockquote>
<p>官网解释：</p>
<h5 id="axios-create-config"><a href="#axios-create-config" class="headerlink" title="axios.create([config])"></a>axios.create([config])</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const instance &#x3D; axios.create(&#123;  </span><br><span class="line">	baseURL: &#39;https:&#x2F;&#x2F;some-domain.com&#x2F;api&#x2F;&#39;,  </span><br><span class="line">	timeout: 1000,  </span><br><span class="line">	headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>axiosInstance.interceptors.response.use</code></p>
<p>用于将公共的业务逻辑抽离出来。</p>
</li>
</ul>
<p>然后在同一个目录下新建 request.js 用来封装不同的网络请求，内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; axiosInstance &#125; <span class="keyword">from</span> <span class="string">"./config"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getBannerRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.get (<span class="string">'/banner'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getRecommendListRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.get (<span class="string">'/personalized'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>request.js</code>中封装一些向服务器发起请求的方法，注意返回的是<code>promise</code>对象。</p>
<br>

<h2 id="redux层开发"><a href="#redux层开发" class="headerlink" title="redux层开发"></a><code>redux</code>层开发</h2><p>在 Recommend 目录下，新建 store 文件夹，然后新建以下文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">actionCreators.js&#x2F;&#x2F; 执行一些request.js中封装好的方法，获取到接口数据，并通过dispatch更新store的内容</span><br><span class="line">constants.js      &#x2F;&#x2F; 常量集合，存放不同 action 的 type 值</span><br><span class="line">index.js          &#x2F;&#x2F; 用来导出 reducer，action</span><br><span class="line">reducer.js        &#x2F;&#x2F; 存放 initialState 和 reducer 函数</span><br></pre></td></tr></table></figure>



<h3 id="constants-js"><a href="#constants-js" class="headerlink" title="constants.js"></a><code>constants.js</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义action类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_BANNER=<span class="string">'recommend/CHANGE_BANNER'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_RECOMMEND_LIST=<span class="string">'recommend/RECOMMEND_LIST'</span>;</span><br></pre></td></tr></table></figure>



<h3 id="reducer-js"><a href="#reducer-js" class="headerlink" title="reducer.js"></a><code>reducer.js</code></h3><p>定义<code>reducer</code>函数，并初始化<code>state</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">'immutable'</span>; <span class="comment">// 这里用到 fromJS 把 JS 数据结构转化成 immutable 数据结构</span></span><br><span class="line"><span class="keyword">import</span> &#123;combineReducer&#125; <span class="keyword">from</span> <span class="string">'redux-immutable'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState=fromJS(&#123;</span><br><span class="line">    bannerList: [],</span><br><span class="line">    recommendList: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义reducer函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state=defaultState, action)=&gt;&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> actionTypes.CHANGE_BANNER:</span><br><span class="line">            <span class="keyword">return</span> state.set(<span class="string">'bannerList'</span>, action.data);</span><br><span class="line">        <span class="keyword">case</span> actionTypes.CHANGE_RECOMMEND_LIST:</span><br><span class="line">            <span class="keyword">return</span> state.set(<span class="string">'recommendList'</span>, action.data);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="actionCreators-js"><a href="#actionCreators-js" class="headerlink" title="actionCreators.js"></a><code>actionCreators.js</code></h3><p>执行<code>request.js</code>中的方法，通过<code>axios</code>从接口获取数据，然后通过<code>dispatch</code>方法，使用获取到的新数据去更新state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;fromJS&#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getBannerRequest, getRecommendListRequest&#125; <span class="keyword">from</span> <span class="string">'../../../api/request'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeBannerList=<span class="function">(<span class="params">data</span>)=&gt;</span>(&#123;</span><br><span class="line">    type: actionTypes.CHANGE_BANNER,</span><br><span class="line">    data: fromJS(data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeRecommendList=<span class="function">(<span class="params">data</span>)=&gt;</span>(&#123;</span><br><span class="line">    type: actionTypes.CHANGE_RECOMMEND_LIST,</span><br><span class="line">    data: fromJS(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getBannerList=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">        getBannerRequest().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//返回的数据格式为：&#123;banners: Array(8), code:200&#125;</span></span><br><span class="line">            dispatch(changeBannerList(data.banners));</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"轮播图数据传输错误"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getRecommendList=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">        getRecommendListRequest().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">            dispatch(changeRecommendList(data.result));</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"推荐歌单数据传输错误"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a><code>index.js</code></h3><p>用于将相关变量导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actionCreators &#125;;</span><br></pre></td></tr></table></figure>



<br>

<h2 id="组件连接Redux"><a href="#组件连接Redux" class="headerlink" title="组件连接Redux"></a>组件连接<code>Redux</code></h2><p>首先，需要将 recommend 下的 reducer 注册到全局 store，在 store/reducer.js 中，内容如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux-immutable'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> recommendReducer &#125; <span class="keyword">from</span> <span class="string">'../application/Recommend/store/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers (&#123;</span><br><span class="line">  recommend: recommendReducer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注册完成！</p>
<p>现在在 Recommend/index.js 中，准备连接 Redux。组件代码更新如下:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Slider <span class="keyword">from</span> <span class="string">'../../components/slider/'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'./store/actionCreators'</span>;</span><br><span class="line"><span class="keyword">import</span> RecommendList <span class="keyword">from</span> <span class="string">'../../components/list/'</span>;</span><br><span class="line"><span class="keyword">import</span> Scroll <span class="keyword">from</span> <span class="string">'../../baseUI/scroll/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Content &#125; <span class="keyword">from</span> <span class="string">'./style'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Recommend</span> (<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; bannerList, recommendList &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; getBannerDataDispatch, getRecommendListDataDispatch &#125; = props;</span><br><span class="line"></span><br><span class="line">  useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    getBannerDataDispatch ();</span><br><span class="line">    getRecommendListDataDispatch ();</span><br><span class="line">    <span class="comment">//eslint-disable-next-line</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> bannerListJS = bannerList ? bannerList.toJS () : [];</span><br><span class="line">  <span class="keyword">const</span> recommendListJS = recommendList ? recommendList.toJS () :[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Content&gt;</span><br><span class="line">      &lt;Scroll&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Slider bannerList=&#123;bannerListJS&#125;&gt;&lt;<span class="regexp">/Slider&gt;</span></span><br><span class="line"><span class="regexp">          &lt;RecommendList recommendList=&#123;recommendListJS&#125;&gt;&lt;/</span>RecommendList&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Scroll&gt;</span><br><span class="line">    &lt;<span class="regexp">/Content&gt; </span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 映射 Redux 全局的 state 到组件的 props 上</span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state) =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 不要在这里将数据 toJS</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 不然每次 diff 比对 props 的时候都是不一样的引用，还是导致不必要的重渲染，属于滥用 immutable</span></span><br><span class="line"><span class="regexp">  bannerList: state.getIn (['recommend', 'bannerList']),</span></span><br><span class="line"><span class="regexp">  recommendList: state.getIn (['recommend', 'recommendList']),</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 映射 dispatch 到 props 上</span></span><br><span class="line"><span class="regexp">const mapDispatchToProps = (dispatch) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    getBannerDataDispatch () &#123;</span></span><br><span class="line"><span class="regexp">      dispatch (actionTypes.getBannerList ());</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    getRecommendListDataDispatch () &#123;</span></span><br><span class="line"><span class="regexp">      dispatch (actionTypes.getRecommendList ());</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 将 ui 组件包装成容器组件</span></span><br><span class="line"><span class="regexp">export default connect (mapStateToProps, mapDispatchToProps)(React.memo (Recommend));</span></span><br></pre></td></tr></table></figure>



<p>通过<code>connect</code>高阶函数，将<code>mapStateToProps</code>、<code>mapDispatchToProps</code>的属性和方法整合起来，传入内嵌组件（<code>Recommend</code>），内嵌组件就可以通过<code>props</code>获取到数据。</p>
<ul>
<li><code>mapStateToProps</code>：获取<code>store</code>中的state，对数据进行初始化操作</li>
<li><code>mapDispatchToProps</code>：声明一些数据更新、数据获取操作</li>
</ul>
<p>在<code>useEffect</code>阶段执行<code>getBannerDataDispatch ();</code> <code>getRecommendListDataDispatch ();</code>操作。<code>useEffect</code>是<code>Hook</code>的API，用于完成副作用操作。它相当于<code>class</code>中的一些声明周期，在特定时期执行响应的操作。此处<code>useEffect</code>的第二个参数为<code>[]</code>，表示只在第一次执行，用来请求异步数据；如果第二个参数不为空数组，比如数组内有一些属性的话，则在这些属性发生变化的时候，<code>useEffect</code>才会执行。</p>
<blockquote>
<p>Hook的API介绍详情：</p>
<p>React官方文档</p>
<p><a href="https://juejin.im/post/5e53d9116fb9a07c9070da44" target="_blank" rel="noopener">https://juejin.im/post/5e53d9116fb9a07c9070da44</a></p>
</blockquote>
<br>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>看到结果：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200417202719.png" alt></p>
<br>

<blockquote>
<p>要注意的点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getBannerList=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">        getBannerRequest().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//返回的数据格式为：&#123;banners: Array(8), code:200&#125;</span></span><br><span class="line">            dispatch(changeBannerList(data.banners));</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"轮播图数据传输错误"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意看接口返回的数据，比如getBannerRequest()获取到的数据是对象，那我们要使用data.banners才能获取到banner的内容，直接data是会出错的。</p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React useEffect Hook的对象 &amp; 数组依赖</title>
    <url>/2021/03/13/React-useEffect-Hook%E7%9A%84%E5%AF%B9%E8%B1%A1-%E6%95%B0%E7%BB%84%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>useEffect</code>可以说是使用<code>React</code> <code>Hook</code>时最常用的hook，可以用于实现一些生命周期操作和对变量的监听。</p>
<p>本文是对<a href="https://www.benmvp.com/blog/object-array-dependencies-react-useEffect-hook/" target="_blank" rel="noopener">Object &amp; array dependencies in the React useEffect Hook</a>的翻译，帮助自己更好地理解<code>useEffect</code>的同时，也希望帮助到大家。</p>
<h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><code>useEffect</code></h1><p><code>useEffect</code>在没有设置第二个参数的时候，会在每次渲染的时候执行其回调：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然而，我们一般很少这么用，因为通常我们并不需要在每次渲染的时候都执行回调，这样会执行不必要次数导致性能下降。</p>
<p><code>useEffect</code>有第二个参数，称为依赖数组，只有当依赖数组内的元素发生变化的时候，才会执行<code>useEffect</code>的回调。这么做就能够优化<code>effect</code>执行的次数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  &#125;, [count]) <span class="comment">// Only re-run the effect if count changes</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种做法在数组元素类型为基本数据类型时可以起到作用。但对于复杂数据类型如：对象，数组和函数来说，<code>React</code>会使用<code>referential equality</code>来对比前后是否有不同。</p>
<p><code>React</code>会检查当前渲染下的这个对象和上一次渲染下的对象的内存地址是否一致。两个对象必须是同一个对象<code>useEffect</code>才会跳过执行<code>effect</code>。所以，即使内容完全相同，内存地址不同的话，<code>useEffect</code>还是会执行<code>effect</code>。</p>
<h2 id="Option-1-依赖于对象属性"><a href="#Option-1-依赖于对象属性" class="headerlink" title="Option 1 - 依赖于对象属性"></a>Option 1 - 依赖于对象属性</h2><p>在这个例子中，当前组件会从<code>props</code>获取一个对象，并在<code>useEffect</code>的依赖数组中使用这个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; team &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team.id).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [team])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理想情况下，<code>props</code>传入的<code>team</code>的内容是一样的话，其内存地址也会相同。但这其实是无法保证的。</p>
<p>所以，为了解决这个问题，我们可以只使用<code>team</code>对象里的一些属性，而不是使用整个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; team &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team.id).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [team.id, team.active])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设<code>team</code>对象中的<code>id</code>和<code>active</code>属性都是基本数据类型，<code>effect</code>就只会在<code>id</code>或者<code>active</code>属性发生变化的时候执行（注意是或，不是且）。</p>
<p><code>team</code>对象如果是在组件内被创建的话也能够起到作用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; id, name, active &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// construct the object from props and/or state</span></span><br><span class="line">  <span class="keyword">const</span> team = &#123; id, name, active &#125;</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team.id).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [team.id, team.active])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，即使<code>team</code>对象在每次渲染过程中都重新被创建，也不会导致<code>effect</code>每次渲染都会执行，因为<code>useEffect</code>只依赖于<code>id</code>和<code>active</code>属性。</p>
<p>需要注意的是，这个方案不适用于依赖元素为数组的情况。</p>
<h2 id="Option2-在内部创建对象"><a href="#Option2-在内部创建对象" class="headerlink" title="Option2 - 在内部创建对象"></a>Option2 - 在内部创建对象</h2><p>在上一个例子中，如果<code>effect</code>不是使用对象里的元素，而是以整个对象作为依赖会发生什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; id, name, active &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// construct the object from props/state</span></span><br><span class="line">  <span class="keyword">const</span> team = &#123; id, name, active &#125;</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [team])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>team</code>对象是在每次渲染下重新创建的，所以<code>useEffect</code>在每次重新渲染时都会执行。</p>
<p>幸运的是，<code>react-hooks/exhaustive-deps</code>ESLint rule提示道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The &#39;team&#39; object makes the dependencies of useEffect Hook</span><br><span class="line">change on every render. To fix this, wrap the initialization</span><br><span class="line">of &#39;team&#39; in its own useMemo() Hook.</span><br></pre></td></tr></table></figure>

<p>在我们使用ESLint推荐的使用<code>useMemo</code> Hook之前，我们可以尝试更加简单的操作。我们可以尝试两次创建<code>team</code>对象，一个用于传递给<code>Player</code>子组件，一个用于<code>useEffect</code>内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; id, name, active &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// recreate the `team` object within `useEffect`</span></span><br><span class="line">    <span class="comment">// from props/state</span></span><br><span class="line">    <span class="keyword">const</span> team = &#123; id, name, active &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [id, name, active])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> team = &#123; id, name, active &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>team</code>对象是在<code>useEffect</code>内部被创建，并且只在<code>effect</code>要被执行的时候被创建。<code>id</code>、<code>name</code>、<code>active</code>作为依赖，只有当这些值发生变化的时候<code>effect</code>才会执行。</p>
<p><strong>创建对象相对来说开销是比较小的，所以在useEffect中重新创建一个<code>team</code>对象是可以接受的。</strong><br>优化<code>useEffect</code>所带来的性能提升远远大于创建两个对象所带来的性能损耗。</p>
<h2 id="Option3-记忆对象"><a href="#Option3-记忆对象" class="headerlink" title="Option3 - 记忆对象"></a>Option3 - 记忆对象</h2><p>然而，如果创建对象或数组的开销是昂贵的，那重复创建对象就会比执行多次<code>effect</code>更糟糕。在这种情况下，我们需要“缓存”创建的对象或数组，这样当其中的数据没有发生变化时，这个对象或数组就不会在渲染过程中发生变化。这个过程称为“记忆”（memoization），我们通过<code>useMemo</code>来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createTeam &#125; <span class="keyword">from</span> <span class="string">'../utils'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; id, name, active &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// memoize calling `createTeam` because it's</span></span><br><span class="line">  <span class="comment">// an expensive operation</span></span><br><span class="line">  <span class="keyword">const</span> team = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> createTeam(&#123; id, name, active &#125;), [</span><br><span class="line">    id,</span><br><span class="line">    name,</span><br><span class="line">    active,</span><br><span class="line">  ])</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [team])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设这个<code>createTeam()</code>方法开销昂贵，那我们自然会希望它执行的次数越少越好。<code>useMemo</code> Hook可以实现只有在<code>id</code>、<code>name</code>或者<code>active</code>在渲染过程中发生变化时，才会再次创建<code>team</code>。但如果在<code>Team</code>组件重新渲染过程中，以上属性没有一个发生变化，<code>team</code>对象就会是同一个对象。因为是同一个对象，我们就可以放心地使用<code>useEffect</code>，不用担心会执行不必要的次数。</p>
<h2 id="Option-4-自己创建"><a href="#Option-4-自己创建" class="headerlink" title="Option 4 - 自己创建"></a>Option 4 - 自己创建</h2><p>如果以上方案都无法解决问题怎么办？比如从<code>props</code>中传入了对象或者数组，这个对象或数组会成为<code>useEffect</code>的依赖数组元素，而且我们并不知道创建一个新的<code>team</code>对象所需的属性。但我们还是想要实现在组件渲染过程中“缓存”这个对象的值。</p>
<p>在这种情况下，我们可以使用<code>useRef</code> Hook替代<code>useMemo</code> Hook。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> isDeepEqual <span class="keyword">from</span> <span class="string">'fast-deep-equal/react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getPlayers &#125; <span class="keyword">from</span> <span class="string">'../api'</span></span><br><span class="line"><span class="keyword">import</span> Players <span class="keyword">from</span> <span class="string">'../components/Players'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Team = <span class="function">(<span class="params">&#123; team &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [players, setPlayers] = useState([])</span><br><span class="line">  <span class="keyword">const</span> teamRef = useRef(team)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isDeepEqual(teamRef.current, team)) &#123;</span><br><span class="line">    teamRef.current = team</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (team.active) &#123;</span><br><span class="line">      getPlayers(team).then(setPlayers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [teamRef.current])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Players</span> <span class="attr">team</span>=<span class="string">&#123;team&#125;</span> <span class="attr">players</span>=<span class="string">&#123;players&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了<code>isDeepEqual</code>来判断<code>teamRef.current</code>和<code>team</code>的值是否一致，而不是比较两者的内存地址。所以，即使在每次渲染过程中<code>team</code>对象是一个新的对象，如果它的内容是一致的，<code>isDeepEqual()</code>也会返回<code>true</code>。</p>
<p>所以当两者在做深比较的时候，如果内容一致，<code>isDeepEqual</code>会返回<code>true</code>，<code>teamRef.current</code>会继续指向原本<code>team</code>对象的内存地址。那依赖数组里的元素<code>teamRef.current</code>就没有发生变化，<code>useEffect</code>也不会再执行。如果<code>isDeepEqual</code>返回<code>false</code>，<code>teamRef.current</code>就会被赋予新的<code>team</code>值，<code>effect</code>就会执行。</p>
<p>如果你发现自己遇到了Option4这样的情况，我建议安装<code>react-use</code>npm包，使用其中的<code>useDeepCompareEffect</code> Hook来解决问题，还能够避免<code>react-hooks/exhaustive-deps</code>lint rule报错。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大多数情况下，我能用Option1来解决问题。如果Option1无法解决，我就会使用<code>react-use</code>包里的helper Hook来解决问题。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux源码解析</title>
    <url>/2021/01/09/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Redux源码解析"><a href="#Redux源码解析" class="headerlink" title="Redux源码解析"></a><strong>Redux源码解析</strong></h1><p>在使用Redux的时候，我们会觉得很方便，因为很多事情Redux会帮我们完成，在内部运作，不需要我们手动去做，比如我们调用dispatch方法的时候，Redux自动就会帮我们执行reduce方法，更新state。所以本文就来拆解一些Redux在背后为我们做的事情，主要分为以下几部分：</p>
<ul>
<li>createStore发生了什么?</li>
<li>dispatch执行后在内部怎么运行的？</li>
<li>compose函数做了什么事情？</li>
<li>combineReducers是如何合并不同的reducer的？</li>
<li>applyMiddleware是如何组织中间件的？</li>
</ul>
<br>

<h1 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a><strong>createStore</strong></h1><p>createStore是要见一个store仓库，是redux的核心所在，它最后要返回四个非常重要的属性，分别是：</p>
<ul>
<li>getState</li>
<li>subscribe</li>
<li>dispatch</li>
<li>replaceReducer</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    getState,<span class="comment">// 获取到 state</span></span><br><span class="line">    subscribe,<span class="comment">// 采用发布订阅模式，这个方法进行观察者的订阅</span></span><br><span class="line">    dispatch,<span class="comment">// 派发 action</span></span><br><span class="line">    replaceReducer<span class="comment">// 用新的 reducer 替换现在的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先第一步是检查参数，一共可以接受3个参数，分别是reducer（改变store的纯函数），preloadedState（初始状态），enhancer（中间件相关）。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//reducer 必须是函数</span></span><br><span class="line">    <span class="comment">// 当前 reducer</span></span><br><span class="line">    <span class="keyword">let</span> currentReducer = reducer</span><br><span class="line">    <span class="comment">//state 数据，redux 的根本</span></span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState</span><br><span class="line">    <span class="comment">// 订阅者集合</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = []</span><br><span class="line">    <span class="comment">// 虽然不起眼，但是是一个关键的设计</span></span><br><span class="line">    <span class="keyword">let</span> nextListeners = currentListeners</span><br><span class="line">    <span class="comment">// 是否正在有 dispatch 在运行</span></span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//return 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>createStore的getState方法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有 dispatch 正在执行则报错</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">"xxxx 具体信息省略"</span>)</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>createStore的subscribe方法：</p>
<p>为了避免发生问题，我们会缓存最开始的数组currentListeners，在调用订阅者的时候，一切关于currentListeners的改变都不允许，但是可以拷贝一份同样的数组，让它来承担订阅者对数组的改变，这个数组就是nextListeners。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 next 和 current 数组是一个引用，那这种情况是危险的，原因上面已经谈到，我们需要 next 和 current 保持各自独立</span></span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">    nextListeners = currentListeners.slice ()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span> (<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">'Expected the listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果正在有 dispatch 执行则报错</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">"xxx"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line">    ensureCanMutateNextListeners ()</span><br><span class="line">    nextListeners.push (listener)</span><br><span class="line">    <span class="comment">// 返回的是一个退订的方法，将特定的 listener 从订阅者集合中删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 已经退订了就不管了</span></span><br><span class="line">        <span class="keyword">if</span> (!isSubscribed) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (isDispatching) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">"xxx 具体信息省略"</span>)</span><br><span class="line"></span><br><span class="line">        isSubscribed = <span class="literal">false</span></span><br><span class="line">        ensureCanMutateNextListeners ()</span><br><span class="line">        <span class="keyword">const</span> index = nextListeners.indexOf (listener)</span><br><span class="line">        nextListeners.splice (index, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>subscribe方法用于添加订阅者Listener，返回的函数unsubscirbe方法用于退订某个订阅者。</p>
<p><strong>每次调用这个subscribe函数时，都会产生一个闭包，里面存储着isSubscribed的值，调用n次就会产生n个这样的闭包，用来存储n个不同的订阅情况。</strong></p>
<p>createStore的dispatch函数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line"><span class="comment">//action 必须是一个对象</span></span><br><span class="line"><span class="comment">//action.type 不能为 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 看到没有？执行 reducer 后返回的状态直接成为 currentState 了</span></span><br><span class="line">    currentState = currentReducer (currentState, action)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将nextListeners赋值给currentListeners</span></span><br><span class="line"><span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="comment">// store发生变化则调用每个订阅者</span></span><br><span class="line">    <span class="keyword">const</span> listener = listeners [i]</span><br><span class="line">    listener ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>createStore的replaceReducer函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function replaceReducer (nextReducer) &#123;</span><br><span class="line">    if (typeof nextReducer !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        throw new Error (&#39;Expected the nextReducer to be a function.&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentReducer &#x3D; nextReducer</span><br><span class="line">    &#x2F;&#x2F; 此时无法匹配任何的 action，但是返回的状态可以将 currentState 给更新</span><br><span class="line">    &#x2F;&#x2F; 也就是更新当前的 state，因为 reducer 更新了，老的 state 该换了！</span><br><span class="line">    dispatch (&#123; type: ActionTypes.REPLACE &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="combineReducer"><a href="#combineReducer" class="headerlink" title="combineReducer"></a><strong>combineReducer</strong></h1><p>在之前的Redux及其中间件解析文章中也有提到，combineReducers方法的作用将所有子reducer合并为一个大reducer，根据action的不同返回新的state：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingWithA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    a: doSomethingWithA(state.a, action),</span><br><span class="line">    b: processB(state.b, action),</span><br><span class="line">    c: c(state.c, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其源码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span> (<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以项目中的例子来讲，reducerKeys 就是 ['recommend', 'singers']</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys (reducers)</span><br><span class="line">  <span class="comment">//finalReducers 是 reducers 过滤后的结果</span></span><br><span class="line">  <span class="comment">// 确保 finalReducers 里面每一个键对应的值都是函数</span></span><br><span class="line">  <span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys [i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers [key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    finalReducers [key] = reducers [key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys (finalReducers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后依然返回一个纯函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span> (<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这个标志位记录初始的 state 是否和经过 reducer 后是一个引用，如果不是则 state 被改变了</span></span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = finalReducerKeys [i]</span><br><span class="line">        <span class="keyword">const</span> reducer = finalReducers [key]</span><br><span class="line">        <span class="comment">// 原来的状态树中 key 对应的值</span></span><br><span class="line">        <span class="keyword">const</span> previousStateForKey = state [key]</span><br><span class="line">        <span class="comment">// 调用 reducer 函数，获得该 key 值对应的新状态</span></span><br><span class="line">        <span class="keyword">const</span> nextStateForKey = reducer (previousStateForKey, action)</span><br><span class="line">        nextState [key] = nextStateForKey</span><br><span class="line">        hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个很简单理解吧？如果没改变直接把原始的 state 返回即可</span></span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="compose函数"><a href="#compose函数" class="headerlink" title="compose函数"></a><strong>compose函数</strong></h1><p>compose是一个工具，充分体现高阶函数的技巧。源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs [<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> funcs.reduce (<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a (b (...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f0 = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log (x) &#125;</span><br><span class="line"><span class="keyword">const</span> f1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log (<span class="number">1</span>) &#125;</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log (<span class="number">2</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> fArr = [f2, f1, f0];</span><br><span class="line"><span class="built_in">console</span>.log (compose (...fArr)(<span class="number">100</span>)) <span class="comment">// 执行 f2 (f1 (f0 (100))) 输出 100 1 2</span></span><br></pre></td></tr></table></figure>



<p>compose函数一般用于组合所有的enhancer，作为第三个参数传入createStore方法。createStore方法的结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createStore(reducer, [preloadedState], [enhancer])</span><br></pre></td></tr></table></figure>

<p>第三个可选参数enhancer指的是store enhancer，也就是store的增强器，用于增强store的功能。一个store enhancer，实际上是一个高阶函数（compose也是一个高阶函数），它的参数是创建store的函数（store creator），返回值是一个可以创建功能更强大的store的函数（enhanced store creator），这和React中的高阶组件的概念很相似。</p>
<p>store enhancer函数的结构一般如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancerCreator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something based on old store</span></span><br><span class="line">        <span class="comment">// return a new enhanced store</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，enhancerCreator是用于创建store enhancer的函数，也就是说，enhancerCreator的调用结果才是一个store enhancer。(…args)参数代表穿件store所需要的参数，也就是createStore接收的参数，实际上就是(reducer, [preloadedState], [enhancer])。</p>
<p>可以这么理解，因为要创建一个功能更加强大的store，所以需要传入创建store所需要的参数。</p>
<p>比如，现在我们想创建一个store enhancer，用于输出发送的action的信息和state的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autoLogger.js</span></span><br><span class="line"><span class="comment">// store enhancer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">autoLogger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">reducer, initialState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(reducer, initialState, enhancer)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`dispatch an action: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(action)&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> res = store.dispatch(action);</span><br><span class="line">      <span class="keyword">const</span> newState = store.getState();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`current state: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(newState)&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;...store, dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>autoLogger声明了一个新的dispatch方法，在原本的store.dispatch方法基础上添加了两个输出日志，然后返回一个新的store（{…store, dispatch}）。当我们调用dispatch方法时，实际是调用了autoLogger方法中新声明的dispatch，因为上面对象最后一个dispatch覆盖了store中的dispatch。</p>
<p>其中createStore的部分源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数为函数，但是第三个参数没传</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        enhancer = preloadedState<span class="comment">// 将第二个参数当做 enhancer </span></span><br><span class="line">        preloadedState = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保 enhancer 为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer (createStore)(reducer, preloadedState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如何使用这个store enhancer？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// configureStore.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'path/to/reducers'</span>;</span><br><span class="line"><span class="keyword">import</span> autLogger <span class="keyword">from</span> <span class="string">'path/to/autoLogger'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer，</span><br><span class="line">  autoLogger()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<br>

<h1 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a><strong>applyMiddleware</strong></h1><p>applyMiddleware本身就是一个store enhancer，结构和上面的autoLogger很像，applyMiddleware的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span> (<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore (...args)</span><br><span class="line">        <span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (</span><br><span class="line">                <span class="string">'Dispatching while constructing your middleware is not allowed. '</span> +</span><br><span class="line">                <span class="string">'Other middleware would not be applied to this dispatch.'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//middlewareAPI 其实就是拿到 store 的信息</span></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">        getState: store.getState,</span><br><span class="line">        dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch (...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考上面的 thunk，其实就是传入 store 参数，剩下的部分为 next =&gt; action =&gt; &#123; ... &#125;;</span></span><br><span class="line">    <span class="comment">// 传入这个参数是必须的，因为需要拿到 store 的相关属性，如 thunk 拿了 getState</span></span><br><span class="line">    <span class="comment">// 这里的意思就是每个中间件都能拿到 store 的数据</span></span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map (<span class="function"><span class="params">middleware</span> =&gt;</span> middleware (middlewareAPI))</span><br><span class="line">    dispatch = compose (...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...store,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在调用applyMiddleware(thunk, logger)，走到compose逻辑的时候，相当于调用thunk(logger(store.dispatch))。</p>
<p>无论是applyMiddleware中使用compose组合所有中间件还是使用compose来组合所有的enhancer，在经过compose组合之后，所有的middleware或store enhancer都会形成一个洋葱模型。compose中的第一个enhancer（或middleware）处于洋葱模型的最外层，最后一个enhancer处于洋葱模型的最里层，经过层层调用形成一个更强大的store：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210109164428.png" alt></p>
<p>applyMiddleware(…middlewares)将middleware限制为只可以增强store dispatch的功能，但这只是它自身的规范限制，对于其他store enhancer，你可以增强store中包含的任意方法的功能，如dispatch、subscribe、getState、replaceReducer等。毕竟，store只是一个包含一些函数的普通JavaScript对象，可以很容易的复制其中的方法，并增加新的功能。</p>
<br>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="https://juejin.cn/book/6844733816460804104/section/6844733816599216141" target="_blank" rel="noopener">Redux及中间件原理解析</a></p>
<p><a href="https://segmentfault.com/a/1190000012653724" target="_blank" rel="noopener">浅析Redux的store enhancer</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Taro入门及踩坑之旅</title>
    <url>/2021/01/12/Taro%E5%85%A5%E9%97%A8%E5%8F%8A%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因最近开始准备毕设，我的毕设是要做一个小程序，便开始了学习如何开发小程序之旅。</p>
<p><code>Taro</code>是一个开放式跨端跨框架的解决方案，支持使用<code>React/Vue/Nerv</code>等框架来开发微信、京东、百度、支付宝、字节跳动、QQ小程序 / H5等应用。</p>
<p>所以，使用<code>Taro</code>的话，只需编写一套代码就能够拥有适配到多端的能力。<code>Taro</code>目前在<code>github</code>上 有27.9k个star，这也是我选择学习它的一个原因。（虽然整个做下来之后发现它的教程坑实在是多……）</p>
<p>那就开始吧。</p>
<blockquote>
<p>官方文档：<a href="https://docs.taro.zone/docs/README" target="_blank" rel="noopener">Taro官方文档</a></p>
</blockquote>
<br>

<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>因为有一定前端开发经验，所以我直接从渐进式入门教程着手，通过实操一步步上手。</p>
<blockquote>
<p><a href="https://docs.taro.zone/docs/guide" target="_blank" rel="noopener">渐进式入门教程</a></p>
<p><a href="https://github.com/NervJS/taro-v2ex" target="_blank" rel="noopener">渐进式入门教程源码</a></p>
</blockquote>
<p>渐进式入门教程是使用<code>Taro</code>开发一个简单的<code>V2EX</code>论坛客户端，整个教程分为4个部分：</p>
<ul>
<li>环境准备</li>
<li>基础教程</li>
<li>项目进阶与优化</li>
<li>多端开发</li>
</ul>
<p>这里就展开一些教程中没有提到的点和总结其中比较关键的点。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>使用<code>Taro</code>开发需要安装：</p>
<ul>
<li><code>Taro CLI</code></li>
<li><code>Node.js</code></li>
</ul>
<p><code>Taro CLI</code>安装指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g @tarojs&#x2F;cli</span><br></pre></td></tr></table></figure>

<p>安装完毕后在终端输入<code>taro</code>，如果出现类似内容说明安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">👽 Taro v3.0.0-beta.6</span><br><span class="line"></span><br><span class="line">Usage: taro &lt;command&gt; [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version       output the version number</span><br><span class="line">  -h, --help          output usage information</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  init [projectName]  Init a project with default templete</span><br><span class="line">  config &lt;cmd&gt;        Taro config</span><br><span class="line">  create              Create page for project</span><br><span class="line">  build               Build a project with options</span><br><span class="line">  update              Update packages of taro</span><br><span class="line">  convert             Convert weapp to taro</span><br><span class="line">  info                Diagnostics Taro env info</span><br><span class="line">  doctor              Diagnose taro project</span><br><span class="line">  help [cmd]          display help for [cmd]</span><br></pre></td></tr></table></figure>



<h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在小程序中，组件分为页面组件和基础组件。页面组件就是那些可以通过路由跳转到指定页面的组件，具有生命周期，基础组件就是一些普通组件，不构成页面，是页面或者组件的一部分。</p>
<h4 id="页面组件"><a href="#页面组件" class="headerlink" title="页面组件"></a>页面组件</h4><p>页面组件一般在<code>pages</code>文件夹下定义：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210112215246.png" alt></p>
<p>以<code>thread_detail</code>组件举例，该文件夹下有三个文件：</p>
<ul>
<li><code>index.css</code>：样式文件</li>
<li><code>thread_detail.tsx</code>：组件</li>
<li><code>thread_detail.config.ts</code>：页面组件配置文件</li>
</ul>
<p>配置文件主要是配置一些基础样式和文字，<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html" target="_blank" rel="noopener">页面配置</a>，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">backgroundTextStyle: &#39;light&#39;,</span><br><span class="line">navigationBarBackgroundColor: &#39;#fff&#39;,</span><br><span class="line">navigationBarTitleText: &#39;WeChat&#39;,</span><br><span class="line">navigationBarTextStyle: &#39;black&#39;</span><br></pre></td></tr></table></figure>

<p>在<code>thread_detail.config.ts</code>中是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  navigationBarTitleText: &#39;话题&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个配置文件是必须要写的，否则在项目打包编译就会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module not found: Can‘t resolve ‘.&#x2F;pages&#x2F;xxx&#x2F;xxx.config‘ in ‘xxxx‘</span><br></pre></td></tr></table></figure>

<p>这里要注意一下。</p>
<p>类组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以使用所有的 React 组件方法</span></span><br><span class="line">  componentDidMount () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onLoad</span></span><br><span class="line">  onLoad () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onReady</span></span><br><span class="line">  onReady () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onShow</span></span><br><span class="line">  componentDidShow () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onHide</span></span><br><span class="line">  componentDidHide () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onPullDownRefresh，除了 componentDidShow/componentDidHide 之外，</span></span><br><span class="line">  <span class="comment">// 所有页面生命周期函数名都与小程序相对应</span></span><br><span class="line">  onPullDownRefresh () &#123;&#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View className=<span class="string">'index'</span> /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index</span><br></pre></td></tr></table></figure>



<p>函数组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; View &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useReady,</span><br><span class="line">  useDidShow,</span><br><span class="line">  useDidHide,</span><br><span class="line">  usePullDownRefresh</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Index</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可以使用所有的 React Hooks</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onReady</span></span><br><span class="line">  useReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onShow</span></span><br><span class="line">  useDidShow(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 onHide</span></span><br><span class="line">  useDidHide(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Taro 对所有小程序页面生命周期都实现了对应的自定义 React Hooks 进行支持</span></span><br><span class="line">  <span class="comment">// 详情可查阅：【Taro 文档】-&gt; 【进阶指南】-&gt;【Hooks】</span></span><br><span class="line">  usePullDownRefresh(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View className=<span class="string">'index'</span> /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index</span><br></pre></td></tr></table></figure>





<h4 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h4><p>基础组件一般在<code>components</code>文件夹下定义：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210112220336.png" alt></p>
<p>这里就不需要为每个组件设置配置文件。</p>
<h3 id="入口配置"><a href="#入口配置" class="headerlink" title="入口配置"></a>入口配置</h3><p><code>app.config.ts</code>就是入口配置文件，我们可以在其中配置页面路径列表、全局的默认窗口表现等属性。<code>Taro</code>的配置规范是基于微信小程序的全局配置进行规定的：<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">微信小程序全局配置</a>。</p>
<p>在V2EX项目中，全局配置为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.config.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  pages: [</span><br><span class="line">    <span class="string">'pages/index/index'</span>,</span><br><span class="line">    <span class="string">'pages/nodes/nodes'</span>,</span><br><span class="line">    <span class="string">'pages/hot/hot'</span>,</span><br><span class="line">    <span class="string">'pages/node_detail/node_detail'</span>,</span><br><span class="line">    <span class="string">'pages/thread_detail/thread_detail'</span>,</span><br><span class="line">  ],</span><br><span class="line">  tabBar: &#123;</span><br><span class="line">    list: [&#123;</span><br><span class="line">      <span class="string">'iconPath'</span>: <span class="string">'resource/latest.png'</span>,</span><br><span class="line">      <span class="string">'selectedIconPath'</span>: <span class="string">'resource/lastest_on.png'</span>,</span><br><span class="line">      pagePath: <span class="string">'pages/index/index'</span>,</span><br><span class="line">      text: <span class="string">'最新'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="string">'iconPath'</span>: <span class="string">'resource/hotest.png'</span>,</span><br><span class="line">      <span class="string">'selectedIconPath'</span>: <span class="string">'resource/hotest_on.png'</span>,</span><br><span class="line">      pagePath: <span class="string">'pages/hot/hot'</span>,</span><br><span class="line">      text: <span class="string">'热门'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="string">'iconPath'</span>: <span class="string">'resource/node.png'</span>,</span><br><span class="line">      <span class="string">'selectedIconPath'</span>: <span class="string">'resource/node_on.png'</span>,</span><br><span class="line">      pagePath: <span class="string">'pages/nodes/nodes'</span>,</span><br><span class="line">      text: <span class="string">'节点'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">'color'</span>: <span class="string">'#000'</span>,</span><br><span class="line">    <span class="string">'selectedColor'</span>: <span class="string">'#56abe4'</span>,</span><br><span class="line">    <span class="string">'backgroundColor'</span>: <span class="string">'#fff'</span>,</span><br><span class="line">    <span class="string">'borderStyle'</span>: <span class="string">'white'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">window</span>: &#123;</span><br><span class="line">    backgroundTextStyle: <span class="string">'light'</span>,</span><br><span class="line">    navigationBarBackgroundColor: <span class="string">'#fff'</span>,</span><br><span class="line">    navigationBarTitleText: <span class="string">'WeChat'</span>,</span><br><span class="line">    navigationBarTextStyle: <span class="string">'black'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h4><p>在<code>Taro</code>中，可以使用<code>Taro</code>的<code>navigateTo</code>方法进行路由跳转：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Taro.navigateTo(&#123; <span class="attr">url</span>: <span class="string">'/pages/thread_detail/thread_detail'</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>这个用法类似<code>React</code>中的<code>props.history.push(&#39;/xxx&#39;)</code>。</p>
<h4 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h4><p>在页面组件中，可以通过 <code>getCurrentInstance().router</code> 或者<code>Current.router?.params</code>获取当前页面的路由参数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Taro, &#123; Current &#125; <span class="keyword">from</span> <span class="string">'@tarojs/taro'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件内</span></span><br><span class="line"><span class="keyword">const</span> &#123; full_name &#125; = Current.router?.params;</span><br></pre></td></tr></table></figure>



<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><code>React</code>组件的生命周期方法和小程序的生命周期方法在<code>Taro</code>中均支持，但需要注意它们的触发时机和顺序。见官方文档：<a href="https://taro-docs.jd.com/taro/docs/react#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">生命周期触发机制</a>。</p>
<h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><p><code>Taro</code>中使用小程序规范的内置组件进行开发，如<code>&lt;View /&gt;</code>、<code>&lt;Text /&gt;</code>、<code>&lt;Button /&gt;</code>等，这些是跨平台组件。</p>
<p>在<code>React</code>中使用这些内置组件前，必须从<code>@tarojs/components</code>进行引入，组件的<code>props</code>遵从大驼峰式命名规范：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小程序写法</span></span><br><span class="line">&lt;view hover-<span class="class"><span class="keyword">class</span></span>=<span class="string">'test'</span> /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Taro写法</span></span><br><span class="line"><span class="keyword">import</span> &#123; View &#125; <span class="keyword">from</span> <span class="string">'@tarojs/components'</span></span><br><span class="line"></span><br><span class="line">&lt;View hoverClass=<span class="string">'test'</span> /&gt;</span><br></pre></td></tr></table></figure>



<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在 Taro 中事件遵从小驼峰式（camelCase）命名规范，所有内置事件名以 <code>on</code> 开头。</p>
<p>在事件回调函数中，第一个参数是事件本身，回调中调用 <code>stopPropagation</code> 可以阻止冒泡。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation() <span class="comment">// 阻止冒泡</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">scrollHandler</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只有小程序的 bindtap 对应 Taro 的 onClick</span></span><br><span class="line">  <span class="comment">// 其余小程序事件名把 bind 换成 on 即是 Taro 事件名（支付宝小程序除外，它的事件就是以 on 开头）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">onClick</span>=<span class="string">&#123;clickHandler&#125;</span> <span class="attr">onScroll</span>=<span class="string">&#123;scrollHandler&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="项目进阶与优化"><a href="#项目进阶与优化" class="headerlink" title="项目进阶与优化"></a>项目进阶与优化</h2><p>项目在开发完毕之后，我们想要看项目的效果是怎么样的，要怎么做呢？当时我很疑惑，于是找了<code>Taro</code>官方的一个5分钟上手小程序的<a href="https://mp.weixin.qq.com/s?__biz=MzU3NDkzMTI3MA==&mid=2247484205&idx=1&sn=935bb7a35c11c33563eeb7c3aaca3321&chksm=fd2bab04ca5c2212b4cd8aeb5858bd08517aeb31e20727b22d1eee00b394184e7e61359e7dd9&token=1180618535&lang=zh_CN#rd" target="_blank" rel="noopener">视频</a>来看，便找到了答案。</p>
<p>首先，先打包编译。使用<code>Taro CLI</code>生成的项目，在<code>package.json</code>中已经配置好了各种小程序的打包编译指令：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210113104709.png" style="zoom:67%;">

<p>比如，我想打包微信小程序，则在终端输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev:weapp</span><br></pre></td></tr></table></figure>

<p>调试的话就执行<code>npm run dev</code>，打包构建到生产环境则执行<code>npm run build</code>。</p>
<p>如果想要<strong>多端编译</strong>，在<code>config</code>文件夹下的<code>index.js</code>里修改<code>outputRoot</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">outputRoot: <span class="string">`dist/<span class="subst">$&#123;process.env.TARO_ENV&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<p>这样的话，各个端打包好的文件就可以同时存放在<code>dist</code>文件夹内，比如微信小程序的路径是<code>dist/weapp</code>，<code>h5</code>的路径是<code>dist/h5</code>。</p>
<p>然后，打开微信开发者工具，导入打包编译好的项目，就有效果啦：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210113110200.png" alt></p>
<p>但此时，我的项目遇到了一个bug，在微信开发者工具中报错了：<br><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210113110650.png" alt></p>
<p>当时没有仔细看报错信息，其实第二行<code>Thread.render</code>中点击进去有提示报错位置。心想：这没法调试。。。也没办法<code>console.log</code>。（实际上是可以的）。</p>
<p>于是便想，那是不是可以打包成<code>h5</code>，在浏览器里调试，这样不就和平时的前端开发一样了么！于是便转向了另一个方向。但是在浏览器端，会有跨域问题，<code>localhost</code>向<code>https://www.v2ex.com/api/</code>发起请求是违反了浏览器的同源策略。小程序开发工具并没有同源策略的限制，于是不会有这个问题。</p>
<h3 id="Taro-h5-跨域问题解决"><a href="#Taro-h5-跨域问题解决" class="headerlink" title="Taro h5 跨域问题解决"></a><code>Taro</code> h5 跨域问题解决</h3><p>首先，要在<code>config/dev.js</code>中添加h5配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">h5: &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api/'</span>: &#123;</span><br><span class="line">                target: <span class="string">"https://www.v2ex.com"</span>,</span><br><span class="line">                    changeOrigin: <span class="literal">true</span></span><br><span class="line">                <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">                <span class="comment">//   '^/api/': '/'</span></span><br><span class="line">                <span class="comment">// &#125;,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的配置就是<code>webpack</code>的<code>devServer</code>的配置，详情可参考博客：<a href="https://blog.csdn.net/mobile18611667978/article/details/100545882" target="_blank" rel="noopener">devServer之proxy跨域</a></p>
<p>第二步，修改<code>api.ts</code>里的<code>HOST</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HOST_URI = <span class="string">'https://www.v2ex.com/api/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改为</span></span><br><span class="line"><span class="keyword">const</span> HOST_URI = <span class="string">'/api/'</span></span><br></pre></td></tr></table></figure>

<p>为什么要这么改呢？因为在proxy中，我们会检查请求的开头是否为<code>/api/</code>，如果是以<code>http</code>开头，则检查不匹配，不走代理，跨域失效。所以去掉前面的<code>http</code>部分，相当于遇到<code>/api/</code>才做代理，则会把默认域名<code>http://localhost:xxxx</code>改成<code>target</code>，也就是<code>https://www.v2ex.com</code>地址。不过在浏览器F12下，<code>Network-&gt;Headers</code>中看到的还是<code>http://localhost:xxxx/api/xxx</code>，但是真正的请求地址为：<code>https://www.v2ex.com/api/xxx</code>。</p>
<p>需要添加<code>pathRewrite</code>属性的场景是：相当于遇见<code>/api/</code>才做代理，但真实的请求中没有<code>/api/</code>，所以在<code>pathRewrite</code>中把<code>/api/</code>去掉, 这样既有了标识, 又能在请求接口中把<code>/api/</code>去掉。</p>
<p>运行<code>npm run dev:h5</code>，可以在浏览器端查看到效果：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210113114233.png" alt></p>
<p>最后问题是由于将生命周期函数<code>componentWillMount</code>写成<code>componentWillUnmount</code>导致的，找了好久，以至于想锤死自己。</p>
<p>不过<code>React</code>已经不建议使用<code>componentWillMount</code>这个生命周期函数了，所以我们应该将数据获取放在<code>componentDidMount</code>中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      thread: <span class="keyword">this</span>.props.thread</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染时加一层判断：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件内</span></span><br><span class="line"><span class="comment">// 在加载到thread的数据后再渲染，防止出现property of undefined的报错</span></span><br><span class="line"><span class="keyword">const</span> attrLen = <span class="built_in">Object</span>.keys(thread).length;</span><br><span class="line"></span><br><span class="line">&#123;attrLen ? <span class="xml"><span class="tag">&lt;<span class="name">Thread</span></span></span></span><br><span class="line"><span class="xml">    node=&#123;thread.node&#125;</span></span><br><span class="line"><span class="xml">    title=&#123;thread.title&#125;</span></span><br><span class="line"><span class="xml">    last_modified=&#123;thread.last_modified&#125;</span></span><br><span class="line"><span class="xml">    replies=&#123;thread.replies&#125;</span></span><br><span class="line"><span class="xml">    tid=&#123;thread.id&#125;</span></span><br><span class="line"><span class="xml">    member=&#123;thread.member&#125;</span></span><br><span class="line"><span class="xml">    not_navi=&#123;true&#125;</span></span><br><span class="line"><span class="xml">/&gt;</span> : <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>



<p>其实微信开发者工具也有完善的调试器，能够看到<code>console.log</code>等的结果，所以我们直接在<code>vscode</code>中修改代码，<code>ctrl s</code>之后，就能够在微信开发者工具中看到相应的渲染结果，也可以通过看<code>console</code>来调试。不过微信开发者工具似乎不能够使用<code>Redux</code>的调试工具，这个之后再研究研究。</p>
<p>后续用hooks对这个demo进行重构，代码仓库：<a href="https://github.com/delaprada/taro-mini-program" target="_blank" rel="noopener">taro-mini-program</a>。</p>
<br>

<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><code>Taro</code>学习优秀资源：<a href="https://github.com/NervJS/awesome-taro" target="_blank" rel="noopener">awesome-taro</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Taro微信小程序云开发实践</title>
    <url>/2021/01/16/Taro%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>云开发简而言之就是：开发者无需搭建服务器，可免鉴权直接使用平台提供的API进行业务开发。</p>
<p>云开发提供云函数，云数据库和云存储，服务端的部署和托管都交由腾讯云来管理，开发者就无需在运维和管理上投入过多的精力。</p>
<p>小程序传统开发模式：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210116143909.png" alt></p>
<p>小程序云开发：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210116143957.png" style="zoom: 67%;">

<ul>
<li>云函数：node.js</li>
<li>云数据库：MongoDB</li>
</ul>
<p>传统开发 vs 云开发：</p>
<p><img src="/images/loading.png" data-original="C:%5CUsers%5Calice%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210116144312278.png" alt="image-20210116144312278"></p>
<p>（<code>serverless</code>指的是：我们无需考虑硬件等基础设施，是无服务的应用，我们依赖的是像腾讯云这样的云服务商提供的服务）</p>
<h1 id="云开发"><a href="#云开发" class="headerlink" title="云开发"></a>云开发</h1><p>想要在小程序中实现云开发，首先在导入项目时要填入注册的<code>APPID</code>，必须填写，否则无法使用云开发功能。</p>
<p>无论是使用微信创建一个云开发项目还是使用<code>taro cli</code>初始化一个云开发项目，根目录下都会有一个<code>project.config.json</code>文件，文件中的<code>cloudbaseRoot</code>用于指定存放云函数&amp;云托管的目录。</p>
<p>需要注意的是，云开发能力从基础库<code>2.2.4</code>开始支持。</p>
<p>云开发在默认配额下可以创建两个环境，各个环境相互隔离，每个环境都包含独立的数据库实例、存储空间、云函数配置等资源：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210116150121.png" alt></p>
<p>如上图所示，我创建了两个环境，一个叫<code>dev</code>， 一个叫<code>test-taro</code>。</p>
<p>在项目中，需要为项目配置开发的环境，否则默认都是指定<strong>第一个创建的环境</strong>。</p>
<p>比如在<code>taro</code>云开发项目中，需在<code>app.js</code>中配置项目环境：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.TARO_ENV === <span class="string">'weapp'</span>) &#123;</span><br><span class="line">        Taro.cloud.init(&#123;</span><br><span class="line">            env: <span class="string">'test-taro-1gs4sohn82c1ff34'</span> <span class="comment">// 环境id</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>微信原生的云开发项目中，则在<code>onLaunch</code>方法中配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!wx.cloud) &#123;</span><br><span class="line">		<span class="built_in">console</span>.error(<span class="string">'请使用 2.2.3 或以上的基础库以使用云能力'</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wx.cloud.init(&#123;</span><br><span class="line">            <span class="comment">// env 参数说明：</span></span><br><span class="line">            <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">            <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">            <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">            <span class="comment">// env: 'my-env-id',</span></span><br><span class="line">            traceUser: <span class="literal">true</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.globalData = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>云函数处可通过右键切换云函数的当前环境：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210116151334.png" alt></p>
<p><strong>注意</strong>：在小程序端配置<code>init</code>时的<code>env</code>只会决定小程序端API调用的云环境，并不会决定云函数中API调用的环境，云函数中需要通过<code>wx-server-sdk</code>的<code>init</code>方法重新设置环境（或者使用上面的方面）。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">wx.cloud.init(&#123;</span><br><span class="line">  env: <span class="string">'test-x1dzi'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h2><p>云数据库是一个JSON数据库，数据库中的每条记录都是一个JSON格式的对象。</p>
<p>一个数据库可以有多个集合（相当于关系型数据库中的表），集合可以看作一个JSON数组，数组中的每个对象就是一条记录，记录的格式是JSON对象。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210116151919.png" alt></p>
<p>通过在云开发界面点击+创建新的集合：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210116152028.png" alt></p>
<p>数据库的API分为小程序端和服务端两个部分：</p>
<ul>
<li>小程序端API：拥有严格的调用权限控制，开发者可在小程序内直接调用API进行非敏感数据的操作。</li>
<li>服务端：对于有更高安全要求的数据，可在云函数内通过服务端API进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全地操作数据库。</li>
</ul>
<p>在微信原生项目中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小程序端操作数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 云数据库</span></span><br><span class="line"><span class="keyword">const</span> db = wx.cloud.database();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向user集合添加数据</span></span><br><span class="line">db.collection(<span class="string">'user'</span>).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		name: <span class="string">"jerry"</span>,</span><br><span class="line">		age: <span class="string">"22"</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(res);</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err);</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务端操作数据库</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">'wx-server-sdk'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = cloud.database();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再进行数据库操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<p><code>taro</code>项目中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小程序端操作数据库</span></span><br><span class="line"><span class="keyword">const</span> db = Taro.cloud.database();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向user集合添加数据</span></span><br><span class="line">db.collection(<span class="string">'user'</span>)</span><br><span class="line">    .add(&#123;</span><br><span class="line">    	data: &#123;</span><br><span class="line">    		name: <span class="string">'alice'</span>,</span><br><span class="line">    		age: <span class="string">'26'</span>,</span><br><span class="line">    	&#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在云函数内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">"wx-server-sdk"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = cloud.database();</span><br><span class="line"><span class="comment">// 然后再进行数据库操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>





<h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><p>云函数是一段运行在云端的代码，相当于服务端的代码，我们可以在云函数中操作数据库、管理云文件、调用其他云函数等操作。</p>
<p>云函数必须要进行部署才能生效，部署方式：</p>
<p>右键点击函数文件夹，选择上传并部署（云端安装依赖，不上传<code>node_modules</code>）。</p>
<p>如果遇到以下问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloudTest.weapp.jsx:86 Error: errCode: -404011 cloud function execution error | errMsg: cloud.callFunction:fail requestID 7ac9328a-579d-11eb-9459-5254006d699d, cloud function service error code -504002, error message Error: errCode: -1 unknown error | err</span><br></pre></td></tr></table></figure>

<p>尝试重新上传并部署，过一会便生效了。</p>
<p>比如我们定义了一个<code>add</code>云函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法</span></span><br><span class="line"><span class="comment">// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了可以通过 getWXContext 方法获取的用户登录态 `openId` 和小程序 `appId` 信息</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">'wx-server-sdk'</span>)</span><br><span class="line">exports.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; userInfo, a, b&#125; = event</span><br><span class="line">  <span class="keyword">let</span> &#123; OPENID, APPID &#125; = cloud.getWXContext() <span class="comment">// 这里获取到的 openId 和 appId 是可信的</span></span><br><span class="line">  <span class="keyword">let</span> sum = a + b</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    OPENID,</span><br><span class="line">    APPID,</span><br><span class="line">    sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发者工具中上传并部署云函数后，我们在小程序中可以使用<code>callFunction</code>方法调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">  <span class="comment">// 需调用的云函数名</span></span><br><span class="line">  name: <span class="string">'add'</span>,</span><br><span class="line">  <span class="comment">// 传给云函数的参数</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">12</span>,</span><br><span class="line">    b: <span class="number">19</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 成功回调</span></span><br><span class="line">  complete: <span class="built_in">console</span>.log</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 当然 promise 方式也是支持的</span></span><br><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">  name: <span class="string">'add'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">12</span>,</span><br><span class="line">    b: <span class="number">19</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>



<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>云开发提供了云函数本地调试的功能，开发者可以在本地对云函数进行断点调试。</p>
<p>不使用本地调试和使用本地调试在调试流程上的区别：</p>
<ul>
<li>不使用本地调试：本地修改代码 —&gt; 上传部署云函数 —&gt; 调用。</li>
<li>使用本地调试：本地修改 —&gt; 调用。无需上传等待的步骤。</li>
</ul>
<p>如何进行本地调试？</p>
<p>进行本地调试的云函数首先要执行<code>cloud.init</code>步骤，在其中指定云函数的环境：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">  env: <span class="string">'test-taro-1gs4sohn82c1ff34'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>如果云函数中有使用到<code>npm</code>模块，需在云函数本地目录安装相应依赖才可正常使用云函数本地调用功能。所以如果在开启本地调试的过程中，有相关的警告，则检查一下是否有安装依赖。</p>
<p>云函数中一般都会用到<code>wx-server-sdk</code>这个<code>npm</code>包，所以应该都要在本地调试之前安装依赖，否则会报错。</p>
<p><img src="/images/loading.png" data-original="https://res.wx.qq.com/wxdoc/dist/assets/img/local-debug-flow-simple.b4e7aa78.gif" alt="描述"></p>
<ul>
<li>首先选中想要进行本地调试的云函数，右键选择开启云函数本地调试。</li>
</ul>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210117100009.png" alt></p>
<ul>
<li><code>source</code>目录下可以看到云函数对应的源代码，可以在代码里添加断点。</li>
<li>比如当前我测试的函数是<code>batch</code>，当我在小程序页面点击批量删除按钮时，调试便开启。我们可以控制怎么执行下一步来看整个函数执行的过程。也可以在<code>console</code>页看到相应的输出结果</li>
</ul>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210117100323.png" style="zoom:50%;">

<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210117100501.png" alt></p>
<h3 id="云端测试"><a href="#云端测试" class="headerlink" title="云端测试"></a>云端测试</h3><p>除了本地调试以外，还能够执行云端测试，在云开发平台对云函数进行测试：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210117100956.png" alt></p>
<p>在其中输入参数，运行测试，可以在开发者工具的调试器中看到执行结果。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210117101417.png" alt></p>
<h2 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h2><p>简单来说：</p>
<ul>
<li>云存储：提供存储能力，更多面对的场景是非结构化数据，如文件、图片、视频等。</li>
<li>云数据库：提供基础的数据库和数据对象管理能力，包括<code>oracle</code>、<code>mysql</code>、<code>sql</code>、<code>server</code>等关系型数据库，也可以包括类似<code>mongodb</code>、<code>hbase</code>等半结构化数据库。</li>
</ul>
<p>所以，如果我们要上传一些图片的话，我们需要将其存储到云存储中，并在数据库中记录图片在云存储中的路径。之后想要展示这些图片时，便可以从数据库中找到记录，将图片展示出来。</p>
<p>云存储的API包括：</p>
<ul>
<li><code>uploadFile</code></li>
<li><code>downloadFile</code></li>
<li><code>deleteFile</code></li>
<li><code>getTempFileURL</code></li>
</ul>
<br>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实践代码仓库地址：<a href="https://github.com/delaprada/wechat-miniprogram-cloud" target="_blank" rel="noopener">wechat-miniprogram-cloud</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>stroke学习之stroke-dasharray和stroke-dashoffset</title>
    <url>/2020/12/26/stroke%E5%AD%A6%E4%B9%A0%E4%B9%8Bstroke-dasharray%E5%92%8Cstroke-dashoffset/</url>
    <content><![CDATA[<p>今天在做音乐APP的进度条功能的时候，使用到了svg的stroke-dasharray和stoke-dashoffset两个之前没有用到过的属性，借此机会总结一下。</p>
<h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a><strong>概念解析</strong></h1><ul>
<li><p><code>stroke</code>：画短线于，在…上划线</p>
</li>
<li><p><code>stroke-dasharray</code>：用于创建虚线。之所以是array是因为其值其实是数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stroke-dasharray &#x3D; &#39;10&#39; </span><br><span class="line">stroke-dasharray &#x3D; &#39;10, 5&#39; </span><br><span class="line">stroke-dasharray &#x3D; &#39;20, 10, 5&#39;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201226091645.png" alt></p>
<ul>
<li><p><code>stroke-dasharray</code>为一个参数时： 其实是表示虚线长度和每段虚线之间的间距。如：<code>stroke-dasharray = &#39;10&#39;</code> 表示：虚线长10，间距10，然后重复 虚线长10，间距10。</p>
</li>
<li><p>两个参数或者多个参数时：一个表示长度，一个表示间距。如：<code>stroke-dasharray = &#39;10, 5&#39;</code>表示：虚线长10，间距5，然后重复 虚线长10，间距5。如：<code>stroke-dasharray = &#39;20, 10, 5&#39;</code>表示：虚线长20，间距10，虚线长5，接着是间距20，虚线10，间距5，之后开始如此循环。</p>
</li>
<li><p><code>stroke-dashoffset</code>：<code>offset</code>是偏移的意思，因此这个属性是相对于起始点的偏移。偏移x值为正数时，表示向左移动了x个长度单位，偏移x值为负数时，表示向右移动了x个长度单位。</p>
</li>
</ul>
<p>需要注意的是，不管偏移的方向是哪一边，<code>dasharray</code>是循环的，也就是：虚线-间隔-虚线-间隔。<code>dashoffset</code>属性需要搭配<code>dasharray</code>属性才能看得出效果，因为不是虚线的话是无法看出偏移的。</p>
<br>



<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h1><p>举一下MDN的例子，图中的红线段表示偏移的距离：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201226091709.png" alt></p>
<p>上图效果分别是：</p>
<ol>
<li>没有虚线</li>
<li><code>stroke-dasharray=&quot;3 1&quot;</code> ，虚线没有设置偏移，也就是<code>stroke-dashoffset</code>值为0</li>
<li><code>stroke-dashoffset=&quot;3&quot;</code>，偏移正数，虚线整体左移了3个单位，图中3后面的红线段，就是起始线段，线段之后是1个单位的间隔，我们可见区域从这个间隔开始，然后循环 3-1,3-1的虚线-间隔-虚线-间隔</li>
<li><code>stroke-dashoffset=&quot;-3&quot;</code>，偏移负数，虚线整体右移动了3个单位，由于<code>dasharray</code>是循环的，前面偏移的位置会有<code>dasharray</code>填充上</li>
<li><code>stroke-dashoffset=&quot;1&quot;</code>，偏移正数，虚线整体左移了1个单位，最终呈现出来的效果跟线段4 一样</li>
</ol>
<p>（红色部分是我们看不见的部分，是可视区域或者偏移导致的）</p>
<br>



<h1 id="进度条效果"><a href="#进度条效果" class="headerlink" title="进度条效果"></a><strong>进度条效果</strong></h1><h2 id="线性进度条"><a href="#线性进度条" class="headerlink" title="线性进度条"></a><strong>线性进度条</strong></h2><p>实现这样一个动画：线段从无到有，由短变长</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/1312697-20190618114824197-199415331.gif" alt="img"></p>
<p>实现思路是：</p>
<ol>
<li><p>设置<code>stroke-dasharray</code>虚线长度等于当前<code>svg</code>的宽度，间隔大于或者等于<code>svg</code>宽度</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg &gt; 　　</span><br><span class="line">&lt;line id=<span class="string">"line"</span> x1=<span class="string">"30"</span> y1=<span class="string">"30"</span> x2=<span class="string">"300"</span> y2=<span class="string">"30"</span> stroke-width=<span class="string">"20"</span> stroke=<span class="string">"red"</span> stroke-dasharray=<span class="string">"300,320"</span>/&gt; </span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时候我们可以在可视区域内看到一条红色的实线（因为间隔不在可视区域内）：</p>
</li>
</ol>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201226091915.png" alt></p>
<ol start="2">
<li>设置stroke左移300（即<strong><code>stroke-dashoffset: 300</code></strong>），这样就刚好隐藏了虚线，可视区域看到的是320的间隔（其实应该是270的间隔，因为可视区域只有270）：</li>
</ol>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201226091933.png" alt></p>
<ol start="3">
<li><p>当鼠标移入的时候，使offset由300变为0，就实现图中的效果了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">svg</span><span class="selector-pseudo">:hover</span> <span class="selector-id">#line</span>&#123;</span><br><span class="line">    <span class="attribute">stroke-dashoffset</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#line</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="圆形进度条"><a href="#圆形进度条" class="headerlink" title="圆形进度条"></a>圆形进度条</h2><p>实现思路和上面是类似的，设置<code>stroke-dasharray</code>虚线长度等于当前圆的周长，间隔大于或等于圆的周长。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/1312697-20190618115412705-1014505699.gif" alt="img"></p>
<p>实现思路：</p>
<ol>
<li><p>先画一个圆</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;svg  width=<span class="string">"200"</span> height=<span class="string">"200"</span> viewBox=<span class="string">"0 0 200 200"</span>&gt;    </span><br><span class="line">&lt;circle id=<span class="string">"circle"</span> cx=<span class="string">"100"</span> cy=<span class="string">"80"</span> r=<span class="string">"50"</span>  fill=<span class="string">"gray"</span> stroke-width=<span class="string">"5"</span> stroke=<span class="string">"green"</span> /&gt; </span><br><span class="line">&lt;<span class="regexp">/svg&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201226092002.png" alt></p>
<ol start="2">
<li><p>设置<code>stroke-dasharray</code>和<code>stroke-dashoffset</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#circle</span>&#123;      </span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">2s</span>;</span><br><span class="line">    stroke-dasharray:314,314; // 周长为2πr</span><br><span class="line">    stroke-dashoffset:314; // 相当于左移了314，虚线部分则不在可视区域内</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><code>hover</code>时，设置<code>stroke-dashoffset</code>为0，将虚线部分又展示到可视区域内，注意圆的stroke起始位置为右侧中间</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">svg</span><span class="selector-pseudo">:hover</span> <span class="selector-id">#circle</span>&#123;     </span><br><span class="line">    <span class="attribute">stroke-dashoffset</span>:<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/1312697-20190618115412705-1014505699.gif" alt="img"></p>
<p>因此，如果我们想让圆从上方中点开始，需要将圆逆时针旋转90度（rotate(-90deg)）:</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201226092030.png" alt></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-class">.progress-bar</span> &#123;       </span><br><span class="line">    <span class="attribute">transform</span>: scale (<span class="number">0.9</span>) rotate (-<span class="number">90deg</span>);       </span><br><span class="line">    <span class="attribute">stroke</span>: $&#123;style [<span class="string">"theme-color"</span>]&#125;;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>



<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h1><p>用<code>svg</code>的<code>stroke-dasharray</code>和<code>stroke-dashoffset</code>实现进度条效果适用于：不会人为拖动进度条的场景，比如通过<code>props</code>传入百分比控制<code>dashoffset</code>的位置。</p>
<p>因为在人为拖动进度条的场景下，一般需要有拖动按钮，需要为拖动按钮绑定用户的<code>touchStart</code>，<code>touchMove</code>，<code>touchEnd</code>事件，这些在<code>svg</code>上是不可行的。</p>
<p>在人为拖动进度条的场景下，只能乖乖用<code>div</code>去画进度条，例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ProgressBarWrapper&gt;</span><br><span class="line">    &lt;div className=<span class="string">"bar-inner"</span> </span><br><span class="line">        ref=&#123;progressBar&#125;</span><br><span class="line">        onClick=&#123;progressClick&#125;</span><br><span class="line">     &gt;</span><br><span class="line">     &lt;div className=<span class="string">"progress"</span> ref=&#123;progress&#125;&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">     &lt;div className="progress-btn-wrapper"</span></span><br><span class="line"><span class="regexp">         ref=&#123;progressBtn&#125;</span></span><br><span class="line"><span class="regexp">         onTouchStart=&#123;progressTouchStart&#125;</span></span><br><span class="line"><span class="regexp">         onTouchMove=&#123;progressTouchMove&#125;</span></span><br><span class="line"><span class="regexp">         onTouchEnd=&#123;progressTouchEnd&#125;</span></span><br><span class="line"><span class="regexp">      &gt;</span></span><br><span class="line"><span class="regexp">      	&lt;div className="progress-btn"&gt;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/ProgressBarWrapper&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ProgressBarWrapper</code>为整个进度条的容器，<code>bar-inner</code>是进度条的背景（100%），<code>progress</code>是当前进度（可变），<code>progress-btn-wrapper</code>是拖动按钮容器，<code>progress-btn</code>是拖动按钮。</p>
<p>可以看到此时进度条有拖动事件（<code>touch</code>）和点击事件（<code>click</code>），这两个事件的处理是不同的。</p>
<p><code>touch</code>事件处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _offset = <span class="function">(<span class="params">offsetWidth</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置进度条长度为offsetWidth，按钮的x偏移量为offsetWidth</span></span><br><span class="line">    progress.current.style.width = <span class="string">`<span class="subst">$&#123;offsetWidth&#125;</span>px`</span>;</span><br><span class="line">    progressBtn.current.style.transform = <span class="string">`translate3d($    &#123;offsetWidth&#125;px, 0, 0)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录开始位置和当前进度条宽度</span></span><br><span class="line"><span class="keyword">const</span> progressTouchStart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> startTouch = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示滑动动作开始</span></span><br><span class="line">    startTouch.initiated = <span class="literal">true</span>;</span><br><span class="line">    startTouch.startX = e.touches[<span class="number">0</span>].pageX;</span><br><span class="line">    startTouch.left = progress.current.clientWidth;</span><br><span class="line">    setTouch(startTouch);  <span class="comment">// touch是一个state状态</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> progressTouchMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!touch.initiated) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// deltaX记录移动距离</span></span><br><span class="line">    <span class="keyword">const</span> deltaX = e.touches[<span class="number">0</span>].pageX - touch.startX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度条净宽度 = 进度条宽度 - 按钮宽度</span></span><br><span class="line">    <span class="keyword">const</span> barWidth = progressBar.current.clientWidth -         progressBtnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制offsetWidth大小使得进度条长度和按钮位置在最小（0）和最大（barWidth）范围之内</span></span><br><span class="line">    <span class="keyword">const</span> offsetWidth = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.max(<span class="number">0</span>, touch.left + deltaX), barWidth);</span><br><span class="line">    _offset(offsetWidth)；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>click</code>点击事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击事件（与前面的拖动事件效果不同）</span></span><br><span class="line"><span class="keyword">const</span> progressClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 进度条当前长度，getBoundingClientRect可获取DOM元素到浏览器可视范围的距离</span></span><br><span class="line">    <span class="keyword">const</span> rect = progressBar.current.getBoundingClientRect();</span><br><span class="line">    <span class="keyword">const</span> offsetWidth = e.pageX - rect.left;</span><br><span class="line">    _offset(offsetWidth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/bar.png" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>云服务器部署node.js egg项目</title>
    <url>/2021/02/21/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node-js-egg%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<blockquote>
<p>最近在做毕业设计，用egg+mysql+sequelize+taro写一个小程序，因为没有用到微信的云开发，是自己搭建的后台，所以需要将后台项目部署到云服务器上。整个过程踩了不少坑，于是想写个流程以防忘记。</p>
</blockquote>
<h2 id="云服务器准备"><a href="#云服务器准备" class="headerlink" title="云服务器准备"></a>云服务器准备</h2><h3 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h3><p>可在腾讯云购买轻量应用服务器，学生的话可以购买校园云服务器，规格是cpu1核，内存2GB，系统盘40GB，对于我的项目来说应该够用了：<br><a href="https://cloud.tencent.com/act/campus?fromSource=gwzcw.1110252.1110252.1110252&gclid=Cj0KCQiA4L2BBhCvARIsAO0SBdb7oOpn-mxK3fRq6pa841xfw9l8An7-ViduP8BaQNyJHA6tNFlJ5BUaAhbMEALw_wcB" target="_blank" rel="noopener">腾讯云校园云服务器</a><br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/c01c8d4516e1a750d549a4cc89722943.png" alt></p>
<h3 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h3><p>微信小程序官方文档中表明，服务器域名只支持https，且不能使用ip地址，所以我们需要注册域名。</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/688aea7d208a7aef956f1239d4e3abb2.png" alt></p>
<p>域名购买完成后，需要实名认证，实名认证完成后才能进行下一步解析。</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/c72801f7c37de45abd73663643986b91.png" alt></p>
<p>不和ip配套使用的域名是没有任何意义的，所以我们需要将域名绑定到我们需要对外提供服务的服务器ip上。因此我们点击域名的解析操作，添加解析到你之前购买的服务器的ip上：</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/b9ed96b9e6a9c630e919181ba4d7b286.png" alt></p>
<p>可以到轻量云服务器控制台查看之前购买的云服务器的公网ip：</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/7fa69db8860a51762fce954b135b46dd.png" alt></p>
<h3 id="申请SSL证书"><a href="#申请SSL证书" class="headerlink" title="申请SSL证书"></a>申请SSL证书</h3><p>上面提到，微信小程序官方规定域名必须是https，所以我们需要申请ssl证书，腾讯云可以免费申请ssl证书，证书也要添加到域名解析记录中：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/c3295fe949f13f8714f12ec7b765ce14.png" alt><br>证书申请成功后先下载下来，以备后续使用：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/3fa785df4f7d08b7b864985a646142f8.png" alt><br>证书下载下来后会有多种，我们后续会使用到nginx的证书。</p>
<p>以上就完成好云服务器的准备工作了。<br><br></p>
<h2 id="云服务器环境部署"><a href="#云服务器环境部署" class="headerlink" title="云服务器环境部署"></a>云服务器环境部署</h2><p>根据项目需求，我们要在云服务器上安装node、MySQL、nginx。</p>
<h3 id="连接远程服务器"><a href="#连接远程服务器" class="headerlink" title="连接远程服务器"></a>连接远程服务器</h3><p> 连接远程服务器的意义在于，我们能够在本地对远程服务器进行操作，比如文件上传、安装包。这里我们需要安装两个应用：XShell和Xftp，XShell一般用于对远程服务器进行操作，Xftp一般用于文件上传。</p>
<p>XShell和Xftp安装配置参考博客：<a href="https://blog.csdn.net/ctrlxv/article/details/79054941" target="_blank" rel="noopener">新手搭建云服务器详细过程</a></p>
<p>安装好以上两个应用后就可以开始环境部署了。</p>
<h3 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h3><p>以下步骤均在XShell中执行。</p>
<h4 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、下载node二进制安装包</span><br><span class="line">  wget https://nodejs.org/dist/v10.13.0/node-v10.13.0-linux-x64.tar.xz</span><br><span class="line">2、解压</span><br><span class="line">  tar xvf node-v10.13.0-linux-x64.tar.xz</span><br><span class="line">3、创建软链接，使node和npm全局有效</span><br><span class="line">  ln -s /root/node-v10.13.0-linux-x64/bin/node /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line">  ln -s /root/node-v10.13.0-linux-x64/bin/npm /usr/<span class="built_in">local</span>/bin/npm</span><br><span class="line">4、查看node和npm版本，如果显示版本号，说明安装成功</span><br><span class="line">  node -v</span><br><span class="line">  npm -v</span><br><span class="line">5、软件默认安装在/root/node-v10.13.0-linux-x64/目录下</span><br></pre></td></tr></table></figure>
<p>按照这个步骤node可以成功，但npm会出现问题，因此后续我改用nvm安装node。</p>
<p>安装nvm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash</span><br><span class="line">或者</span><br><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>安装node，注意：如果你已经安装了node，不用卸载旧的，直接安装就好，nvm会替你管理版本的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install node</span><br></pre></td></tr></table></figure>
<p>此时再输入<code>node -v</code>和<code>npm -v</code>都显示对应版本，表明安装成功。<br><br></p>
<h4 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h4><h5 id="安装yum-repo"><a href="#安装yum-repo" class="headerlink" title="安装yum repo"></a>安装yum repo</h5><p>由于CentOS的yum源中没有MySQL，需要到MySQL的官网下载yum repo配置文件。<br>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>然后进行repo的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-9.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>执行完成后会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo。</p>
<h5 id="使用yum命令完成MySQL安装"><a href="#使用yum命令完成MySQL安装" class="headerlink" title="使用yum命令完成MySQL安装"></a>使用yum命令完成MySQL安装</h5><p>必须进入<code>/etc/yum.repos.d/</code>目录后再执行以下脚本。</p>
<ol>
<li>安装命令：<code>yum install mysql-server</code></li>
<li>启动MySQL：<code>systemctl start mysqld</code></li>
<li>获取安装时的临时密码（在第一次登陆时就是用这个密码）：<code>grep &#39;temporary password&#39; /var/log/mysqld.log</code></li>
</ol>
<h5 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h5><p>执行<code>mysql -u root -p</code>指令，然后输入密码（刚刚获取的临时密码）。</p>
<h5 id="登陆成功后修改密码"><a href="#登陆成功后修改密码" class="headerlink" title="登陆成功后修改密码"></a>登陆成功后修改密码</h5><p>修改密码时，MySQL会进行密码强度校验，不满足校验时会报异常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure>
<p>但我们通常想设置更为简单的密码，这里需要执行以下步骤：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> global validate_password_policy=0; </span><br><span class="line"><span class="built_in">set</span> global validate_password_length=4; </span><br><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>
<p>这样我们就将MySQL的密码改为简单的123456了。</p>
<p>以上就完成好MySQL的安装。</p>
<h5 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h5><p>因为之前是在本地进行前后端联调，数据都存储在本地的数据库中，所以需要将本地的数据导入云服务器的数据库中。</p>
<p><strong>step1</strong>：<br>将本地数据库信息导出为.sql文件。cmd进入终端，执行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p miniprogram &gt; C:\Users\alice\miniprogram.sql</span><br></pre></td></tr></table></figure>
<p>我的数据库名称为miniprogram，导出的.sql文件的名称也要叫miniprogram，导出到一个你可以找到的位置。</p>
<p><strong>step2</strong>：<br>在云服务器中也创建一个名字相同的数据库。在XShell中输入<code>mysql -u root -p</code>输入密码登录进去。<br>新建一个和文件相同名称的数据库（输入sql语句时不要漏了分号）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create database miniprogram;</span><br></pre></td></tr></table></figure>
<p>进入数据库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use miniprogram;</span><br></pre></td></tr></table></figure>
<p>设置数据库编码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> names utf8;</span><br></pre></td></tr></table></figure>


<p><strong>step3</strong>：<br>将miniprogram.sql文件通过Xftp上传到云服务器上。我是现在root文件夹下新建user文件夹，并将.sql文件传输过去：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/a14a1b55acf8bf4b76b9d1e73f547185.png" alt></p>
<p><strong>step4</strong>：<br>第二步已经登录数据库，此处只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /root/user/miniprogram.sql;</span><br></pre></td></tr></table></figure>
<p>即可导入成功。</p>
<p>可以后续进入数据库查看是否有对应的表判断是否导入成功（指令：<code>show databases;</code>、<code>use miniprogram;</code>）。<br><br></p>
<h4 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h4><p>执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nginx</span><br></pre></td></tr></table></figure>
<p>安装完后输入<code>nginx -v</code>，若显示nginx版本号则表示安装成功。<br><br></p>
<h4 id="上传SSL证书"><a href="#上传SSL证书" class="headerlink" title="上传SSL证书"></a>上传SSL证书</h4><p>在服务器新建目录: /data/release/nginx（/data文件本身存在，只需在里面新建release文件夹和nginx文件夹即可）</p>
<p>使用xftp将证书上传到该文件夹下：</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/fdc295822acd923dea56e3fb536cd6c1.png" alt></p>
<p>上传后在服务器上查询：</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/20210221110315475.png" alt="在这里插入图片描述"></p>
<p>上传完证书后就可以开始配置nginx。进入服务器的/etc/nginx/conf.d目录，新建一个weapp.conf文件，将文件拷贝到本地，打开编辑，写入如下配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream app_weapp &#123;</span><br><span class="line">    server localhost:7001; // 你的项目服务端启动的地址</span><br><span class="line">    keepalive 8;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;</span><br><span class="line">    server_name www.miniprogram.ltd; // 你的域名</span><br><span class="line"> </span><br><span class="line">    rewrite ^(.*)$ https://<span class="variable">$server_name</span><span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen      443;</span><br><span class="line">    server_name www.miniprogram.ltd; // 你的域名</span><br><span class="line"> </span><br><span class="line">    ssl on;</span><br><span class="line"> </span><br><span class="line">    ssl_certificate           /data/release/nginx/1_miniprogram.ltd_bundle.crt; //你的证书</span><br><span class="line">    ssl_certificate_key       /data/release/nginx/2_miniprogram.ltd.key; // 你的证书</span><br><span class="line">    ssl_session_timeout       5m;</span><br><span class="line">    ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers               ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;</span><br><span class="line">    ssl_session_cache         shared:SSL:50m;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app_weapp;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">        proxy_set_header Connection <span class="string">'upgrade'</span>;</span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_cache_bypass <span class="variable">$http_upgrade</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>nginx配置的upstream主要是实现负载均衡的效果。<br>简单来说就是：upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>所以实际上你向域名发起请求，是会被转发到云服务器的后端服务器上的。详情可参考博客：<a href="https://www.cnblogs.com/muhy/p/10528449.html" target="_blank" rel="noopener">nginx使用upstream实现负载均衡</a>。</p>
<p>修改好后将该文件上传至/etc/nginx/conf.d目录下，然后再XShell中输入nginx -t，如显示以下信息，则配置成功：</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/2021022112295142.png" alt="在这里插入图片描述"></p>
<p>配置成功后，输入nginx回车，即可启动nginx。此时通过配置的域名访问服务器（<a href="http://www.miniprogram.ltd），会显示Nginx详情页。" target="_blank" rel="noopener">http://www.miniprogram.ltd），会显示Nginx详情页。</a></p>
<p>如果访问 http://你的域名/weapp/a 会自动跳转到 HTTPS 上，并显示 502 Bad Gateway，则表示配置成功：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/20210221123436197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk3MzQxMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果上传的weapp.conf文件发生了修改，需要重启nginx：<code>nginx -s reload</code>。</p>
<p>如果出现<code>nginx: [emerg] bind() to [::]:80 failed (98: Address already in use)</code>的报错，可以执行<code>netstat -ntpl</code>指令查看进程，将占用80端口的进程kill掉，或执行<code>fuser -n tcp 80</code>直接查看占用80端口的进程有哪些，依次kill掉即可。<br><br></p>
<p>至此云服务器的环境已经完全搭建好了。<br><br></p>
<h3 id="将服务端项目上传至云服务器"><a href="#将服务端项目上传至云服务器" class="headerlink" title="将服务端项目上传至云服务器"></a>将服务端项目上传至云服务器</h3><p>在服务器端创建目录/data/release/weapp（和上面存放nginx证书同目录），将服务端代码通过xftp传输到云服务器上（记得不要传node_modules）：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/b9e278751a68db8649f93a7b876979d9.png" alt></p>
<p>注意服务端数据库项目的配置部分，项目中用到sequelize构建数据库，需将配置的用户名和密码改为云服务器端MySQL的用户名和密码：</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/8f8aa0e05d212b7c0cf0f0cbbd61749e.png" alt></p>
<p>上传完后，执行以下指令将npm源切换到淘宝镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装全局依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure>
<p>启动服务端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/3157bd94e8bb0ca5865452702b8b9f00.png" alt></p>
<p>服务端项目启动成功。</p>
<br>


<h3 id="云服务器防火墙开放7001端口"><a href="#云服务器防火墙开放7001端口" class="headerlink" title="云服务器防火墙开放7001端口"></a>云服务器防火墙开放7001端口</h3><p>此步骤很关键，否则无法访问服务端接口。在腾讯云轻量云服务器防火墙处添加规则，开放7001端口：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/194f2977aa307742921ab084fcbb7922.png" alt></p>
<p>因为目前域名还未备案成功，所以不能通过域名进行访问。此时只需启动mysql和服务端项目，不需要启动nginx来测试服务端接口：<br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/37fb83a790e7d07678175c1286b75b77.png" alt><br><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/img_convert/0c9e660c76d51628d13d130eaea26583.png" alt></p>
<h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>因为微信小程序官方文档中表明，服务器域名只支持https，且不能使用ip地址，所以我们需要注册域名的同时，还需要进行域名备案，这样才能正常访问服务端的接口。<br>域名备案流程大概是十多天左右，在此期间需要将域名解析暂停。我是在腾讯云上进行备案的，还挺顺利。</p>
<p>备案完成后，进入云服务器，启动MySQL、nginx、项目，然后就可以顺利访问了：<br><img src="/images/loading.png" data-original="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d30db18f261e45e18f734aece2b3d3dd~tplv-k3u1fbpfcp-watermark.image" alt></p>
<p>有几点需要注意：</p>
<ul>
<li>此时不需要像用ip访问后台一样输入端口号了，域名前是http或https均可，因为nginx会将http重定向为https</li>
</ul>
<h2 id="后续踩坑"><a href="#后续踩坑" class="headerlink" title="后续踩坑"></a>后续踩坑</h2><h3 id="部分接口无法访问"><a href="#部分接口无法访问" class="headerlink" title="部分接口无法访问"></a>部分接口无法访问</h3><p>在访问接口过程中发现，有些接口能够正常访问，有些接口却不能，导致我一度怀疑是不是egg的问题。</p>
<p>后来发现是远程数据库的数据没有更新！当我们在本地开发的时候，通常是连接本地的数据库，但是我们向后台请求数据时，后台是在云服务器上的，它请求的是云服务器上的MySQL数据库。因此，我们需要再一次将本地数据库导出成sql文件，导入云服务器的数据库中。</p>
<p>egg项目更新后也要重新上传至云服务器。</p>
<h3 id="debeaver连接远程数据库报错"><a href="#debeaver连接远程数据库报错" class="headerlink" title="debeaver连接远程数据库报错"></a><code>debeaver</code>连接远程数据库报错</h3><p>如果每次数据有变更都要将本地数据库的sql导出再导入远程数据库，就十分麻烦，但直接在<code>XShell</code>中操作远程数据库，在非可视化的界面输入各种数据库操作执行也十分繁琐，所以我们可以用<code>debeaver</code>连接远程数据库（<code>debeaver</code>既可以连接本地数据库也可以连接远程数据库进行操作）。</p>
<p>但是按照本地数据库的链接方式来连接远程数据库时，会出现以下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message from server: &quot;Host &#39;221.4.34.96&#39; is not allowed to connect to this MySQL server&quot;</span><br></pre></td></tr></table></figure>



<p>这是权限问题导致的，我们可以在远程数据库中修改对<code>Host &#39;221.4.34.96&#39;</code>的权限来解决：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/image-20210309112048949.png" alt></p>
<p>将其中的<code>123.123.123.123</code>改为你的<code>debeaver</code>ip：<code>221.4.34.96</code>。</p>
<p>在这个过程中可能涉及密码不符合要求的问题，可以修改密码强度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前安全变量值</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;validate_password%&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置</span><br><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;4;</span><br></pre></td></tr></table></figure>

<p>这样就能够将123456作为你的密码。</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是跨域以及跨域解决方案</title>
    <url>/2020/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在介绍跨域前，先介绍浏览器的一个重要的安全策略——同源策略。</p>
<blockquote>
<p><strong>在文中，web 端地址为 localhost:8000 服务端地址为 localhost:8080</strong></p>
</blockquote>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><ul>
<li>同源策略是浏览器的一个安全功能，它是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器很容易受到XSS和CSFR等攻击。</li>
<li>同源指的是：协议，域名，端口号都相同</li>
<li>同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源</li>
</ul>
<br>

<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域是指一个源下的文档或脚本试图去请求另一个源下的资源。</p>
<p>常见的跨域场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;b.js         同一域名，不同文件或路径           允许</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;lab&#x2F;c.js</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.domain.com:8000&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;b.js         同一域名，不同端口                不允许</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">https:&#x2F;&#x2F;www.domain.com&#x2F;b.js        同一域名，不同协议                不允许</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;192.168.4.12&#x2F;b.js           域名和域名对应相同ip              不允许</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;x.domain.com&#x2F;b.js           主域相同，子域不同                不允许</span><br><span class="line">http:&#x2F;&#x2F;domain.com&#x2F;c.js</span><br><span class="line"> </span><br><span class="line">http:&#x2F;&#x2F;www.domain1.com&#x2F;a.js</span><br><span class="line">http:&#x2F;&#x2F;www.domain2.com&#x2F;b.js        不同域名                        不允许</span><br></pre></td></tr></table></figure>

<br>

<h2 id="为什么会出现跨域"><a href="#为什么会出现跨域" class="headerlink" title="为什么会出现跨域"></a>为什么会出现跨域</h2><p>归结于前后端分离这种架构设计和开发模式。前端开发人员只需负责将页面设计做好，后端开发人员只需将后端逻辑写好，这样降低了前端和后端程序员的门槛，也提升了开发效率。那在开发过程中，前后端需要进行联调，才能对各种功能进行测试。但在前后端分离的模式下，前后端的域名是不一致的，此时浏览器向服务器发起请求的时候就会发生跨域的问题。</p>
<br>

<h2 id="为什么需要跨域"><a href="#为什么需要跨域" class="headerlink" title="为什么需要跨域"></a>为什么需要跨域</h2><h3 id="限制不同源的请求"><a href="#限制不同源的请求" class="headerlink" title="限制不同源的请求"></a>限制不同源的请求</h3><p>比如用户登录a网站，同时新开tab打开了b网站，如果不限制同源，b可以像a网站发起任何请求，会让不法分子有机可趁。</p>
<h3 id="限制dom操作"><a href="#限制dom操作" class="headerlink" title="限制dom操作"></a>限制dom操作</h3><p>如果现在有一个和百度很类似的网站叫：<code>www.baidu1.com</code>。我们先登录一下百度，然后访问这个<code>www.baidu1.com</code>。如果可以进行dom操作（例如：<code>document.cookie</code>）的话，大家的信息在这些钓鱼网站上会被轻松获取。</p>
<br>



<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201206165534.png" alt></p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin（domain）上的web应用被准许访问来自不同源服务器上的指定的资源。当这个web应用向一个与之不同域、协议或端口号的服务器请求资源的时候，就会发起一个跨域请求。</p>
<p>CORS中的请求分为两种：简单请求和非简单请求。</p>
<p>简单请求，例如请求方法为HEAD，GET，POST；非简单请求，例如：PUT，DELETE。</p>
<p>浏览器对这两种请求的处理是不一样的。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><ul>
<li>如果浏览器发现这次跨域请求是简单请求，就自动在头信息中添加一个<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源。服务器会根据这个值决定是否同意这次请求。</li>
<li>如果服务器同意这次请求的话，就会在响应报文加入头字段<code>Access-Control-Allow-Origin</code>。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接收任意域名的请求。</li>
</ul>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><ul>
<li>预检请求：浏览器如果发现此次请求是一个非简单请求的话，就自动发出一个预检请求。<strong>预检请求用的请求方法是<code>OPTIONS</code></strong>，表示这个请求是用来询问服务器，当前网页所在域名是否在服务器的许可名单之中，以及可以使用哪些HTTP头字段。在这个报文中还会带有<code>Access-Control-Request-Method</code>字段，表示CORS请求中使用的http方法是什么，比如<code>PUT</code>；还有<code>Access-Control-Request-Headers</code>，指定浏览器CORS请求会额外发送的头信息字段。</li>
<li>预检请求的回应：服务器在收到预检请求之后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨域请求，就可以做出回应。回应的关键字段也是<code>Access-Control-Allow-Origin</code>。</li>
</ul>
<p>想要携带cookie需要满足3个条件：</p>
<ol>
<li>客户端设置<code>withCredentials</code>属性为true，例如在<code>axios</code>中的设置方式为：<code>axios.defaults.withCredentials = true</code></li>
<li>服务器端添加<code>Access-Control-Allow-Credentials: true</code></li>
<li>服务器端配置的<code>Access-Control-Allow-Origin</code>为非*</li>
</ol>
<h3 id="Node的跨域解决例子"><a href="#Node的跨域解决例子" class="headerlink" title="Node的跨域解决例子"></a>Node的跨域解决例子</h3><h4 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Origin"</span>, ctx.headers.origin);</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.set(<span class="string">"Access-Control-Request-Method"</span>, <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  ctx.set(</span><br><span class="line">    <span class="string">"Access-Control-Allow-Headers"</span>,</span><br><span class="line">    <span class="string">"Origin, X-Requested-With, Content-Type, Accept, cc"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (ctx.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    ctx.status = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">"koa-cors"</span>);</span><br><span class="line"></span><br><span class="line">app.use(cors());</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Node正向代理"><a href="#Node正向代理" class="headerlink" title="Node正向代理"></a>Node正向代理</h2><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点（代理服务器）同域。</p>
<p>代理前：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201206171719.png" alt></p>
<p>代理后：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201206171734.png" alt></p>
<h3 id="cli工具中的代理"><a href="#cli工具中的代理" class="headerlink" title="cli工具中的代理"></a>cli工具中的代理</h3><h4 id="Webpack（4-x）"><a href="#Webpack（4-x）" class="headerlink" title="Webpack（4.x）"></a>Webpack（4.x）</h4><p>在<code>webpack</code>中可以配置<code>proxy</code>来快速获得接口代理的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">"./index.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">"/api"</span>: &#123;</span><br><span class="line">        target: <span class="string">"http://localhost:8080"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">"index.html"</span>,</span><br><span class="line">      template: <span class="string">"webpack.html"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">"getlist"</span>&gt;获取列表&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="login"&gt;登录&lt;/</span>button&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/axios/0.19.2/axios.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  axios.defaults.withCredentials = true;</span></span><br><span class="line"><span class="regexp">  getlist.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    axios.get("/</span>api/corslist<span class="string">").then(res =&gt; &#123;</span></span><br><span class="line"><span class="string">      console.log(res.data);</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  login.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">    axios.post("</span>/api/login<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>



<p>因为前端现在是向<code>webpack</code>的<code>devServer</code>发起请求，所以不需要带域名(也就是<code>http://localhost:8080</code>)，<code>devServer</code>会自动转发给目标服务器地址<code>http://localhost:8080</code>。</p>
<h4 id="Vue-cli-2-x"><a href="#Vue-cli-2-x" class="headerlink" title="Vue-cli 2.x"></a>Vue-cli 2.x</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/index.js</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">proxyTable: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">     target: <span class="string">'http://localhost:8080'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="Vue-cli-3-x"><a href="#Vue-cli-3-x" class="headerlink" title="Vue-cli 3.x"></a>Vue-cli 3.x</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 如果没有就新建</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">"/api"</span>: &#123;</span><br><span class="line">        target: <span class="string">"http://localhost:8080"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="Parcel（2-x）"><a href="#Parcel（2-x）" class="headerlink" title="Parcel（2.x）"></a>Parcel（2.x）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .proxyrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"/api"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"http://localhost:8080"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上配置方式虽多，但都是有着共同的底层包http-proxy-middleware。里面需要用到的各种websocket，rewrite等功能，直接看这个库的配置即可。搜索技巧就是，想要那个框架直接google xxx proxy即可，官网有配置答案。</p>
<br>

<h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>Nginx则是通过反向代理的方式，这里需要自定义一个域名。这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。</p>
<p><code>nginx</code>安装教程：<a href="https://blog.csdn.net/diaojw090/article/details/89135073" target="_blank" rel="noopener">https://blog.csdn.net/diaojw090/article/details/89135073</a></p>
<p>配置<code>hosts</code>：127.0.0.1 <code>local.test</code></p>
<p>配置<code>nginx</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen <span class="number">80</span>;</span><br><span class="line">        server_name local.test;</span><br><span class="line">        location /api &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//localhost:8080;</span></span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//localhost:8000;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<code>nginx</code>：<code>sudo nginx</code></p>
<p>重启<code>nginx</code>：<code>sudo nginx -s reload</code></p>
<p>前端代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  axios.defaults.withCredentials = <span class="literal">true</span>;</span><br><span class="line">  getlist.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    axios.get(<span class="string">"/api/corslist"</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  login.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    axios.post(<span class="string">"/api/login"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  axios.defaults.withCredentials = <span class="literal">true</span>;</span><br><span class="line">  getlist.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    axios.get(<span class="string">"/api/corslist"</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  login.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    axios.post(<span class="string">"/api/login"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<p>疑惑：为什么客户端访问nginx反向代理服务器不会跨域，domain都不一样。。</p>
<h3 id="用nginx反向代理解决跨域"><a href="#用nginx反向代理解决跨域" class="headerlink" title="用nginx反向代理解决跨域"></a>用<code>nginx</code>反向代理解决跨域</h3><blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_34020571/article/details/80597136" target="_blank" rel="noopener">https://blog.csdn.net/qq_34020571/article/details/80597136</a></p>
</blockquote>
<p>第一步：配置<code>nginx.config</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       <span class="number">8000</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"> </span><br><span class="line">        #charset koi8-r;</span><br><span class="line"> </span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">		</span><br><span class="line">		location / &#123;</span><br><span class="line">			root	E:<span class="regexp">/h5;    #h5项目路径</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp">		</span></span><br><span class="line">		location /urm &#123;    #代理的接口路径</span><br><span class="line">			 proxy_pass   http:<span class="comment">//192.168.1.111:9003/urm;</span></span><br><span class="line">                        proxy_set_header Host $host;</span><br><span class="line">                        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                        add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">                        add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">                        add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">                        add_header <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		location = <span class="regexp">/favicon.ico &#123;</span></span><br><span class="line"><span class="regexp">			log_not_found off;</span></span><br><span class="line"><span class="regexp">			access_log off;</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure>



<p>第二步：启动后端服务器，启动<code>nginx</code></p>
<p>第三步：修改前端<code>ajax</code>访问的<code>url</code></p>
<p>从<code>http://192.168.1.111:9003/urm</code> —&gt; <code>http://192.168.1.111:8000/urm</code></p>
<p>第四步：访问前端项目</p>
<p><code>http://192.168.1.111:8000/agent/merchant_manage.html</code></p>
<blockquote>
<p>正向代理和反向代理的区别</p>
<p>参考链接：<a href="https://blog.csdn.net/m13666368773/article/details/8060481" target="_blank" rel="noopener">https://blog.csdn.net/m13666368773/article/details/8060481</a></p>
<ul>
<li>正向代理：客户端知道服务端，通过代理端连接服务端。代理端代理的是服务端。</li>
<li>反向代理：所谓反向，是对正向而言的。服务端知道客户端，客户端不知道服务端，通过代理端连接服务端。代理端代理客户端。代理对象恰好相反，故名为反向代理。</li>
</ul>
</blockquote>
<br>

<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p><code>JSONP</code>主要是利用了<code>script</code>标签没有跨域限制的特性来完成的。</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>仅支持<code>GET</code>方法，如果想要使用完整的<code>REST</code>接口，请使用<code>CORS</code>或者其他代理方式。</p>
<h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><ol>
<li>前端定义回调函数（例如 <code>jsonpCallback=function(){....}</code>）</li>
<li>通过<code>params</code>形式包装请求参数，并且声明执行函数（例如：<code>cb=jsonpCallback</code>）</li>
<li>后端获取前端声明的执行函数（<code>jsonpCallback</code>），并以带上参数和调用执行函数的方式传递给前端</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>后端实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.path === <span class="string">"/api/jsonp"</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; cb, msg &#125; = ctx.query;</span><br><span class="line">    ctx.body = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; msg &#125;</span>)&#125;)`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>前端普通<code>js</code>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="built_in">window</span>.jsonpCallback = <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script</span></span><br><span class="line"><span class="regexp">  src="http:/</span><span class="regexp">/localhost:8080/</span>api/jsonp?msg=hello&amp;cb=jsonpCallback<span class="string">"</span></span><br><span class="line"><span class="string">  type="</span>text/javascript<span class="string">"</span></span><br><span class="line"><span class="string">&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>jQuery Ajax</code>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  $.ajax(&#123;</span></span><br><span class="line"><span class="regexp">    url: "http:/</span><span class="regexp">/localhost:8080/</span>api/jsonp<span class="string">",</span></span><br><span class="line"><span class="string">    dataType: "</span>jsonp<span class="string">",</span></span><br><span class="line"><span class="string">    type: "</span><span class="keyword">get</span>",</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">"hello"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    jsonp: <span class="string">"cb"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><p><code>WebSocket</code>协议是<code>html5</code>一种新的协议。在<code>WebSocket</code>协议中，<strong>客户端和服务端都可以主动地推送消息</strong>，而且没有同源策略的限制，不存在跨域问题。<strong>协议的标识符为<code>ws</code>。像https一样如果加密的话就是<code>wxs</code></strong>。</p>
<p>在 <code>WebSocket</code> API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。</p>
<p>前端部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8080"</span>);</span><br><span class="line">  socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="string">"秋风的笔记"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">"ws"</span>);</span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line">server.on(<span class="string">"connection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>本节内容代码：<a href="https://github.com/hua1995116/node-demo/tree/master/node-cors" target="_blank" rel="noopener">https://github.com/hua1995116/node-demo/tree/master/node-cors</a></p>
<p>参考：</p>
<p><a href="https://segmentfault.com/a/1190000022398875" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022398875</a></p>
<p><a href="https://blog.csdn.net/m13666368773/article/details/8060481" target="_blank" rel="noopener">https://blog.csdn.net/m13666368773/article/details/8060481</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用better-scroll创建Scroll组件</title>
    <url>/2020/04/19/%E4%BD%BF%E7%94%A8better-scroll%E5%88%9B%E5%BB%BAScroll%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>在学习《React Hooks与Immutable数据流实战》这本书的时候，其中一章讲到了使用<code>better scroll</code>打造一个<code>scroll</code>组件，花了蛮长时间去理解里面使用到的各种的方法，比如：better scroll、<code>forwardRef</code>等，在此总结一下。</p>
<h2 id="better-scroll"><a href="#better-scroll" class="headerlink" title="better-scroll"></a>better-scroll</h2><blockquote>
<p>better-scroll的基本原理：<a href="https://juejin.im/post/59300b2e2f301e006bcdd91c#heading-0" target="_blank" rel="noopener">https://juejin.im/post/59300b2e2f301e006bcdd91c#heading-0</a></p>
</blockquote>
<p>better-scroll 是一个移动端滚动的解决方案，它是基于 iscroll 的重写，它和 iscroll 的主要区别在<a href="https://github.com/ustbhuangyi/better-scroll/issues/36" target="_blank" rel="noopener">这里</a>。better-scroll 也很强大，不仅可以做普通的滚动列表，还可以做轮播图、picker 等等。</p>
<h3 id="better-scroll的滚动原理"><a href="#better-scroll的滚动原理" class="headerlink" title="better-scroll的滚动原理"></a><code>better-scroll</code>的滚动原理</h3><p>浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵向滚动条；当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。</p>
<p>那么对于 better-scroll 也是一样的道理，我们先来看一下 better-scroll 常见的 html 结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了更加直观，我们再来看一张图：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20200419144604.png" alt></p>
<p>绿色部分为 wrapper，也就是父容器，它会有<strong>固定的高度</strong>。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。</p>
<p>那么，我们怎么初始化  better-scroll 呢，如果是上述 html 结构，那么初始化代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import BScroll from &#39;better-scroll&#39;</span><br><span class="line">let wrapper &#x3D; document.querySelector(&#39;.wrapper&#39;)</span><br><span class="line">let scroll &#x3D; new BScroll(wrapper, &#123;&#125;)复制代码</span><br></pre></td></tr></table></figure>

<p>better-scroll 对外暴露了一个 <code>BScroll</code> 的类，我们初始化只需要 new 一个类的实例即可。第一个参数就是我们 wrapper 的 DOM 对象，第二个是一些配置参数，具体参考 <a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="noopener">better-scroll 的文档</a>。</p>
<p>better-scroll 的初始化时机很重要，因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动。因此，<strong>我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了</strong>。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用 <code>scroll.refresh()</code> 方法重新计算来确保滚动效果的正常。所以同学们反馈的 better-scroll 不能滚动的原因<strong>多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构发送变化的时候并没有重新计算 better-scroll</strong>。</p>
<br>



<h2 id="创建一个scroll组件"><a href="#创建一个scroll组件" class="headerlink" title="创建一个scroll组件"></a>创建一个scroll组件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 安装 better-scroll</span><br><span class="line">npm install better-scroll@next --save</span><br></pre></td></tr></table></figure>

<p>我们依然采用函数式组件的形式进行开发，不过作为一个通用组件，scroll 组件在业务中会被经常取到原生 DOM 对象，而函数式组件天生不具备被上层组件直接调用 ref 的条件，因此需要用 React 当中一些特殊的方式来处理，即使用 <code>forwardRef</code> 进行包裹。</p>
<blockquote>
<p><code>forwardRef</code>可以将子组件通过ref暴露给父组件，使得父组件可以通过ref获取到子组件的<code>dom</code>。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scroll = forwardRef (<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 编写组件内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>首先梳理一下这个组件需要接受哪些参数:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scroll.propTypes = &#123;</span><br><span class="line">  direction: PropTypes.oneOf ([<span class="string">'vertical'</span>, <span class="string">'horizental'</span>]),<span class="comment">// 滚动的方向</span></span><br><span class="line">  click: <span class="literal">true</span>,<span class="comment">// 是否支持点击</span></span><br><span class="line">  refresh: PropTypes.bool,<span class="comment">// 是否刷新</span></span><br><span class="line">  onScroll: PropTypes.func,<span class="comment">// 滑动触发的回调函数</span></span><br><span class="line">  pullUp: PropTypes.func,<span class="comment">// 上拉加载逻辑</span></span><br><span class="line">  pullDown: PropTypes.func,<span class="comment">// 下拉加载逻辑</span></span><br><span class="line">  pullUpLoading: PropTypes.bool,<span class="comment">// 是否显示上拉 loading 动画</span></span><br><span class="line">  pullDownLoading: PropTypes.bool,<span class="comment">// 是否显示下拉 loading 动画</span></span><br><span class="line">  bounceTop: PropTypes.bool,<span class="comment">// 是否支持向上吸顶</span></span><br><span class="line">  bounceBottom: PropTypes.bool<span class="comment">// 是否支持向下吸底</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>propTypes</code>定义参数的类型。</p>
</blockquote>
<p>目前归纳出了这些可能的参数，也正是后面的开发中所需要的，给他们赋默认值:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Scroll.defaultProps = &#123;</span><br><span class="line">  direction: <span class="string">"vertical"</span>,</span><br><span class="line">  click: <span class="literal">true</span>,</span><br><span class="line">  refresh: <span class="literal">true</span>,</span><br><span class="line">  onScroll:<span class="literal">null</span>,</span><br><span class="line">  pullUpLoading: <span class="literal">false</span>,</span><br><span class="line">  pullDownLoading: <span class="literal">false</span>,</span><br><span class="line">  pullUp: <span class="literal">null</span>,</span><br><span class="line">  pullDown: <span class="literal">null</span>,</span><br><span class="line">  bounceTop: <span class="literal">true</span>,</span><br><span class="line">  bounceBottom: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>defaultProps</code>定义这些参数的默认值。</p>
</blockquote>
<p>现在来写 scroll 组件的核心逻辑代码，首先声明如下 hooks 变量:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//better-scroll 实例对象</span></span><br><span class="line"><span class="keyword">const</span> [bScroll, setBScroll] = useState ();</span><br><span class="line"><span class="comment">//current 指向初始化 bs 实例需要的 DOM 元素 </span></span><br><span class="line"><span class="keyword">const</span> scrollContaninerRef = useRef ();</span><br></pre></td></tr></table></figure>

<p>从外面接受 props，解构赋值拿到这些参数:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; direction, click, refresh, pullUpLoading, pullDownLoading, bounceTop, bounceBottom &#125; = props;</span><br><span class="line"><span class="keyword">const</span> &#123; pullUp, pullDown, onScroll &#125; = props;</span><br></pre></td></tr></table></figure>



<p>接下来创建 better-scroll:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> scroll = <span class="keyword">new</span> BScroll (scrollContaninerRef.current, &#123;</span><br><span class="line">    scrollX: direction === <span class="string">"horizental"</span>,</span><br><span class="line">    scrollY: direction === <span class="string">"vertical"</span>,</span><br><span class="line">    probeType: <span class="number">3</span>,</span><br><span class="line">    click: click,</span><br><span class="line">    bounce:&#123;</span><br><span class="line">      top: bounceTop,</span><br><span class="line">      bottom: bounceBottom</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  setBScroll (scroll);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setBScroll (<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>new BScroll</code>创建一个scroll实例，第一个参数是父容器，也就是说<code>scrollContainerRef</code>所指向的DOM作为这个scroll组件的父容器。</p>
<p><code>setBScroll</code>方法就是将创建出来的scroll实例赋值给<code>bScroll</code>。</p>
<p><code>return()=&gt;{...}</code>就是在组件销毁的时候对effect进行清除</p>
</blockquote>
<p>每次重新渲染都要刷新实例，防止无法滑动:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (refresh &amp;&amp; bScroll)&#123;</span><br><span class="line">    bScroll.refresh ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>给实例绑定 scroll 事件:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!bScroll || !onScroll) <span class="keyword">return</span>;</span><br><span class="line">  bScroll.on (<span class="string">'scroll'</span>, (scroll) =&gt; &#123;</span><br><span class="line">    onScroll (scroll);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    bScroll.off (<span class="string">'scroll'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [onScroll, bScroll]);</span><br></pre></td></tr></table></figure>



<p>进行上拉到底的判断，调用上拉刷新的函数:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!bScroll || !pullUp) <span class="keyword">return</span>;</span><br><span class="line">  bScroll.on (<span class="string">'scrollEnd'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断是否滑动到了底部</span></span><br><span class="line">    <span class="keyword">if</span> (bScroll.y &lt;= bScroll.maxScrollY + <span class="number">100</span>)&#123;</span><br><span class="line">      pullUp ();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    bScroll.off (<span class="string">'scrollEnd'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [pullUp, bScroll]);</span><br></pre></td></tr></table></figure>



<p>进行下拉的判断，调用下拉刷新的函数:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">useEffect (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!bScroll || !pullDown) <span class="keyword">return</span>;</span><br><span class="line">  bScroll.on (<span class="string">'touchEnd'</span>, (pos) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断用户的下拉动作</span></span><br><span class="line">    <span class="keyword">if</span> (pos.y &gt; <span class="number">50</span>) &#123;</span><br><span class="line">      pullDown ();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    bScroll.off (<span class="string">'touchEnd'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [pullDown, bScroll]);</span><br></pre></td></tr></table></figure>



<p>现在已经完成了滑动事件，上拉下拉事件的判断，现在需要给外界暴露组件方法，假设这样的一个情景：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上层组件代码</span></span><br><span class="line"><span class="keyword">const</span> scrollRef = useRef ();</span><br><span class="line">...</span><br><span class="line">&lt;Scroll ref=&#123;scrollRef&#125;&gt;&lt;<span class="regexp">/Scroll&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要通过这种调用方法的方式刷新 scroll 组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">scrollRef.current.refresh ();</span><br></pre></td></tr></table></figure>

<p>这应该怎么办呢？</p>
<p>React Hooks 中的 useImperativeHandle 已经给了我们解决方案，我们这样做就好了:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般和 forwardRef 一起使用，ref 已经在 forWardRef 中默认传入</span></span><br><span class="line">useImperativeHandle (ref, () =&gt; (&#123;</span><br><span class="line">  <span class="comment">// 给外界暴露 refresh 方法</span></span><br><span class="line">  refresh () &#123;</span><br><span class="line">    <span class="keyword">if</span> (bScroll) &#123;</span><br><span class="line">      bScroll.refresh ();</span><br><span class="line">      bScroll.scrollTo (<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 给外界暴露 getBScroll 方法，提供 bs 实例</span></span><br><span class="line">  getBScroll () &#123;</span><br><span class="line">    <span class="keyword">if</span> (bScroll) &#123;</span><br><span class="line">      <span class="keyword">return</span> bScroll;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样上层组件就可以通过ref获取到这些方法。比如有时候要执行刷新之类的操作的时候，就需要去调用refresh方法。</p>
</blockquote>
<p>剩下的是 UI 的渲染工作:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;ScrollContainer ref=&#123;scrollContaninerRef&#125;&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/ScrollContainer&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>scrollContainerRef</code>所指向的<code>dom</code>就是这个<code>ScrollContainer</code>。</p>
</blockquote>
<p>同时贴出样式部分的 js 代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ScrollContainer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>



<h2 id="将Scroll组件应用到Recommend-js中"><a href="#将Scroll组件应用到Recommend-js中" class="headerlink" title="将Scroll组件应用到Recommend.js中"></a>将Scroll组件应用到Recommend.js中</h2><p>导入<code>Scroll</code>组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Scroll <span class="keyword">from</span> <span class="string">'../../scroll.js'</span>;</span><br></pre></td></tr></table></figure>



<p>在<code>return</code>中应用：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Content&gt;</span><br><span class="line">  &lt;Scroll className=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Slider bannerList=&#123;bannerList&#125;&gt;&lt;<span class="regexp">/Slider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;RecommendList recommendList=&#123;recommendList&#125;&gt;&lt;/</span>RecommendList&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Scroll&gt;</span><br><span class="line">&lt;<span class="regexp">/Content&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里作者用了个<code>Content</code>，来去保证父组件高度固定，这里是我疑惑的一个点，按照<code>better-scroll</code>的官方文档的内容，我们执行</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BScroll (scrollContaninerRef.current, &#123;</span><br><span class="line">    scrollX: direction === <span class="string">"horizental"</span>,</span><br><span class="line">    scrollY: direction === <span class="string">"vertical"</span>,</span><br><span class="line">    probeType: <span class="number">3</span>,</span><br><span class="line">    click: click,</span><br><span class="line">    bounce:&#123;</span><br><span class="line">      top: bounceTop,</span><br><span class="line">      bottom: bounceBottom</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>操作的时候，已经将<code>scrollContainerRef.current</code>作为父容器了。</p>
<p>后来我仔细想了一下发觉这么做是有道理的。</p>
<p>但我们可以看到<code>scrollContainerRef</code>的样式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ScrollContainer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p><code>scrollContainer</code>的高度是根据父元素高度来固定的。这么做的一个好处就是<code>scrollContainer</code>能够在多个地方复用，根据不同的父元素高度来调节自身的高度，因为<code>better-scroll</code>很重要的一点就是<code>wrapper</code>的高度要固定（即<code>scrollContainerRef.current</code>的高度要固定）。如果一开始便设置<code>ScrollContainer</code>的高度是固定的，比如30px，那么它就不能够在多个地方复用了，因为不同地方scroll的高度是不一样的。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序登录鉴权与获取用户信息</title>
    <url>/2021/01/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83%E4%B8%8E%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在小程序中，与云开发相比，传统的前后端开发在登录鉴权的实现方面相对来说更加复杂，不仅需要前端和后端的交互，后端还需要与微信接口服务进行交互，以完成整个鉴权流程：</p>
<p><img src="/images/loading.png" data-original="https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg" alt="img"></p>
<p>整个流程简单来说分为以下7步：</p>
<ol>
<li>前端调用<code>wx.login()</code>获取临时登录凭证<code>code</code>，并回传到开发者服务器。</li>
<li>服务器调用<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html" target="_blank" rel="noopener">auth.code2Session</a>换取<strong>用户唯一标识OpenID和会话密钥session_key</strong>。</li>
<li>服务器端根据<code>OpenID</code>或<code>session_key</code>生成自定义登录态（可以理解为是<code>token</code>），将<code>token</code>响应给前端。</li>
<li>前端将<code>token</code>存入<code>Storage</code>中。</li>
<li>当前端之后向后端发起请求时，就会带上<code>token</code>。</li>
<li>后台通过<code>token</code>（或者其他类型密钥），解密获取<code>OpenID</code>，判断是哪个用户的行为，做出响应的逻辑处理（比如操作数据库等）。</li>
<li>后台响应数据给前端。</li>
</ol>
<p>这个是小程序登录的流程，但是<strong>小程序登录和小程序获取用户信息并不是一回事</strong>。小程序登录的<code>API</code>是<code>wx.login</code>，可以获取用户的<code>openID</code>，<code>openID</code>是用户的唯一标识，是比较隐私的数据，一般不会返回给前端。小程序获取用户信息的<code>API</code>是<code>wx.getUserInfo</code>，它可以获取用户的一些基本信息，比如<code>nickName</code>、<code>avatarUrl</code>等。两者不要弄混。</p>
<p>其实微信登录一开始并不是这样的，以往微信小程序在用户没有任何操作的情况下就会直接弹出授权的登录方式，如果用户点击拒绝授权，则无法使用小程序。按照微信官方对这个功能更新的解释是：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210126090858.png" style="zoom:67%;">

<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210126091038.png" style="zoom:67%;">

<p>因此，微信对开发的建议是：</p>
<ol>
<li>当用户打开小程序时访问第一个页面时，先通过<code>wx.login</code>，获取用户 <code>openID</code> 。这时无需弹框授权，开发者拿到 <code>openID</code> 可以建立自身的帐号<code>ID</code>。</li>
<li>在第一步中，拿到 <code>openID</code> 后，判断是新用户还是老用户。如果是老用户，可以直接登录；如果是新用户，可先在小程序首页展示你的信息服务，让用户对这个小程序有大概的了解，再引导用户进行下一步的操作。</li>
<li>当需要获取用户头像昵称的时候，对用户展示一个登录页面，这个页面只有一个最重要的操作，引导用户进行登录。</li>
</ol>
<h1 id="小程序登录"><a href="#小程序登录" class="headerlink" title="小程序登录"></a>小程序登录</h1><p>在上一节中有提到，小程序登录可以分为7个步骤，下面就详细讲一下7个步骤具体是如何实现。</p>
<h2 id="step1-前端调用wx-login-获取临时登录凭证code"><a href="#step1-前端调用wx-login-获取临时登录凭证code" class="headerlink" title="step1: 前端调用wx.login()获取临时登录凭证code"></a>step1: 前端调用<code>wx.login()</code>获取临时登录凭证<code>code</code></h2><p>在项目中，我使用了<code>Taro</code>框架，所以调用的<code>API</code>对应为<code>Taro.login()</code>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Taro.login(&#123;&#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">          <span class="comment">// 将code发送到后台，以获取token</span></span><br><span class="line">          getToken(res.code)</span><br><span class="line">            .then(<span class="function">(<span class="params">res: any</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> &#123; token, userExist &#125; = res;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将token存储到Storage中</span></span><br><span class="line">              Taro.setStorageSync(<span class="string">'token'</span>, token);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果是老用户，获取用户信息</span></span><br><span class="line">              <span class="keyword">if</span>(userExist) &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; userInfo &#125; = res;</span><br><span class="line">                Taro.setStorageSync(<span class="string">'userInfo'</span>, userInfo);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.error(err);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'登录失败! '</span> + res.errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="step2-服务端调用auth-code2Session换取openid和session-key"><a href="#step2-服务端调用auth-code2Session换取openid和session-key" class="headerlink" title="step2: 服务端调用auth.code2Session换取openid和session_key"></a>step2: 服务端调用<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html" target="_blank" rel="noopener">auth.code2Session</a>换取openid和session_key</h2><p>服务端调用外部接口需要使用<code>egg.js</code>中的一个<code>api</code>：<code>this.ctx.curl</code>，因为是异步请求，所以需要加上<code>await</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/controller/home.js</span></span><br><span class="line"><span class="comment">// login接口</span></span><br><span class="line"><span class="keyword">async</span> login() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = ctx.request.body;</span><br><span class="line">    <span class="comment">// 服务器根据客户端传来的code向微信接口服务获取session_key和openid</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.curl(</span><br><span class="line">        <span class="string">`https://api.weixin.qq.com/sns/jscode2session?		</span></span><br><span class="line"><span class="string">    appid=wx6936c18b38186cf3&amp;secret=d11f77fb7d5a959b6ba46c30dbd4da95&amp;js_code=<span class="subst">$&#123;code&#125;</span>&amp;grant_type=authorization_code`</span>,</span><br><span class="line">        &#123;</span><br><span class="line">        	dataType: <span class="string">'json'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> &#123; openid &#125; = res.data;  <span class="comment">// 获取到openid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="step3-根据openid生成自定义登录态token，响应给前端"><a href="#step3-根据openid生成自定义登录态token，响应给前端" class="headerlink" title="step3: 根据openid生成自定义登录态token，响应给前端"></a>step3: 根据<code>openid</code>生成自定义登录态token，响应给前端</h2><p>因为<code>openid</code>是用户的唯一标识，根据它生成token，响应给前端后，前端每次发请求带上token，后台解密请求中的token，获取到<code>openid</code>，便能识别这是哪个用户的请求行为。</p>
<p>这里我们使用<code>jwt</code>来生成自定义登录态<code>token</code>，使用<code>jwt-simple</code>库来生成<code>jwt</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jwt-simple'</span>);</span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">'zhuoran'</span>; <span class="comment">// 自定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> login() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> &#123; openid &#125; = res.data;  <span class="comment">// 获取到openid</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据用户的openid生成token</span></span><br><span class="line">    <span class="keyword">const</span> token = jwt.encode(openid, SECRET);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将token返回</span></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      token: token,</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="step4-前端将token存入storage"><a href="#step4-前端将token存入storage" class="headerlink" title="step4: 前端将token存入storage"></a>step4: 前端将token存入storage</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将token存储到Storage中</span></span><br><span class="line">Taro.setStorageSync(<span class="string">'token'</span>, token);</span><br></pre></td></tr></table></figure>



<p>并在每次请求时带上<code>token</code>，将<code>token</code>放在请求头的<code>Authorization</code>字段里面：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> option = &#123;</span><br><span class="line">    url: BASE_URL + url,</span><br><span class="line">    data: data,</span><br><span class="line">    method: method,</span><br><span class="line">    header: &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: contentType,</span><br><span class="line">        Authorization: Taro.getStorageSync(<span class="string">'token'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">Taro.request(option);</span><br></pre></td></tr></table></figure>

<p>这样前端之后向后端发起请求，都会带上token。</p>
<h2 id="step5-后台解密token获取openid"><a href="#step5-后台解密token获取openid" class="headerlink" title="step5: 后台解密token获取openid"></a>step5: 后台解密token获取openid</h2><p>在后台解密token获取openid之后，便能知道这是哪个用户的请求，执行响应的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> request() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从请求头的authorization字段获取token</span></span><br><span class="line">    <span class="keyword">const</span> token = ctx.get(<span class="string">'authorization'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对token进行解密获取其中的openid</span></span><br><span class="line">    <span class="keyword">const</span> openid = jwt.decode(token, SECRET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据openid查找用户信息</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> ctx.model.User.findAll(&#123;</span><br><span class="line">      where: &#123;</span><br><span class="line">        openid: openid,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后注意要将openid属性去掉，私密属性不传回给客户端</span></span><br><span class="line">    ctx.body = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="额外需要注意的点"><a href="#额外需要注意的点" class="headerlink" title="额外需要注意的点"></a>额外需要注意的点</h2><p>保存用户登录态，一直以来都有两种解决方案：前端保存和后端保存。</p>
<ul>
<li>后端保存：在后端设定并存储当前token的过期时间，定期通知小程序前端重新登录</li>
<li>前端保存：因为session_key存在时效性（因为通过session_key我们可以查看敏感信息，所以必定会有一定的时效性），而小程序前端可以通过<code>wx.checkSession()</code>来检查<code>session_key</code>是否过期。我们可以自定义登录态，并考虑以session_key有效期作为自身登录态有效期（也就是以session_key的到期时间作为自定义登录态的到期时间，两者实际上并没有实质联系）。这个也是小程序文档中推荐的方法。</li>
</ul>
<p>因此，在项目中token是会过期的，一段时间没有使用就会导致它过期。那怎么去检验token是否过期，然后去更新它呢？</p>
<p>这里就需要用到前端拦截器和后端中间件。前端拦截器用来判断<code>token</code>是否过期，后端中间件用于判断请求是否携带token以及token是否有效。</p>
<h2 id="前端拦截器"><a href="#前端拦截器" class="headerlink" title="前端拦截器"></a>前端拦截器</h2><p>这里会使用到<code>Taro</code>拦截器<code>API</code>：<a href="https://taro-docs.jd.com/taro/docs/apis/network/request/addInterceptor" target="_blank" rel="noopener"><code>Taro.addInterceptor(callback)</code></a>。拦截器允许我们在请求发出前或发出后做一些额外操作。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interceptor = <span class="function"><span class="keyword">function</span> (<span class="params">chain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拦截请求发出前做一些额外操作</span></span><br><span class="line">  <span class="keyword">const</span> requestParams = chain.requestParams</span><br><span class="line">  <span class="keyword">const</span> &#123; method, data, url &#125; = requestParams</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`http <span class="subst">$&#123;method || <span class="string">'GET'</span>&#125;</span> --&gt; <span class="subst">$&#123;url&#125;</span> data: `</span>, data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chain.proceed(requestParams)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 拦截请求发出后做一些额外操作</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`http &lt;-- <span class="subst">$&#123;url&#125;</span> result:`</span>, res)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">Taro.addInterceptor(interceptor)</span><br></pre></td></tr></table></figure>



<p>所以，我们可以将<code>checkSession</code>步骤写在前端拦截器里，在请求每次发出之前判断<code>session_key</code>是否有过期，如果过期了，则重新调用<code>login</code>方法，更新token，如果没有过期，则正常发起请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login方法</span></span><br><span class="line"><span class="keyword">const</span> login = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Taro.login(&#123;&#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.code) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'code为'</span> + res.code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将code和userInfo发送到后台，以获取token</span></span><br><span class="line">        getToken(res.code)</span><br><span class="line">          .then(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'获取token'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(token);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将token存储到Storage中</span></span><br><span class="line">            Taro.setStorageSync(<span class="string">'token'</span>, token);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录失败! '</span> + res.errMsg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义拦截器</span></span><br><span class="line"><span class="keyword">const</span> customInterceptor = <span class="function">(<span class="params">chain</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> requestParams = chain.requestParams;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">const</span> loginFlag = Taro.getStorageSync(<span class="string">'token'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查session是否过期</span></span><br><span class="line">  Taro.checkSession(&#123;&#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'session没过期，不用重新登录'</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'token为'</span> + loginFlag);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'session已过期，要重新登录'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重新登录</span></span><br><span class="line">      login();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chain.proceed(requestParams).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要请求成功，不管返回什么状态码，都走这个回调</span></span><br><span class="line">    <span class="keyword">switch</span> (res.statusCode) &#123;</span><br><span class="line">      <span class="keyword">case</span> HTTP_STATUS.NOT_FOUND:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'请求资源不存在'</span>);</span><br><span class="line">      <span class="keyword">case</span> HTTP_STATUS.BAD_GATEWAY:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'服务端出现了问题'</span>);</span><br><span class="line">      <span class="keyword">case</span> HTTP_STATUS.FORBIDDEN: &#123;</span><br><span class="line">        Taro.setStorageSync(<span class="string">'Authorization'</span>, <span class="string">''</span>);</span><br><span class="line">        <span class="comment">// pageToLogin();</span></span><br><span class="line">        <span class="comment">// TODO 根据自身业务修改</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'没有权限访问'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HTTP_STATUS.AUTHENTICATE: &#123;</span><br><span class="line">        Taro.setStorageSync(<span class="string">'Authorization'</span>, <span class="string">''</span>);</span><br><span class="line">        <span class="comment">// pageToLogin();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'需要鉴权'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> HTTP_STATUS.SUCCESS:</span><br><span class="line">        <span class="keyword">return</span> res.data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Taro 提供了两个内置拦截器</span></span><br><span class="line"><span class="comment">// logInterceptor - 用于打印请求的相关信息</span></span><br><span class="line"><span class="comment">// timeoutInterceptor - 在请求超时时抛出错误。</span></span><br><span class="line"><span class="keyword">const</span> interceptors = [</span><br><span class="line">  customInterceptor,</span><br><span class="line">  Taro.interceptors.logInterceptor,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> interceptors;</span><br></pre></td></tr></table></figure>



<h2 id="后端中间件"><a href="#后端中间件" class="headerlink" title="后端中间件"></a>后端中间件</h2><p>正如之前所述，后端中间件的作用是用户判断请求是否携带token以及token是否有效的。我们在egg Node.js后端项目中定义校验token的中间件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/middleware/auth.js</span></span><br><span class="line"><span class="keyword">let</span> jwt = <span class="built_in">require</span>(<span class="string">'jwt-simple'</span>);</span><br><span class="line"><span class="keyword">const</span> SECRET = <span class="string">'zhuoran'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = ctx.get(<span class="string">'authorization'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'请求带有token'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> openid = jwt.decode(token, SECRET);</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          code: <span class="number">401</span>,</span><br><span class="line">          msg: <span class="string">'token有误'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'请求没有带token'</span>);</span><br><span class="line">      ctx.body = &#123;</span><br><span class="line">        code: <span class="number">401</span>,</span><br><span class="line">        msg: <span class="string">'您没有登录'</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>因为小程序中，有些功能不强制要求用户登录之后才能使用，所以有些请求操作不需要后台校验是否有token，那么这个<code>auth.js</code>中间件就不能够全局配置，而是放在需要校验token的路由下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller, middleware &#125; = app;</span><br><span class="line">  <span class="keyword">const</span> auth = middleware.auth();</span><br><span class="line"></span><br><span class="line">  router.get(<span class="string">'/'</span>, controller.home.index);</span><br><span class="line">  router.get(<span class="string">'/request'</span>, auth, controller.home.request); <span class="comment">// 将middleware放在中间</span></span><br><span class="line">  router.post(<span class="string">'/login'</span>, controller.home.login);</span><br><span class="line">  router.post(<span class="string">'/userInfo'</span>, controller.home.userInfo);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="登录鉴权及获得用户信息流程梳理"><a href="#登录鉴权及获得用户信息流程梳理" class="headerlink" title="登录鉴权及获得用户信息流程梳理"></a>登录鉴权及获得用户信息流程梳理</h1><p>登录：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210127093505.png" style="zoom:80%;">

<p>获取用户信息：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210127094738.png" style="zoom:80%;">



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相对于云开发来说，传统的前后端开发在登录鉴权方面复杂许多，涉及多端交互，以上总结也有许多要改进的地方。总而言之，将逻辑理顺之后，写代码就比较简单了。</p>
<p>在登录鉴权过程中比较重要的点：</p>
<ol>
<li>知道什么是用户的唯一标识，并根据它生成token</li>
<li>对token进行校验，判断其是否过期，是否准确</li>
<li>通过画流程图等方式理清各个过程的逻辑</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6873700061000237069" target="_blank" rel="noopener">使用Nodejs实现jwt原理</a></p>
<p><a href="https://juejin.cn/post/6844903588498522120" target="_blank" rel="noopener">手把手教会你小程序登录鉴权</a></p>
<p><a href="https://juejin.cn/post/6844903756887228430" target="_blank" rel="noopener">小程序登录那些事</a></p>
<p><a href="https://blog.csdn.net/qq_33594380/article/details/80431582?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3.control" target="_blank" rel="noopener">小程序：授权、登录、session_key、unionId</a></p>
<p><a href="https://segmentfault.com/a/1190000023682165" target="_blank" rel="noopener">微信小程序wx.getUserInfo授权获取用户信息（头像、昵称）</a></p>
<p><a href="https://segmentfault.com/q/1010000016300232#" target="_blank" rel="noopener">前后端分离项目，token过期，重新登录和刷新token的问题</a></p>
<p><a href="https://blog.csdn.net/bocongbo/article/details/93719624" target="_blank" rel="noopener">egg中间件匹配路由</a></p>
<p><a href="https://www.cnblogs.com/juewuzhe/p/11130475.html" target="_blank" rel="noopener">Taro微信小程序登录</a></p>
<p><a href="https://github.com/NervJS/taro/issues/421" target="_blank" rel="noopener">Button组件onGetUserInfo未执行</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM</title>
    <url>/2020/03/31/%E8%99%9A%E6%8B%9FDOM/</url>
    <content><![CDATA[<p>昨天面试的时候，面试官问到虚拟DOM的原理，被问到的时候，就把自己之前的理解说了一通，因为之前面试的时候也被问到过，觉得应该没问题。后来面试官质问了一下：“虚拟DOM最终也是使用DOM API去操作DOM，它的性能就一定会更好么 ? ” 然后就懵了….后来在网上搜了些资料，又有了些新的见解。</p>
<h2 id="虚拟DOM的含义"><a href="#虚拟DOM的含义" class="headerlink" title="虚拟DOM的含义"></a>虚拟DOM的含义</h2><p>虚拟DOM是使用JS去模拟真实的DOM。DOM树上的结构、属性信息我们都可以使用JavaScript对象表示出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    id: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面对应的HTML写法是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。</p>
<p>用JS操作真实DOM的操作：状态变更-&gt;重新渲染整个视图的方式，可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。</p>
<p>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：<strong>虚拟DOM是局部更新的。虽然视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，减少了不必要的调用DOM API去操作DOM的操作</strong>。</p>
<br>



<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h4 id="步骤一：用JS对象模拟真实DOM"><a href="#步骤一：用JS对象模拟真实DOM" class="headerlink" title="步骤一：用JS对象模拟真实DOM"></a>步骤一：用JS对象模拟真实DOM</h4><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点：</p>
<p>element.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">  <span class="keyword">this</span>.props = props</span><br><span class="line">  <span class="keyword">this</span>.children = children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如上面的 DOM 结构就可以简单的表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">'./element'</span>) <span class="comment">//模块化导入Element函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">'ul'</span>, &#123;<span class="attr">id</span>: <span class="string">'list'</span>&#125;, [</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 2'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: <span class="string">'item'</span>&#125;, [<span class="string">'Item 3'</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>



<p>现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的<code>&lt;ul&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName) <span class="comment">// 根据tagName构建</span></span><br><span class="line">  <span class="keyword">var</span> props = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) &#123; <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> children = <span class="keyword">this</span>.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> Element)</span><br><span class="line">      ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">      : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ulRoot = ul.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot)</span><br></pre></td></tr></table></figure>



<p>上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的<code>&lt;ul&gt;</code>的DOM结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异</h4><p>当我们要做出修改的时候，首先是要创建一个新的结点，然后使用<strong><code>diff</code>算法去对比新旧节点的不同</strong>，这种对比只会在同层级进行，不会跨层进行，此处是使用深度优先遍历算法，然后将差异记录在<code>patches</code>对象当中。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/x.png" alt></p>
<p>同层级比较的话算法复杂度更低，降到<code>O(n)</code>。</p>
<p><strong>深度优先遍历，记录差异</strong>：</p>
<p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/n.png" alt></p>
<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span> (<span class="params">oldTree, newTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span> <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = &#123;&#125; <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  <span class="keyword">return</span> patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对比oldNode和newNode的不同，记录下来</span></span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span> (<span class="params">oldChildren, newChildren, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> leftNode = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count) <span class="comment">// 计算节点的标识</span></span><br><span class="line">      ? currentNodeIndex + leftNode.count + <span class="number">1</span></span><br><span class="line">      : currentNodeIndex + <span class="number">1</span></span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches) <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如，上面的div和新的div有差异，当前的标记是0，那么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;difference&#125;, &#123;difference&#125;, ...] <span class="comment">// 用数组存储新旧节点的不同</span></span><br></pre></td></tr></table></figure>



<p>同理p是patches[1]，ul是patches[3]，类推。</p>
<p><strong>差异类型</strong>：</p>
<p>上面说的节点的差异指的是什么呢？对 DOM 操作可能会：</p>
<ol>
<li>替换掉原来的节点，例如把上面的div换成了section</li>
<li>移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换</li>
<li>修改了节点的属性</li>
<li>对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。</li>
</ol>
<p>所以我们定义了几种差异类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> REPLACE = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> REORDER = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> PROPS = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> TEXT = <span class="number">3</span></span><br></pre></td></tr></table></figure>



<p>对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode <span class="comment">// el('section', props, children)</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<p>如果给div新增了属性id为container，就记录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patches[0] &#x3D; [&#123;</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode &#x2F;&#x2F; el(&#39;section&#39;, props, children)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  type: PROPS,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: &quot;container&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<p>如果是文本节点，如上面的文本节点2，就记录下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">2</span>] = [&#123;</span><br><span class="line">  type: TEXT,</span><br><span class="line">  content: <span class="string">"Virtual DOM2"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<p>那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。</p>
<p>这就涉及到两个列表的对比算法，其实可以抽象出来是最小编辑距离问题（动态规划思想）。</p>
<p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [&#123;</span><br><span class="line">  type: REORDER,</span><br><span class="line">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>



<h4 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上"></a>步骤三：把差异应用到真正的DOM树上</h4><p>因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。</p>
<p>使用<code>patch</code>方法将对象<code>patches</code>当中记录的更改应用到真实DOM上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">node, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentPatches = patches[walker.index] <span class="comment">// 从patches拿出当前节点的差异</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> len = node.childNodes</span><br><span class="line">    ? node.childNodes.length</span><br><span class="line">    : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    <span class="keyword">var</span> child = node.childNodes[i]</span><br><span class="line">    walker.index++</span><br><span class="line">    dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) <span class="comment">// 对当前节点进行DOM操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span> (<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">  currentPatches.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">currentPatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> REPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> REORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> PROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> TEXT:</span><br><span class="line">        node.textContent = currentPatch.content</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown patch type '</span> + currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h3><p>优点：</p>
<ul>
<li><p>很多 DOM API 的读写都涉及<strong>页面布局的“重新计算”</strong>，以确保返回值的准确，涉及样式、结构的还会触发<strong>页面“重新绘制”</strong>，更耗性能。</p>
<p>综上，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。</p>
</li>
<li><p>虚拟DOM实际上最终还是会调用DOM API，但它能够<strong>减少不必要的DOM API调用</strong>。虚拟DOM遵循“在JS中缓存必要数据，计算界面更新时的阶段数据差异，<strong>只提交最终差集</strong>”的基本思路。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用JS去模拟真实DOM，会占用一定内存</li>
<li>diff算法，有计算方面的额外开销</li>
</ul>
<br>

<p>参考：</p>
<p>&lt;<a href="https://www.zhihu.com/search?type=content&q=虚拟dom" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E8%99%9A%E6%8B%9Fdom</a>&gt;</p>
<br>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本知识</title>
    <url>/2019/12/30/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="ES6和JavaScript的关系"><a href="#ES6和JavaScript的关系" class="headerlink" title="ES6和JavaScript的关系"></a>ES6和JavaScript的关系</h2><p>ES6的全称为ECMAScript 6.0，是JavaScript语言下一代的标准，是使得JavaScript可以用来编写复杂的大型应用程序，称为企业级开发语言。ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。</p>
<br>

<h2 id="JavaScript前言"><a href="#JavaScript前言" class="headerlink" title="JavaScript前言"></a>JavaScript前言</h2><p>JavaScript是世界上最流行的脚本语言，是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</p>
<br>

<h2 id="JavaScript引入"><a href="#JavaScript引入" class="headerlink" title="JavaScript引入"></a>JavaScript引入</h2><ol>
<li>用<script></script>直接包含js代码</li>
<li>把js代码放到一个单独的.js文件，在html中通过<script src="..."></script>引入这个文件，这么做更有利于代码维护</li>
</ol>
<br>

<h2 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h2><ol>
<li>JavaScript的语法和Java类似，每个语句以；结束</li>
<li>JavaScript严格区分大小写</li>
</ol>
<br>

<h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><p>基本数据类型：Number, String, Boolean, null, undefined, Symbol（ES6中新添加的类型，一种实例是唯一且不可改变的数据类型）</p>
<br>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript不区分整数和浮点数，统一用Number表示。可以表示</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>科学计数法</li>
<li>负数</li>
<li>NaN（表示Not a Number，当无法计算结果时用NaN表示）</li>
<li>Infinity（表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity）</li>
</ul>
<br>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串是以单引号或双引号括起来的文本。</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用+号连接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">'你好, '</span> + name + <span class="string">', 你今年'</span> + age + <span class="string">'岁了!'</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>



<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>



<h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>获取字符串长度：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>

<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// 'H'</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// ' '</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// 'w'</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// '!'</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是</strong>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Test'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">alert(s); <span class="comment">// s仍然为'Test'</span></span><br></pre></td></tr></table></figure>



<h4 id="字符串常用方法："><a href="#字符串常用方法：" class="headerlink" title="字符串常用方法："></a>字符串常用方法：</h4><p>注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<p><strong>toUpperCase</strong>：</p>
<p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回'HELLO'</span></span><br></pre></td></tr></table></figure>



<p><strong>toLowerCase</strong>：</p>
<p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回'hello'并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>



<p><strong>substring</strong>:</p>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello, world'</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回'hello'</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回'world'</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>true或者false</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>当我们对Number做比较时，可以通过比较运算符得到一个布尔值，要特别注意比较运算符==和===：</p>
<ul>
<li>==比较：它会自动转换数据类型再比较，很多时候会得到很奇怪的结果</li>
<li>===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>
</ul>
<p>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较</p>
<p>另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<p><code>NaN===NaN   //false</code></p>
<p>唯一能判断NaN的方法是通过isNaN()函数：<br><code>isNaN(NaN)   //true</code></p>
<p>最后要注意浮点数的相等比较：</p>
<p><code>1 / 3 === (1 - 2 / 3); // false</code></p>
<p>比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<br>

<h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul>
<li><p><code>null</code>表示一个“空”的值、表示“无”的对象，转为数值是为0；<code>undefined</code>是一个表示“无”的原始值，转为数值是NaN，当声明的变量还未被初始化时，变量的默认值为undefined。</p>
</li>
<li><p>Null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象</p>
</li>
<li><p>Undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义，典型用法是：</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于undefined</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值属性，该属性的值为undefined</li>
<li>函数没有返回值时，默认返回undefined</li>
</ul>
</li>
<li><p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ul>
</li>
</ul>
<br>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br></pre></td></tr></table></figure>

<p>上述数组包含6个元素。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔。</p>
<p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br><span class="line">arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1</span><br><span class="line">arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即true</span><br><span class="line">arr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined</span><br></pre></td></tr></table></figure>



<p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure>



<p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为['A', 99, 'C']</span></span><br></pre></td></tr></table></figure>

<p>(注意此处与String的不同，String是不可变的)</p>
<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></span><br></pre></td></tr></table></figure>

<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
<p><strong>indexOf</strong></p>
<p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></span><br></pre></td></tr></table></figure>

<p>注意了，数字<code>30</code>和字符串<code>&#39;30&#39;</code>是不同的元素。</p>
<p><strong>slice</strong></p>
<p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></span><br></pre></td></tr></table></figure>



<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p><strong>push和pop</strong></p>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 'A', 'B']</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回'B'</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 'A']</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>



<p><strong>unshift和shift</strong></p>
<p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// 'A'</span></span><br><span class="line">arr; <span class="comment">// ['B', 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>



<p><strong>sort</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure>



<p><strong>reverse</strong></p>
<p><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; <span class="comment">// ['three', 'two', 'one']</span></span><br></pre></td></tr></table></figure>



<p><strong>splice</strong></p>
<p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure>



<p><strong>concat</strong></p>
<p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>



<p><strong>join</strong></p>
<p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<br>



<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript的对象是一组由<code>键-值</code>组成的无序集合，用一个<code>{...}</code>表示一个对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</span><br><span class="line">    city: <span class="string">'Beijing'</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>&#39;Bob&#39;</code>，<code>zipcode</code>属性为<code>null</code>。</p>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name; <span class="comment">// 'Bob'</span></span><br><span class="line">person.zipcode; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>



<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果<strong>属性名包含特殊字符</strong>，就必须用<code>&#39;&#39;</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">'小红'</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaohong[<span class="string">'middle-school'</span>]; <span class="comment">// 'No.1 Middle School'</span></span><br><span class="line">xiaohong[<span class="string">'name'</span>]; <span class="comment">// '小红'</span></span><br><span class="line">xiaohong.name; <span class="comment">// '小红'</span></span><br></pre></td></tr></table></figure>

<p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p>
<p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code></p>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure>



<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">'No.1 Middle School'</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<br>



<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefined</span><br><span class="line">var $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1</span><br><span class="line">var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串</span><br><span class="line">var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值true</span><br><span class="line">var t &#x3D; null; &#x2F;&#x2F; t的值是null</span><br></pre></td></tr></table></figure>



<p>在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意<strong>只能用<code>var</code>申明一次</strong>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure>

<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言（例如int）</p>
<p>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p>
<br>



<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// '0', '1', '2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p>
<br>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code>是一组键值对的结构，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure>

<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>

<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>

<br>



<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>



<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>



<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

<br>



<h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p>
<p>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p><code>for...in</code>和<code>for...of</code>的区别：</p>
<ul>
<li>for in 循环的是对象的属性（普通数组的属性就是index）</li>
<li>for of 循环的是迭代器中的每一个元素</li>
</ul>
<p>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你可能会有疑问，<code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.name = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// '0', '1', '2', 'name'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.name = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">', index = '</span> + index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>基本数据类型和引用数据类型的区别：<a href="https://www.cnblogs.com/c2016c/articles/9328725.html" target="_blank" rel="noopener">https://www.cnblogs.com/c2016c/articles/9328725.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Redux及中间件解析</title>
    <url>/2021/01/07/React-Redux%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="为什么需要Redux"><a href="#为什么需要Redux" class="headerlink" title="为什么需要Redux"></a><strong>为什么需要Redux</strong></h1><p>React知识DOM的一个抽象层，并不是Web应用的完整解决方案。有两个方面它没有涉及：</p>
<ol>
<li>代码结构</li>
<li>组件之间的通信</li>
</ol>
<p>对于大型的复杂应用来说，这两方面是很关键的，因此只有React没有办法写大型应用。</p>
<p>但Redux并不是非用不可。如果你的UI层非常简单，没有很多互动，Redux就是不必要的，用了反而会增加复杂性。</p>
<p>以下这些情况都不需要使用Redux：</p>
<ol>
<li>用户的使用方式非常简单</li>
<li>用户之间没有协作</li>
<li>不需要与服务器大量交互，也没有使用WebSocket</li>
<li>视图层（view）只从单一来源获取数据</li>
</ol>
<p>Redux适用的场景是：多交互、多数据源</p>
<ol>
<li>用户的使用方式复杂</li>
<li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>
<li>多个用户之间可以协作</li>
<li>与服务器大量交互，或者使用了WebSocket</li>
<li>View要从多个来源获取数据</li>
</ol>
<p>从组件的角度看，如果你的应用有以下场景，可以考虑使用Redux：</p>
<ol>
<li>某个组件的状态，需要共享</li>
<li>某个状态需要在任何地方都可以拿到</li>
<li>一个组件需要改变全局状态</li>
<li>一个组件需要改变另一个组件的状态</li>
</ol>
<br>

<hr>

<h1 id="Redux的设计思想"><a href="#Redux的设计思想" class="headerlink" title="Redux的设计思想"></a><strong>Redux的设计思想</strong></h1><ol>
<li>Web应用是一个状态机，视图和状态是一一对应的。</li>
<li>所有的状态，都保存在一个对象（Store）里。</li>
</ol>
<br>

<hr>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h1><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a><strong>Store</strong></h2><p>Store是保存数据的地方，可看作一个容器。<strong>整个应用只能有一个store</strong>，一般用createStore这个方法来生成Store。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, preloadedState, enhancer);</span><br></pre></td></tr></table></figure>



<p>store三个参数的含义：</p>
<ol>
<li>reducer：改变store数据的纯函数</li>
<li>preloadedState：初始状态</li>
<li>enhancer：中间件相关</li>
</ol>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h2><p>Store对象包含所有数据。如果想得到某个时间节点的数据，就要对Store生成快照。这种时间节点的数据集合，就叫做State。</p>
<p>当前时刻的State，可以通过store.getState()拿到：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure>



<p>一个State对应一个View。只要State相同，View就相同。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a><strong>Action</strong></h2><p>State变化 =&gt;(导致) View变化。但是，用户接触不到State，只能接触到View。所以State的变化也是由View导致的。Action就是用户通过View发出的通知，表示State应该要发生变化了。</p>
<p>Action是一个对象，其中type属性是必须的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> action =&#123;   </span><br><span class="line">    type: <span class="string">'ADD_TODO'</span>, <span class="comment">// Action的名称</span></span><br><span class="line">    payload: <span class="string">'Learn Redux'</span> <span class="comment">// 携带的字符串信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>payload属性名可以是任意其他名称，比如data等。之后reducer就根据action.属性名来获取数据，比如action.payload，action.data。</p>
<h2 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a><strong>Action Creator</strong></h2><p>View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦。可以定义一个函数来生成Action，这个函数就叫Action Creator。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加 TODO'</span>;</span><br><span class="line"></span><br><span class="line">functionaddTodo(text)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: ADD_TODO,    </span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">'Learn Redux'</span>);</span><br></pre></td></tr></table></figure>

<p>addTodo函数就是一个Action Creator。</p>
<h2 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a><strong>store.dispatch()</strong></h2><p>store.dispatch()是View发出Action的唯一方法。</p>
<p>store.dispatch可接受一个Action对象作为参数，将它发送出去：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">store.dispatch(&#123;   </span><br><span class="line">    type:<span class="string">'ADD_TODO'</span>,</span><br><span class="line">    payload:<span class="string">'Learn Redux'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>也可以结合Action Creator（调用函数返回一个Action对象）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">store.dispatch(addTodo(<span class="string">'Learn Redux'</span>));</span><br></pre></td></tr></table></figure>



<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><strong>Reducer</strong></h2><p>Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。</p>
<p>Reducer是一个函数，它接受当前State和Action作为参数，返回一个新的State。整个应用的初始状态，可以作为State的默认值：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'ADD'</span>:</span><br><span class="line"><span class="keyword">return</span> state + action.payload;</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">type: <span class="string">'ADD'</span>,</span><br><span class="line">payload: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>reducer函数收到名为ADD的Action以后，就返回一个新的State，作为加法的计算结果。</p>
<p><strong>实际应用中，Reducer函数不用像上面这样手动调用，store.dispatch方法会触发Reducer的自动执行。为此，Store需要知道Reducer函数，做法就是在生成store的时候，将Reducer传入createStore。以后每当store.dispatch发送过来一个新的Action，就会自动调用Reducer，得到新的State。</strong></p>
<p>为什么这个函数要叫Reducer？因为它可以作为数组的reduce方法的参数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> actionTypes.CHANGE_CURRENT_ALBUM:</span><br><span class="line">            <span class="keyword">return</span> state.set(<span class="string">'currentAlbum'</span>, action.data);</span><br><span class="line">        <span class="keyword">case</span> actionTypes.CHANGE_ENTER_LOADING:</span><br><span class="line">            <span class="keyword">return</span> state.set(<span class="string">'enterLoading'</span>, action.data);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">'ADD'</span>, <span class="attr">payload</span>: <span class="number">2</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = actions.reduce(reducer, <span class="number">0</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<p>js数组api reduce方法解析：</p>
<p><a href="https://www.cnblogs.com/amujoe/p/11376940.html" target="_blank" rel="noopener">JS中 reduce() 的用法</a></p>
<p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">reduce mdn官方文档</a></p>
<p>一些需要熟记的点：</p>
<ol>
<li>reduce的第一个参数为reducer函数，可传入4个参数，分别是prev、cur、index、arr，根据英文大致能猜出它的意思。prev表示上一次调用的返回值或者初始值，cur表示当前正在处理的数组元素，index表示当前正在处理的数组元素的索引（若提供init值，则索引为0，否则索引为1，因为init值不算作数组元素），arr表示原数组</li>
<li>reduce的第二个参数为初始值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,arr</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;, init);</span><br></pre></td></tr></table></figure>



<p>因为redux中的reducer函数与reduce方法的第一个参数reducer函数的结构和用途类似，所以称之为reducer（把state看作prev，action看作cur，返回的也是一个新的状态，下一次dispatch action的时候，会根据上一次的状态来更新或者说累加）。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a><strong>纯函数</strong></h3><p>Reducer函数最重要的特征是：它是一个纯函数，即只要是同样的输入，必定得到同样的输出。</p>
<p>并且它需要遵守以下一些约束：</p>
<ol>
<li>不得改写参数</li>
<li>不能调用系统I/O的API</li>
<li>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</li>
</ol>
<p>因此，Reducer函数里面不能改变State，必须返回一个全新的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// State 是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; thingToChange &#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">return</span> &#123; ...state, ...newState &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State 是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...state, newItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a><strong>store.subscribe()</strong></h2><p>Store允许使用store.subscribe方法设置监听函数，一旦State发生变化，就自动执行这个函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure>



<p>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span>           </span><br><span class="line">    <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure>

<br>

<hr>

<h1 id="Store的实现"><a href="#Store的实现" class="headerlink" title="Store的实现"></a><strong>Store的实现</strong></h1><p>Store提供了三个方法：</p>
<ol>
<li>store.getState()</li>
<li>store.dispatch()</li>
<li>store.subscribe()</li>
</ol>
<p>下面是createStore方法的一个简单实现：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> state;</span><br><span class="line"><span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state; <span class="comment">// getState方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123; <span class="comment">// dispatch方法</span></span><br><span class="line">        state = reducer(state, action);</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;  <span class="comment">// subscribe方法</span></span><br><span class="line">        listeners.push(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">    dispatch(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<hr>

<h1 id="Reducer的拆分"><a href="#Reducer的拆分" class="headerlink" title="Reducer的拆分"></a><strong>Reducer的拆分</strong></h1><p>Reducer函数如果不进行拆分的话，会变得十分庞大。Reducer需要根据所有组件的action进行处理，代码的可读性也会变得很糟糕。</p>
<p>Redux提供了一个combineReducers方法，用于Reducer的拆分。你只要定义各个子Reducer函数，然后用这个方法，将它们合成一个大的Reducer。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> chatLogReducer &#125; <span class="keyword">from</span> <span class="string">'../application/ChatLog/store/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> statusMessageReducer &#125; <span class="keyword">from</span> <span class="string">'../application/StatusMessage/store/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> userNameReducer &#125; <span class="keyword">from</span> <span class="string">'../application/userName/store/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatReducer = combineReducers(&#123;</span><br><span class="line">    chatLog: chatLogReducer,</span><br><span class="line">    statusMessage: statusMessageReducer,</span><br><span class="line">    userName: userNameReducer,</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>



<p>combineReducers方法的用法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">    state属性名: 对应的Reducer,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        state属性名: 调用对应的Reducer,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>返回的是合并后的reducer，之后直接将这个合并后的reducer作为参数传入createStore方法中。</p>
<p>例如（注意其中的区别，原生实现中是要调用函数，返回对象）：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingWithA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    a: doSomethingWithA(state.a, action),</span><br><span class="line">    b: processB(state.b, action),</span><br><span class="line">    c: c(state.c, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210107173147.png" style="zoom:33%;">

<br>

<hr>

<h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h1><p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210107173249.png" alt></p>
<p>（注意Action Creators到Reducers之间是虚线，因为是Store自动调用reducer来改变state，所以是虚线，这里的画法体现了这一思路。）</p>
<ol>
<li>首先，用户发出Action。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">store.dispatch(action);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Store自动调用Reducer，并传入两个参数：当前State和收到的Action。Reducer会返回新的State。</li>
<li>State一旦有变化，Store就会调用监听函数</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置监听函数</span></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure>

<br>

<hr>

<h1 id="Redux中间件与异步操作"><a href="#Redux中间件与异步操作" class="headerlink" title="Redux中间件与异步操作"></a><strong>Redux中间件与异步操作</strong></h1><p>我们已经了解到Redux的基本做法：用户发出Action，Reducer函数算出新的State，View重新渲染。</p>
<p>但如果涉及到异步操作，则需要用到新的工具：中间件。</p>
<p>同步与异步的区别是什么？Action发出以后，Reducer立即算出State，这叫同步。Action发出后，过一段时间再执行Reducer，这就是异步。</p>
<h2 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a><strong>中间件的概念</strong></h2><p>中间件其实就是一个函数，对store.dispatch方法进行了改造，在发出Action和执行Reducer这两步之间，添加了其他功能。</p>
<p>比如我们要添加日志功能，把Action和State打印出来，可以对store.dispatch进行改造：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action);</span><br><span class="line">    next(action);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是中间件的雏形。</p>
<p>为什么不在其他环节添加这种功能？</p>
<ol>
<li>Reducer：纯函数，只承担计算State的功能，不适合承担其他功能，因为纯函数不能进行读写操作。</li>
<li>View：与State一一对应，可看作是State的视觉层，也不适合承担其他功能。</li>
<li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li>
</ol>
<h2 id="中间件的用法"><a href="#中间件的用法" class="headerlink" title="中间件的用法"></a><strong>中间件的用法</strong></h2><p>常用的中间件都有现成的，只要引用别人写好的模块即可。比如上面的日志中间件，就有现成的redux-logger模块。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'redux-logger'</span>;</span><br><span class="line"><span class="keyword">const</span> logger = createLogger(); <span class="comment">// 生成日志中间件logger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>两点需要注意：</p>
<ol>
<li>createStore方法可接受整个应用的初始状态作为参数，在这种情况下applyMiddleware就是第三个参数：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(   </span><br><span class="line">    reducer,</span><br><span class="line">    initial_state,</span><br><span class="line">    applyMiddleware(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>中间件的次序有讲究</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk, promise, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="applyMiddlewares"><a href="#applyMiddlewares" class="headerlink" title="applyMiddlewares()"></a><strong>applyMiddlewares()</strong></h2><p>applyMiddlewares是Redux的原生方法，作用是将所有中间件组成一个数组，依次执行。其源码为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">createStore</span>) =&gt;</span> <span class="function">(<span class="params">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">        getState: store.getState,</span><br><span class="line">        dispatch: <span class="function">(<span class="params">action</span>) =&gt;</span> dispatch(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span>         </span><br><span class="line">    middleware(middlewareAPI));</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;...store, dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其中的middlewareAPI，里面有getState和dispatch方法，这也是为什么异步的action creator返回的函数的参数就是dispatch和getState。</p>
<h2 id="异步操作的基本思路"><a href="#异步操作的基本思路" class="headerlink" title="异步操作的基本思路"></a><strong>异步操作的基本思路</strong></h2><p>同步操作只要发出一种Action即可，异步操作的差别是它要发出三种Action（可能但不是必须）：</p>
<ol>
<li>操作发起时的Action</li>
<li>操作成功时的Action</li>
<li>操作失败时的Action</li>
</ol>
<p>所以整个异步思路就是：</p>
<ol>
<li>操作开始时，dispatch一个action，触发State更新为“正在操作”状态，View重新渲染</li>
<li>操作结束时，再送出一个action，触发State更新为“操作结束”状态，View再一次重新渲染</li>
</ol>
<p>结合实际开发，比如组件中有个Loading组件，一般是在开始渲染页面时展示这个Loading组件，在数据加载完成之后，Loading组件消失。</p>
<p>所以在开始渲染页面时，先dispatch一个action，将与展示Loading组件相关的数据（比如show）设为true，在异步数据获取完成后，再dispatch一个action，将show设置为false。</p>
<h2 id="redux-thunk中间件"><a href="#redux-thunk中间件" class="headerlink" title="redux-thunk中间件"></a><strong>redux-thunk中间件</strong></h2><p>实现异步操作结束后系统自动送出第二个Action的关键，在Action Creator之中。</p>
<p>来看一个获取专辑列表的异步请求操作：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getAlbumList = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">        getAlbumDetailRequest(id).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> data = res.playlist;</span><br><span class="line">            <span class="comment">// 操作结束</span></span><br><span class="line">            dispatch(changeCurrentAlbum(data));</span><br><span class="line">            dispatch(changeEnterLoading(<span class="literal">false</span>));</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"获取album数据失败！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="comment">// 操作开始</span></span><br><span class="line">dispatch(changeEnterLoading(<span class="literal">true</span>));</span><br><span class="line">dispatch(getAlbumList(id));</span><br></pre></td></tr></table></figure>



<p>上面的代码，有几个地方需要注意：</p>
<ol>
<li>getAlbumList是一个Action Creator，返回一个函数（和普通的Action Creator不同，普通的Action Creator返回一个对象）。</li>
<li>getAlbumList函数所返回的函数的参数是dispatch和getState这两个Redux方法，而普通的Action Creator的参数是Action的内容。</li>
</ol>
<p>因为正常情况下，store.dispatch方法的参数只能是对象，不能是函数，所以就要使用redux-thunk（是因为需要满足这样的Action Creator，<em>以内容作为参数，和普通的Action Creator一样，但是返回一个函数，以dispatch和getState作为参数，这样在异步请求完成之后才能再dispatch action，更新State，表示操作结束</em>，所以才有redux-thunk）。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: this API requires redux@&gt;=3.1.0</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。</p>
<p>因此，异步操作的第一种解决方案就是：</p>
<ol>
<li>写出一个返回函数的Action Creator</li>
<li>使用redux-thunk中间件改造store.dispatch</li>
</ol>
<br>

<hr>

<h1 id="React-Redux的用法"><a href="#React-Redux的用法" class="headerlink" title="React-Redux的用法"></a><strong>React-Redux的用法</strong></h1><h2 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a><strong>UI组件</strong></h2><p>React-Redux将所有组件分成两大类：UI组件和容器组件。</p>
<p>UI组件有以下几个特征：</p>
<ol>
<li>只负责UI的呈现，不带有任何业务逻辑</li>
<li>没有状态（即不使用this.state这个变量）</li>
<li>所有数据都由参数（this.props）提供</li>
<li>不使用任何Redux的API</li>
</ol>
<p>例如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Title = <span class="function"><span class="params">value</span> =&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>因为不含有状态，UI组件又称为“纯组件”，即它像纯函数一样，纯粹由参数决定它的值。</p>
<h2 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a><strong>容器组件</strong></h2><p>容器组件的特征则相反：</p>
<ol>
<li>负责管理数据和业务逻辑，不负责UI的呈现</li>
<li>带有内部状态</li>
<li>使用Redux的API</li>
</ol>
<p>也就是：<strong>UI组件负责UI的呈现，容器组件负责管理数据和逻辑</strong>。</p>
<p>如果 一个组件既有UI又有业务逻辑怎么办？在这种情况下需要将它进行<strong>拆分</strong>，<strong>外面是一个容器组件，里面包含一个UI组件</strong>。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p>
<p>React-Redux规定，所有的UI组件都由用户提供，容器组件则是React-Redux自动生成（通过connect）。</p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a><strong>connect</strong></h2><p>React-Redux提供connect方法，用于从UI组件生成容器组件。</p>
<p>容器组件需要有业务逻辑才是有意义的，所以为了定义业务逻辑，需要给出下面两方面的信息：</p>
<ol>
<li><strong>输入逻辑（mapStateToProps）</strong>：外部的数据（即state对象）如何转换为UI组件的参数。</li>
<li><strong>输出逻辑（mapDispatchToProps）</strong>：用户发出的动作如何变为Action对象，从UI组件传出去。</li>
</ol>
<p>connect方法的完整API为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoList为UI组件</span></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">mapStateToProps,</span><br><span class="line">mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure>



<h2 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a><strong>mapStateToProps()</strong></h2><p>mapStateToProps是一个函数，接受state作为参数，返回一个对象：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">    currentAlbum: state.getIn([<span class="string">"album"</span>, <span class="string">"currentAlbum"</span>]),</span><br><span class="line">    enterLoading: state.getIn([<span class="string">"album"</span>, <span class="string">"enterLoading"</span>]),</span><br><span class="line">    songsCount: state.getIn([<span class="string">"player"</span>, <span class="string">"playList"</span>]).size,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210107173307.png" alt></p>
<p>mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。</p>
<h2 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a><strong>mapDispatchToProps()</strong></h2><p>mapDispatchToProps是connect函数的第二个参数，用来建立UI组件的参数（props）到store.dispatch方法的映射。它定义了哪些用户的操作应该当做Action，传给Store。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getAlbumDataDispatch(id) &#123;</span><br><span class="line">            dispatch(changeEnterLoading(<span class="literal">true</span>));</span><br><span class="line">            dispatch(getAlbumList(id));</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210107173320.png" alt></p>
<p>组件内部就可以通过以下方式获取数据和方法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; </span><br><span class="line">    currentAlbum,</span><br><span class="line">    enterLoading,</span><br><span class="line">    songsCount,</span><br><span class="line">  &#125; = props;</span><br><span class="line"><span class="keyword">const</span> &#123; getAlbumDataDispatch &#125; = props;</span><br></pre></td></tr></table></figure>



<p>export组件的时候需要用connect包裹：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(React.memo(Album));</span><br></pre></td></tr></table></figure>



<h2 id="Provider组件"><a href="#Provider组件" class="headerlink" title="Provider组件"></a><strong>Provider组件</strong></h2><p>connect方法生成组件以后，需要让容器组件拿到state对象（比如mapStateToProps的参数state），才能生成UI组件的参数。</p>
<p>React-Redux提供Provider组件，可以让容器组件拿到state。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; renderRoutes &#125; <span class="keyword">from</span> <span class="string">'react-router-config'</span>;</span><br><span class="line"><span class="keyword">import</span> routes <span class="keyword">from</span> <span class="string">'./routes/index.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">          &#123;renderRoutes(routes)&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, compose, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, composeEnhancers(</span><br><span class="line"><span class="comment">// 用于异步操作，使得dispatch能够接受函数作为参数，自动发出第二个action</span></span><br><span class="line">applyMiddleware(thunk)</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>



<p>Provider在根组件外包了一层，这样一来，App的所有子组件就默认都能拿到state。</p>
<p>它的原理是React组件的context属性，可以看<a href="https://docs.qq.com/doc/DTEJBZWZjaWxiRkd1" target="_blank" rel="noopener">context笔记</a>。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>egg.js+react SSR实践</title>
    <url>/2021/01/19/egg-js-react-SSR%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做毕设的调研，想学一下如何用node进行后台开发，选择的后台框架是阿里的<code>egg.js</code>，结合<code>mysql</code>数据库、<code>DBeaver</code>数据库管理工具和<code>Sequelize</code>实现CRUD操作。</p>
<h1 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h1><p>首先介绍一下<code>egg</code>初始化生成的项目各个部分的功能。</p>
<p>一个<code>egg</code>项目目录组成大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egg-project</span><br><span class="line">├── package.json</span><br><span class="line">├── app.js (可选)</span><br><span class="line">├── agent.js (可选)</span><br><span class="line">├── app</span><br><span class="line">|   ├── router.js</span><br><span class="line">│   ├── controller</span><br><span class="line">│   |   └── home.js</span><br><span class="line">│   ├── service (可选)</span><br><span class="line">│   |   └── user.js</span><br><span class="line">│   ├── middleware (可选)</span><br><span class="line">│   |   └── response_time.js</span><br><span class="line">│   ├── schedule (可选)</span><br><span class="line">│   |   └── my_task.js</span><br><span class="line">│   ├── public (可选)</span><br><span class="line">│   |   └── reset.css</span><br><span class="line">│   ├── view (可选)</span><br><span class="line">│   |   └── home.tpl</span><br><span class="line">│   └── extend (可选)</span><br><span class="line">│       ├── helper.js (可选)</span><br><span class="line">│       ├── request.js (可选)</span><br><span class="line">│       ├── response.js (可选)</span><br><span class="line">│       ├── context.js (可选)</span><br><span class="line">│       ├── application.js (可选)</span><br><span class="line">│       └── agent.js (可选)</span><br><span class="line">├── config</span><br><span class="line">|   ├── plugin.js</span><br><span class="line">|   ├── config.default.js</span><br><span class="line">│   ├── config.prod.js</span><br><span class="line">|   ├── config.test.js (可选)</span><br><span class="line">|   ├── config.local.js (可选)</span><br><span class="line">|   └── config.unittest.js (可选)</span><br><span class="line">└── test</span><br><span class="line">    ├── middleware</span><br><span class="line">    |   └── response_time.test.js</span><br><span class="line">    └── controller</span><br><span class="line">        └── home.test.js</span><br></pre></td></tr></table></figure>



<h2 id="app-router-js"><a href="#app-router-js" class="headerlink" title="app/router.js"></a><code>app/router.js</code></h2><p>用于配置URL路由规则。即描述请求URL和具体承担执行动作的<code>Controller</code>的对应关系。</p>
<p><code>app/router.js</code>里面定义URL路由规则：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.get(<span class="string">'/user/:id'</span>, controller.user.info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>app/controller</code>目录下面实现<code>Controller</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/controller/user.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> info() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      name: <span class="string">`hello <span class="subst">$&#123;ctx.params.id&#125;</span>`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户执行<code>GET /user/123</code>，<code>user.js</code>这个里面的<code>info</code>方法就会执行。</p>
<p>一些路由定义方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.get(<span class="string">'/home'</span>, controller.home);</span><br><span class="line">  router.get(<span class="string">'/user/:id'</span>, controller.user.page);</span><br><span class="line">  router.post(<span class="string">'/admin'</span>, isAdmin, controller.admin);</span><br><span class="line">  router.post(<span class="string">'/user'</span>, isLoginUser, hasAdminPermission, controller.user.create);</span><br><span class="line">  router.post(<span class="string">'/api/v1/comments'</span>, controller.v1.comments.create); <span class="comment">// app/controller/v1/comments.js</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="RESTful风格的URL定义"><a href="#RESTful风格的URL定义" class="headerlink" title="RESTful风格的URL定义"></a><code>RESTful</code>风格的URL定义</h3><p>如果想通过<code>RESTful</code>的方式来定义路由，<code>egg</code>提供了<code>app.router.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller)</code>快速在一个路径上生成<code>CRUD</code>路由结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.resources(<span class="string">'posts'</span>, <span class="string">'/api/posts'</span>, controller.posts);</span><br><span class="line">  router.resources(<span class="string">'users'</span>, <span class="string">'/api/v1/users'</span>, controller.v1.users); <span class="comment">// app/controller/v1/users.js</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码就在 <code>/posts</code> 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 <code>app/controller/posts.js</code> 接下来， 你只需要在 <code>posts.js</code> 里面实现对应的函数就可以了。</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Path</th>
<th>Route Name</th>
<th>Controller.Action</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>/posts</td>
<td>posts</td>
<td>app.controllers.posts.index</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/new</td>
<td>new_post</td>
<td>app.controllers.posts.new</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.show</td>
</tr>
<tr>
<td>GET</td>
<td>/posts/:id/edit</td>
<td>edit_post</td>
<td>app.controllers.posts.edit</td>
</tr>
<tr>
<td>POST</td>
<td>/posts</td>
<td>posts</td>
<td>app.controllers.posts.create</td>
</tr>
<tr>
<td>PUT</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.update</td>
</tr>
<tr>
<td>DELETE</td>
<td>/posts/:id</td>
<td>post</td>
<td>app.controllers.posts.destroy</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/controller/posts.js</span></span><br><span class="line">exports.index = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.new = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.create = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.show = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.edit = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.update = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">exports.destroy = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果我们不需要其中的某几个方法，可以不用在 <code>posts.js</code> 里面实现，这样对应 URL 路径也不会注册到 Router。</p>
<h2 id="app-controller"><a href="#app-controller" class="headerlink" title="app/controller/**"></a><code>app/controller/**</code></h2><p><code>Controller</code>负责解析用户的输入，处理后返回相应的结果。<code>egg</code>推荐<code>Controller</code>层主要对用户的请求参数进行处理（校验、转换），然后调用对应的<code>service</code>方法处理业务，得到业务结果后封装并返回。简单来说，<code>Controller</code>是接口，而具体涉及到操作表的事情交给<code>service</code>来做。</p>
<h3 id="如何编写Controller"><a href="#如何编写Controller" class="headerlink" title="如何编写Controller"></a>如何编写Controller</h3><p>所有的<code>Controller</code>文件都必须放在<code>app/controller</code>目录下，可以支持多级目录，访问的时候可以通过目录名级联访问。</p>
<p>推荐使用<code>controller</code>类的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/controller/post.js</span></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> create() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx, service &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> createRule = &#123;</span><br><span class="line">      title: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</span><br><span class="line">      content: &#123; <span class="attr">type</span>: <span class="string">'string'</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    ctx.validate(createRule);</span><br><span class="line">    <span class="comment">// 组装参数</span></span><br><span class="line">    <span class="keyword">const</span> author = ctx.session.userId;</span><br><span class="line">    <span class="keyword">const</span> req = <span class="built_in">Object</span>.assign(ctx.request.body, &#123; author &#125;);</span><br><span class="line">    <span class="comment">// 调用 Service 进行业务处理</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> service.post.create(req);</span><br><span class="line">    <span class="comment">// 设置响应内容和响应状态码</span></span><br><span class="line">    ctx.body = &#123; <span class="attr">id</span>: res.id &#125;;</span><br><span class="line">    ctx.status = <span class="number">201</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = PostController;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个<code>PostController</code>的类，类里面的每一个方法都可以作为一个<code>Controller</code>在<code>Router</code>中引用到，我们可以从<code>app.controller</code>根据文件名和方法名定位到它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.post(<span class="string">'createPost'</span>, <span class="string">'/api/posts'</span>, controller.post.create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Controller 支持多级目录，例如如果我们将上面的 Controller 代码放到 <code>app/controller/sub/post.js</code> 中，则可以在 router 中这样使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.post(<span class="string">'createPost'</span>, <span class="string">'/api/posts'</span>, app.controller.sub.post.create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>项目中的<code>Controller</code>类继承于<code>egg.Controller</code>，会有几个属性挂在<code>this</code>上：</p>
<ul>
<li><code>this.ctx</code>：当前请求的上下文<code>Context</code>对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。</li>
<li><code>this.app</code>：当前应用<code>Application</code>对象的实例，通过它我们可以拿到框架提供的全局对象和方法。</li>
<li><code>this.service</code>：应用定义的 <a href="https://eggjs.org/zh-cn/basics/service.html" target="_blank" rel="noopener">Service</a>，通过它我们可以访问到抽象出的业务层，等价于 <code>this.ctx.service</code> 。</li>
<li><code>this.config</code>：应用运行时的<a href="https://eggjs.org/zh-cn/basics/config.html" target="_blank" rel="noopener">配置项</a>。</li>
<li><code>this.logger</code>：logger 对象。</li>
</ul>
<h2 id="app-service"><a href="#app-service" class="headerlink" title="app/service/**"></a><code>app/service/**</code></h2><p>用于编写业务逻辑层，可选，建议使用。<code>Service</code>就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处：</p>
<ul>
<li>保持<code>Controller</code>中的逻辑更加简洁。</li>
<li>保持业务逻辑的独立性，抽象出来的<code>Service</code>可以被多个<code>Controller</code>重复调用。</li>
</ul>
<p>下面就通过一个完整的例子，看看怎么使用 Service。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/router.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  app.router.get(<span class="string">'/user/:id'</span>, app.controller.user.info);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/controller/user.js</span></span><br><span class="line"><span class="keyword">const</span> Controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> info() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> userId = ctx.params.id;</span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">await</span> ctx.service.user.find(userId);</span><br><span class="line">    ctx.body = userInfo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserController;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app/service/user.js</span></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">'egg'</span>).Service;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 默认不需要提供构造函数。</span></span><br><span class="line">  <span class="comment">// constructor(ctx) &#123;</span></span><br><span class="line">  <span class="comment">//   super(ctx); 如果需要在构造函数做一些处理，一定要有这句话，才能保证后面 `this.ctx`的使用。</span></span><br><span class="line">  <span class="comment">//   // 就可以直接通过 this.ctx 获取 ctx 了</span></span><br><span class="line">  <span class="comment">//   // 还可以直接通过 this.app 获取 app 了</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">async</span> find(uid) &#123;</span><br><span class="line">    <span class="comment">// 假如 我们拿到用户 id 从数据库获取用户详细信息</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.db.query(<span class="string">'select * from user where uid = ?'</span>, uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假定这里还有一些复杂的计算，然后返回需要的信息。</span></span><br><span class="line">    <span class="keyword">const</span> picture = <span class="keyword">await</span> <span class="keyword">this</span>.getPicture(uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: user.user_name,</span><br><span class="line">      age: user.age,</span><br><span class="line">      picture,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> getPicture(uid) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.curl(<span class="string">`http://photoserver/uid=<span class="subst">$&#123;uid&#125;</span>`</span>, &#123; <span class="attr">dataType</span>: <span class="string">'json'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curl http://127.0.0.1:7001/user/1234</span></span><br></pre></td></tr></table></figure>



<h2 id="config-config-default-js"><a href="#config-config-default-js" class="headerlink" title="config/config.default.js"></a><code>config/config.default.js</code></h2><p>用于编写配置文件。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * built-in config</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type <span class="type">&#123;Egg.EggAppConfig&#125;</span></span></span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">const</span> config = (exports = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use for cookie sign key, should change to your own and keep security</span></span><br><span class="line">  config.keys = app.name + <span class="string">'_1610862343048_2407'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your middleware config here</span></span><br><span class="line">  config.middleware = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your user config here</span></span><br><span class="line">  <span class="keyword">const</span> userConfig = &#123;</span><br><span class="line">    <span class="comment">// myAppName: 'egg',</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  config.static = &#123;</span><br><span class="line">    prefix: <span class="string">'/public/'</span>,</span><br><span class="line">    dir: path.join(app.baseDir, <span class="string">'public'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 配置和ssr相关项</span></span><br><span class="line">  config.reactssr = &#123;</span><br><span class="line">    layout: path.join(app.baseDir, <span class="string">'app/view/layout.html'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 配置sequelize，与mysql数据源连接</span></span><br><span class="line">  config.sequelize = &#123;</span><br><span class="line">    dialect: <span class="string">'mysql'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    database: <span class="string">'eggtest'</span>,</span><br><span class="line">    username: <span class="string">'root'</span>,</span><br><span class="line">    password: <span class="string">'*****'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不进行csrf攻击检测，使用postman时需要配置</span></span><br><span class="line">  config.security = &#123;</span><br><span class="line">    csrf: &#123;</span><br><span class="line">      enable: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...config,</span><br><span class="line">    ...userConfig,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="config-plugin-js"><a href="#config-plugin-js" class="headerlink" title="config/plugin.js"></a><code>config/plugin.js</code></h2><p>用于配置需要加载的插件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugin.js</span></span><br><span class="line">exports.static = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">exports.reactssr = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-view-react-ssr'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.sequelize = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-sequelize'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// plugin.local.js</span></span><br><span class="line">exports.webpack = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-webpack'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.webpackreact = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-webpack-react'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="app-model"><a href="#app-model" class="headerlink" title="app/model/**"></a><code>app/model/**</code></h2><p>用于放置领域模型，可选，由领域类相关插件约定，如 <a href="https://github.com/eggjs/egg-sequelize" target="_blank" rel="noopener">egg-sequelize</a>。</p>
<p>其余配置见<code>egg</code>官网介绍：<a href="https://eggjs.org/zh-cn/basics/structure.html" target="_blank" rel="noopener">目录结构</a>。</p>
<h1 id="简单的CRUD功能的实现"><a href="#简单的CRUD功能的实现" class="headerlink" title="简单的CRUD功能的实现"></a>简单的CRUD功能的实现</h1><p>通过下面这个例子，我们简单地实现一个前端通过事件向后台发起请求，后台进行处理，操作数据库，然后响应结果的过程。</p>
<h2 id="MySQL下载"><a href="#MySQL下载" class="headerlink" title="MySQL下载"></a><code>MySQL</code>下载</h2><p>在编码之前，首先要在本机上安装好<code>MySQL</code>，下载地址：<a href="https://dev.mysql.com/downloads/installer/" target="_blank" rel="noopener">MySQL</a>。要下载大的<code>MSI</code>版本，不要下载zip，下载zip一直没成功。</p>
<p>下载好<code>MySQL</code>之后，配置环境变量，使得直接在<code>cmd</code>的根目录下输入<code>mysql</code>指令可以被识别，否则每次都得进入<code>MySQL</code>安装包的<code>bin</code>文件夹下<code>cmd</code>。</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210119222128.png" style="zoom: 67%;">



<h2 id="DBeaver下载"><a href="#DBeaver下载" class="headerlink" title="DBeaver下载"></a><code>DBeaver</code>下载</h2><p>下载<code>DBeaver</code>客户端，对<code>MySQL</code>数据库进行管理。</p>
<p>在<code>DBeaver</code>中可以通过指令创建表，查看表目前的情况：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210119222534.png" alt></p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210119222623.png" alt></p>
<p>关于<code>DBeaver</code>连接<code>MySQL</code>数据库可参考文章：<a href="https://blog.csdn.net/qq_38967136/article/details/87896109" target="_blank" rel="noopener">DBeaver连接MySQL</a>。</p>
<p>在连接过程中会遇到这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DBeaver连接mysql失败：Unable to load authentication plugin &#39;caching_sha2_password&#39;.</span><br></pre></td></tr></table></figure>

<p>这个是因为，<code>mysql8</code>之前的版本使用的密码加密规则是<code>mysql_native_password</code>，但是在<code>mysql8</code>则是<code>caching_sha2_password</code>，所以需要修改密码加密规则。</p>
<p>所以接下来要做的事情就是修改<code>MySQL</code>使用的密码加密规则。</p>
<p>打开<code>cmd</code>对话框，输入<code>mysql -u root -p</code>后回车，然后会提示输入密码，输入密码后就会进入MySQL的操作管理界面。 </p>
<p>使用 <code>use mysql</code>打开数据库 和 <code>select user,host,plugin from user;</code> 查看用户，主机，插件。</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/20200210142851618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk1MTc2Mw==,size_16,color_FFFFFF,t_70" alt="默认插件caching_sha2_password"></p>
<p>接下来开始修改默认插件<code>alter user &#39;root&#39; @&#39;localhost&#39; identified with mysql_native_password by &#39;root&#39;;</code> by后面输入密码，可以通过该语句修改密码，若不需要修改密码则输入原来的密码。</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/20200210144306572.png" alt="修改密码"></p>
<p>再次输入 <code>select user,host,plugin from user;</code> 查看用户，主机，插件。</p>
<p><img src="/images/loading.png" data-original="https://img-blog.csdnimg.cn/20200210144556939.png" alt="查看修改后的密码插件"></p>
<p>到这里就可以正常连接<code>MySQL</code>了。</p>
<h2 id="Sequelize安装及配置"><a href="#Sequelize安装及配置" class="headerlink" title="Sequelize安装及配置"></a><code>Sequelize</code>安装及配置</h2><p>安装并配置<code>egg-sequelize</code>插件（它会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上）和 <code>mysql2</code>模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save egg-sequelize mysql2</span><br></pre></td></tr></table></figure>

<p>在 <code>config/plugin.js</code> 中引入 <code>egg-sequelize</code> 插件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.sequelize = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-sequelize'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>config/config.default.js</code> 中编写 <code>sequelize</code> 配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.sequelize = &#123;</span><br><span class="line">    dialect: <span class="string">'mysql'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    database: <span class="string">'eggtest'</span>, <span class="comment">// 数据库名称</span></span><br><span class="line">    username: <span class="string">'root'</span>,</span><br><span class="line">    password: <span class="string">'******'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>我们可以在<code>MySQL</code>应用内或者通过<code>mysql</code>指令在本地创建一个数据库<code>eggtest</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// mysql指令</span><br><span class="line">mysql -u root -e <span class="string">'CREATE DATABASE IF NOT EXISTS `eggtest`;'</span></span><br></pre></td></tr></table></figure>



<p>因为<code>DBeaver</code>连接<code>MySQL</code>时需要连接已经存在的数据库，所以要在<code>MySQL</code>中事先创建一个数据库。</p>
<p>然后再<code>DBeaver</code>中通过指令创建<code>user</code>表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> eggTest.<span class="string">`user`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line"><span class="string">`age`</span>  <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4</span><br><span class="line"><span class="keyword">COLLATE</span>=utf8mb4_0900_ai_ci</span><br><span class="line"><span class="keyword">COMMENT</span>=<span class="string">'eggTest用户信息'</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以在<code>MySQL</code>和<code>DBeaver</code>中都看到这个新建的表了。</p>
<h2 id="完成CRUD功能"><a href="#完成CRUD功能" class="headerlink" title="完成CRUD功能"></a>完成CRUD功能</h2><p>项目目录：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120092815.png" style="zoom:80%;">



<p><code>config/plugin.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.sequelize = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-sequelize'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>config/default.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加数据库配置</span></span><br><span class="line">config.sequelize = &#123;</span><br><span class="line">    dialect: <span class="string">'mysql'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    database: <span class="string">'eggtest'</span>,</span><br><span class="line">    username: <span class="string">'root'</span>,</span><br><span class="line">    password: <span class="string">'*******'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>model/user.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; STRING, INTEGER &#125; = app.Sequelize;</span><br><span class="line">  <span class="keyword">const</span> user = app.model.define(</span><br><span class="line">    <span class="string">'user'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      id: &#123;</span><br><span class="line">        type: INTEGER(<span class="number">11</span>),</span><br><span class="line">        primaryKey: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      username: STRING(<span class="number">100</span>),</span><br><span class="line">      age: INTEGER(<span class="number">11</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      freezeTableName: <span class="literal">true</span>,</span><br><span class="line">      tableName: <span class="string">'user'</span>,</span><br><span class="line">      timestamps: <span class="literal">false</span>,</span><br><span class="line">      underscored: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> user;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><code>controller/users.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="built_in">require</span>(<span class="string">'egg'</span>).Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toInt = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> str === <span class="string">'number'</span>) <span class="keyword">return</span> str;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> str;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(str, <span class="number">10</span>) || <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">controller</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接口描述</span></span><br><span class="line"><span class="comment">   * 用户登录</span></span><br><span class="line"><span class="comment">   * 请求方式：post</span></span><br><span class="line"><span class="comment">   * 参数：&#123;</span></span><br><span class="line"><span class="comment">   * username：string</span></span><br><span class="line"><span class="comment">   * age: int</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 展示所有用户</span></span><br><span class="line">  <span class="keyword">async</span> index() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> query = &#123; <span class="attr">limit</span>: toInt(ctx.query.limit), <span class="attr">offset</span>: toInt(ctx.query.offset) &#125;;</span><br><span class="line">    ctx.body = <span class="keyword">await</span> ctx.model.User.findAll(query);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 展示用户</span></span><br><span class="line">  <span class="keyword">async</span> show() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    ctx.body = <span class="keyword">await</span> ctx.model.User.findByPk(toInt(ctx.params.id));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建用户</span></span><br><span class="line">  <span class="keyword">async</span> create() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建用户'</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, age &#125; = ctx.request.body;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> ctx.model.User.create(&#123; username, age &#125;);</span><br><span class="line">    ctx.status = <span class="number">201</span>;</span><br><span class="line">    ctx.body = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新用户</span></span><br><span class="line">  <span class="keyword">async</span> update() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> id = toInt(ctx.params.id);</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> ctx.model.User.findByPk(id);</span><br><span class="line">    <span class="keyword">if</span>(!user) &#123;</span><br><span class="line">      ctx.status = <span class="number">404</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; age &#125; = ctx.request.body;</span><br><span class="line">    <span class="keyword">await</span> user.update(&#123; age &#125;);</span><br><span class="line">    ctx.body = user;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除用户</span></span><br><span class="line">  <span class="keyword">async</span> destroy() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> id = toInt(ctx.params.id);</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> ctx.model.User.findByPk(id);</span><br><span class="line">    <span class="keyword">if</span>(!user) &#123;</span><br><span class="line">      ctx.status = <span class="number">404</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> user.destroy();</span><br><span class="line">    ctx.status = <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UserController;</span><br></pre></td></tr></table></figure>



<p><code>router.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.get(<span class="string">'/'</span>, controller.home.server);</span><br><span class="line">  router.get(<span class="string">'/client'</span>, controller.home.client);</span><br><span class="line"></span><br><span class="line">  router.resources(<span class="string">'users'</span>, <span class="string">'/users'</span>, controller.users);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="使用postman进行测试"><a href="#使用postman进行测试" class="headerlink" title="使用postman进行测试"></a>使用<code>postman</code>进行测试</h2><p>使用<code>postman</code>进行测试时注意要把<code>egg</code>的<code>csrf</code>检测关掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config/config.default.js</span></span><br><span class="line">config.security = &#123;</span><br><span class="line">    csrf: &#123;</span><br><span class="line">    enable: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>查询所有用户：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120093638.png" alt></p>
<p>根据<code>id</code>查找：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120093758.png" alt></p>
<p>新增用户（注意请求体格式选择<code>x-www-form-urlencoded</code>）：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120093914.png" alt></p>
<p>更新用户信息：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120094048.png" alt></p>
<p>删除用户：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120094152.png" alt></p>
<p>参考：<a href="https://www.cnblogs.com/xingguozhiming/p/12030268.html" target="_blank" rel="noopener">egg+sequelize+mysql实现CRUD操作</a></p>
<h2 id="与前端对接"><a href="#与前端对接" class="headerlink" title="与前端对接"></a>与前端对接</h2><p>首先安装<code>axios</code>和<code>qs</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install axios qs</span><br></pre></td></tr></table></figure>



<p>在<code>web</code>目录下新建<code>api</code>文件夹，在<code>config.js</code>文件中添加<code>axios</code>基础配置，在<code>request.js</code>中添加请求方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api/config.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> baseUrl = <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.create(&#123;</span><br><span class="line">  baseUrl: baseUrl,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    post: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axiosInstance.interceptors.response.use(</span><br><span class="line">  res =&gt; res.data,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err, <span class="string">'网络错误'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  axiosInstance,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api/request.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; axiosInstance &#125; <span class="keyword">from</span> <span class="string">'./config'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getAllUserRequest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.get(<span class="string">'/users'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> searchUserRequest = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.get(<span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createUserRequest = <span class="function">(<span class="params">&#123; username, age &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.post(</span><br><span class="line">    <span class="string">'/users'</span>,</span><br><span class="line">    qs.stringify(&#123;</span><br><span class="line">      username,</span><br><span class="line">      age,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> updateUserRequest = <span class="function">(<span class="params">id, age</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.put(</span><br><span class="line">    <span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">    qs.stringify(&#123;</span><br><span class="line">      age,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deleteUserRequest = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axiosInstance.delete(<span class="string">`/users/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>在组件中引入请求方法，并放在对应的事件处理函数中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;root&#125;/app/web/component/layout.jsx 通过 webpack alias 配置 component</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'@component/layout.jsx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  getAllUserRequest,</span><br><span class="line">  searchUserRequest,</span><br><span class="line">  createUserRequest,</span><br><span class="line">  updateUserRequest,</span><br><span class="line">  deleteUserRequest,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../../api/request'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HomeIndex</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'----componentDidMount-----'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> showAllUser = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    getAllUserRequest()</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> searchUser = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    searchUserRequest(id)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> createUser = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    createUserRequest(&#123;</span><br><span class="line">      username: <span class="string">'bella'</span>,</span><br><span class="line">      age: <span class="number">18</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> updateUser = <span class="function">(<span class="params">id, age</span>) =&gt;</span> &#123;</span><br><span class="line">    updateUserRequest(id, age)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> deleteUser = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    deleteUserRequest(id)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Layout title=<span class="string">"egg-react-ssr"</span> keywords=<span class="string">"alice"</span> description=<span class="string">"easy task"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"main"</span>&gt;</span><br><span class="line">          &lt;div className=<span class="string">"page-container page-component"</span>&gt;&#123;props.message&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;button onClick=&#123;showAllUser&#125;&gt;展示所有用户&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; searchUser(1)&#125;&gt;根据id搜索用户&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;createUser&#125;&gt;创建用户&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; updateUser(1, 19)&#125;&gt;更新用户信息&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; deleteUser(<span class="number">1</span>)&#125;&gt;删除用户&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Layout&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default HomeIndex;</span></span><br></pre></td></tr></table></figure>



<p>在前端页面触发点击事件时，可以得到相应的结果：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210120095655.png" alt></p>
<p>在这里，另一个很关键的点是<code>webpack.config.js</code>的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> rootPath = fs.realpathSync(process.cwd());</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">relativePath</span>) =&gt;</span> path.resolve(rootPath, relativePath);</span><br><span class="line"><span class="keyword">const</span> projectPath = resolve(<span class="string">'app/web'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'app/web/page/home/index.jsx'</span>, <span class="comment">// 必须是jsx，否则客户端渲染有问题</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: projectPath, <span class="comment">// 子项目根目录</span></span><br><span class="line">      <span class="string">'@component'</span>: path.resolve(projectPath, <span class="string">'component'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>entry</code>的配置必须是<code>jsx</code>结尾的文件，<code>js</code>结尾的文件会导致客户端渲染有问题，服务端的<code>console.log</code>也无法正常展示。</p>
<p>详情见<code>egg</code>官网对<code>webpack</code>的<code>entry</code>配置解释：<a href="https://www.yuque.com/easy-team/egg-react/config-webpack" target="_blank" rel="noopener">Webpack</a>。</p>
<p>项目仓库地址：<a href="https://github.com/delaprada/egg-react-ssr-example.git" target="_blank" rel="noopener">egg-react-ssr-example</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.yuque.com/easy-team/egg-react" target="_blank" rel="noopener">Egg React SSR/CSR 工程化</a></p>
<p><a href="https://eggjs.org/zh-cn/intro/" target="_blank" rel="noopener">Egg.js开发指南</a></p>
<p><a href="https://github.com/yinjiangqaq/studyDiary/blob/master/egg%E5%AE%9E%E6%88%98.md" target="_blank" rel="noopener">Egg.js+vue 实战项目</a></p>
]]></content>
      <categories>
        <category>React</category>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>http知识汇总</title>
    <url>/2020/12/07/http%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><ul>
<li>http协议是Web的应用层协议，定义了Web客户端向服务器请求页面的方式；以及服务器向客户端传送Web页面的方式。</li>
<li>它使用tcp作为它的运输层协议。</li>
<li>无状态协议，因为http服务器不保存关于客户的任何信息。</li>
<li>不安全，不会对传输的数据进行加密。</li>
</ul>
<blockquote>
<p>Q：http协议为无状态协议，如何记住用户的状态？</p>
<p>A：无状态协议的好处是快速，但是有时我想要记住用户的状态（比如：登录状态）。此时我们可以使用cookie或者session记录用户的浏览状态信息，用户身份信息。</p>
</blockquote>
<br>

<h1 id="http请求-响应报文"><a href="#http请求-响应报文" class="headerlink" title="http请求/响应报文"></a>http请求/响应报文</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><ul>
<li>由4个部分组成：请求行、请求头、空行、请求体</li>
<li>请求行由3个字段组成：请求方法、URL字段、HTTP协议版本字段<ul>
<li>请求方法有：GET、HEAD、POST、PUT、DELETE</li>
</ul>
</li>
<li>空行：告诉服务器请求头部到此为止</li>
<li>请求体：如果请求方法是GET，则为空；如果请求方法是POST，此处放置要提交的数据</li>
</ul>
<p><img src="/images/loading.png" data-original="http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902554.png" alt="这里写图片描述"></p>
<p><img src="/images/loading.png" data-original="http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902556.jpg" alt="这里写图片描述"></p>
<p>上面是POST方法，它的请求行URL段中一般是没有参数的，参数放在了报文体中。而GET方法的参数直接置于请求行URL中，报文体则为空。</p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><ul>
<li>由3个部分组成：响应行、响应头、响应体</li>
<li>响应行：由协议版本、状态码、状态描述构成</li>
</ul>
<p><img src="/images/loading.png" data-original="http://www.2cto.com/uploadfile/Collfiles/20160921/20160921092902557.jpg" alt="这里写图片描述"></p>
<br>

<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><p>1XX 通知</p>
<p>2XX 成功</p>
<p>3XX 重定向</p>
<p>4XX 客户端错误</p>
<p>5XX 服务端错误</p>
<h3 id="100（”continue”）"><a href="#100（”continue”）" class="headerlink" title="100（”continue”）"></a>100（”continue”）</h3><p>该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。</p>
<p>例如：客户端有一个较大的文件需要上传并保存，但是客户端不知道服务器是否愿意接受这个文件，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿。</p>
<p>实际操作为客户端发送一条特殊的请求报文，报文的头部应包含：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expect</span>: 100-continue</span><br></pre></td></tr></table></figure>

<p>如果服务器愿意接受，就会返回100 continue状态码。</p>
<h3 id="200（”OK”）"><a href="#200（”OK”）" class="headerlink" title="200（”OK”）"></a>200（”OK”）</h3><p>一切正常</p>
<h3 id="204-（无内容）"><a href="#204-（无内容）" class="headerlink" title="204 （无内容）"></a>204 （无内容）</h3><p>服务器成功处理了请求，但没有返回任何内容。</p>
<p>对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。</p>
<h3 id="206（部分内容）"><a href="#206（部分内容）" class="headerlink" title="206（部分内容）"></a>206（部分内容）</h3><p>这种响应是在<strong>客户端表明自己只需要目标url上的部分资源的时候返回的</strong>，这种情况经常发生在客户端继续请求一个未完成的下载时使用。</p>
<h3 id="301（Move-Permanently）"><a href="#301（Move-Permanently）" class="headerlink" title="301（Move Permanently）"></a>301（Move Permanently）</h3><p>永久性转移。将跳转到新的url地址，原本请求的资源已经不可以再访问了。</p>
<h3 id="302（Move-Temporarily）"><a href="#302（Move-Temporarily）" class="headerlink" title="302（Move Temporarily）"></a>302（Move Temporarily）</h3><p>暂时性转移。将跳转到新的url地址，原本请求的资源仍然可以被访问。</p>
<h3 id="304（”Not-Modified”）"><a href="#304（”Not-Modified”）" class="headerlink" title="304（”Not Modified”）"></a>304（”Not Modified”）</h3><p>和浏览器缓存相关。表明服务器端资源未发生改变，可以继续使用浏览器缓存中的资源。请求的时候一般结合last-modified/if-modified-since和Etag/if-none-match使用。</p>
<h3 id="400（”Bad-Request”）"><a href="#400（”Bad-Request”）" class="headerlink" title="400（”Bad Request”）"></a>400（”Bad Request”）</h3><p>请求不能被服务器理解。</p>
<h3 id="401（”unauthorized”）"><a href="#401（”unauthorized”）" class="headerlink" title="401（”unauthorized”）"></a>401（”unauthorized”）</h3><p>请求没有http认证的认证信息。</p>
<h3 id="403（”Forbidden”）"><a href="#403（”Forbidden”）" class="headerlink" title="403（”Forbidden”）"></a>403（”Forbidden”）</h3><p>请求被服务器拒绝。</p>
<h3 id="404（”Not-Found”）"><a href="#404（”Not-Found”）" class="headerlink" title="404（”Not Found”）"></a>404（”Not Found”）</h3><p>请求的资源不在服务器端。</p>
<h3 id="500（”Internet-Server-Error”）"><a href="#500（”Internet-Server-Error”）" class="headerlink" title="500（”Internet Server Error”）"></a>500（”Internet Server Error”）</h3><p>服务器方面的问题。</p>
<h3 id="502（”Bad-Gateway”）"><a href="#502（”Bad-Gateway”）" class="headerlink" title="502（”Bad Gateway”）"></a>502（”Bad Gateway”）</h3><p>作为网关或者代理的服务器向上游服务器发起请求时，从上游服务器接收到无效响应。</p>
<h3 id="504（”Gateway-Timeout”）"><a href="#504（”Gateway-Timeout”）" class="headerlink" title="504（”Gateway Timeout”）"></a>504（”Gateway Timeout”）</h3><p>作为网关或者代理的服务器向上游服务器发起请求时，未能及时从上游服务器接收到响应。</p>
<h2 id="301和302的区别"><a href="#301和302的区别" class="headerlink" title="301和302的区别"></a>301和302的区别</h2><p>共同点：301和302状态码都表示重定向，也就是说浏览器在拿到服务器返回的这个状态码之后会自动跳转到一个新的url地址。</p>
<p>区别：301表示旧地址已经被永久地移除了，这个资源不可以访问了。</p>
<p>​           302表示旧地址的资源还在，可以访问，这个重定向只是临时地从旧地址转到新地址。</p>
<h2 id="302-303-307的区别"><a href="#302-303-307的区别" class="headerlink" title="302 303 307的区别"></a>302 303 307的区别</h2><h3 id="302"><a href="#302" class="headerlink" title="302"></a>302</h3><p>当客户端向服务器发出<strong>POST</strong>请求后，收到服务器的302状态码，那么是不能自动向新的URL发送请求，必须跟用户确认是否该重发，因为第二次POST请求时，环境可能已经发生变化（POST方法不是幂等的，POST操作会不符合用户预期）。</p>
<p>也就是说：<strong>如果客户端发出非GET, HEAD请求后(比如POST请求)，收到302状态码，是不能够自动地向新的URL发送重复请求，除非得到用户的确认。</strong></p>
<h3 id="303"><a href="#303" class="headerlink" title="303"></a>303</h3><p><strong>会直接将上述的POST请求重定向为GET请求</strong></p>
<h3 id="307"><a href="#307" class="headerlink" title="307"></a>307</h3><p><strong>不会将POST转为GET，而是会询问用户是否应该在新的URL上发起POST请求</strong></p>
<br>

<h1 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h1><table>
<thead>
<tr>
<th></th>
<th>请求方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>2</td>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，<strong>用于获取报头</strong></td>
</tr>
<tr>
<td>3</td>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。OPTIONS方法请求web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法</td>
</tr>
<tr>
<td>8</td>
<td>patch</td>
<td>对已知资源进行局部更新</td>
</tr>
</tbody></table>
<h3 id="如何理解patch局部更新资源"><a href="#如何理解patch局部更新资源" class="headerlink" title="如何理解patch局部更新资源"></a><strong>如何理解<code>patch</code>局部更新资源</strong></h3><p>假设我们有一个<code>UserInfo</code>，里面有<code>userId</code>， <code>userName</code>， <code>userGender</code>等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改<code>userName</code>，这时候的更新怎么做？</p>
<p>人们通常(为徒省事)把一个包含了修改后<code>userName</code>的完整<code>userInfo</code>对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。</p>
<p>于是<code>patch</code>诞生，只传一个<code>userName</code>到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。</p>
<p>而<strong><code>put</code>虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象</strong>，理论上说，如果你用了<code>put</code>，但却没有提供完整的<code>UserInfo</code>，那么缺了的那些字段应该被清空。</p>
<p>参考：<a href="https://segmentfault.com/q/1010000005685904/" target="_blank" rel="noopener">https://segmentfault.com/q/1010000005685904/</a></p>
<br>

<h1 id="http缺陷"><a href="#http缺陷" class="headerlink" title="http缺陷"></a>http缺陷</h1><ol>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ol>
<ul>
<li><p>通信使用明文可能会被窃听</p>
<p>如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。</p>
</li>
<li><p>不验证通信方的身份，可能遭遇伪装</p>
<p>在http协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。</p>
</li>
</ul>
<p>摘自：<a href="https://blog.csdn.net/wangxp423/article/details/80033225" target="_blank" rel="noopener">https://blog.csdn.net/wangxp423/article/details/80033225</a></p>
<br>

<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><ul>
<li>http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，设计了SSL（Secure Sockets Layer）/ TLS（Transport Layer Security）协议用于对http协议传输的数据进行加密，从而诞生了https。</li>
<li>因此，https很安全。此外，https同时也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。</li>
</ul>
<h2 id="SSL-TLS握手过程"><a href="#SSL-TLS握手过程" class="headerlink" title="SSL/TLS握手过程"></a>SSL/TLS握手过程</h2><p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/2.jpg" alt></p>
<ol>
<li>Client Hello</li>
</ol>
<p>握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数<strong>Random1</strong>，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。</p>
<ol start="2">
<li>Server Hello</li>
</ol>
<p>第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数<strong>Random2</strong>，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。</p>
<p>注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。</p>
<ol start="3">
<li>Certificate</li>
</ol>
<p>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<ol start="4">
<li>Server Hello Done</li>
</ol>
<p>Server Hello Done通知客户端Server Hello过程结束。</p>
<ol start="5">
<li>Certificate Verify</li>
</ol>
<p>客户端收到服务端传来的证书后，<strong>先从CA验证该证书的合法性</strong>，验证通过后取出证书中的服务端公钥，再生成随机数<strong>Random3</strong>，<strong>再用服务端公钥非对称加密Random3生成PreMaster Key</strong>。</p>
<blockquote>
<p>https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的</p>
</blockquote>
<ol start="6">
<li>Client Key Exchange</li>
</ol>
<p>上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，<strong>服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3</strong>。</p>
<p>至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是<strong>使用这个秘钥进行对称加密</strong>。</p>
<p>为什么要使用三个随机数？</p>
<p>这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。</p>
<blockquote>
<p>最重要理解前六步</p>
</blockquote>
<ol start="7">
<li>Change Cipher Spec（Client）</li>
</ol>
<p>这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。</p>
<ol start="8">
<li>Encrypted Handshake Message(Client)</li>
</ol>
<p>这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。</p>
<ol start="9">
<li>Change Cipher Spec(Server)</li>
</ol>
<p>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</p>
<ol start="10">
<li>Encrypted Handshake Message(Server)</li>
</ol>
<p>这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p>
<p>Application Data</p>
<p><strong>到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输</strong>。</p>
<blockquote>
<p> 参考：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p><a href="https://juejin.im/post/584b76d3a22b9d0058d5036f" target="_blank" rel="noopener">https://juejin.im/post/584b76d3a22b9d0058d5036f</a></p>
</blockquote>
<br>

<h1 id="http1-0-1-1-2-0的区别"><a href="#http1-0-1-1-2-0的区别" class="headerlink" title="http1.0/1.1/2.0的区别"></a>http1.0/1.1/2.0的区别</h1><h2 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h2><ul>
<li>http协议老的标准是http1.0。为了提高系统的效率，http1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个tcp连接，服务器完成请求处理后立即断开tcp连接，服务器不跟踪每个客户也不记录过去的请求。连接无法复用。</li>
<li>客户端和服务器端每次建立和关闭连接是一个相对比较费时的过程，并且会严重影响客户端和服务器的性能。</li>
</ul>
<h2 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h2><ul>
<li>为了克服http1.0的这个缺陷，http1.1支持持久连接，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
<li>同时，http1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分每次请求的内容。</li>
<li>http1.1还克服了http1.0的性能问题。http1.1通过增加更多的请求头和响应头来改进和扩充http1.0的功能。</li>
</ul>
<h3 id="http1-x的缺陷"><a href="#http1-x的缺陷" class="headerlink" title="http1.x的缺陷"></a>http1.x的缺陷</h3><ul>
<li><strong>Head-Of-Line Blocking</strong>：<strong>一旦队首的请求处理太慢，就会阻塞后面请求的处理</strong>。<ul>
<li>在HTTP/1.x中，由于服务器必须按接受请求的顺序发送响应的规则限制，假设浏览器在一个（tcp）连接上发送了两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个请求的响应。</li>
</ul>
</li>
<li><strong>连接无法复用</strong>：<strong>连接无法复用会导致每次请求都会经历三次握手和慢启动</strong>。<ul>
<li>HTTP1.1虽然加入了keep-alive可以复用一部分连接，但在一些情况下仍然需要建立多个连接来避免任务阻塞问题（Head-Of-Line Blocking），比如通过并发连接和域名分片增加任务队列，这样就不至于一个队伍的任务阻塞其他所有任务。因为此时需要建立多个连接，所以一定程度上会消耗资源，给服务器性能带来性能压力。</li>
</ul>
</li>
<li><strong>协议开销大</strong>：HTTP/1.x中header内容过大（每次请求header基本不怎么变化），增加了传输的成本。</li>
<li><strong>安全因素</strong>：HTTP/1.x中传输的内容都是明文，客户端和服务端双方无法验证身份。</li>
</ul>
<h2 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h2><h3 id="http2-0比之前的协议在性能上有很大的提升："><a href="#http2-0比之前的协议在性能上有很大的提升：" class="headerlink" title="http2.0比之前的协议在性能上有很大的提升："></a>http2.0比之前的协议在性能上有很大的提升：</h3><ul>
<li><p><strong>多路复用</strong>：允许在一个连接上发送多个请求，响应多个请求。</p>
<ul>
<li>每个请求和它所对应的响应会在一个stream中</li>
<li>一个连接中可以有多个stream</li>
<li>每个stream高度独立，阻塞的stream不会影响其他stream的处理，所以可以避免Head-Of-Line Blocking。</li>
</ul>
</li>
<li><p><strong>二进制分帧</strong>：用二进制的格式去定义报文。</p>
<ul>
<li><p>http1.1的解析是基于文本的，基本文本协议的格式存在天然的缺陷。因为文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。</p>
</li>
<li><p>http2.0和http1.1报文格式区别：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201208092935.png" alt></p>
<p><img src="/images/loading.png" data-original="https://cloud.githubusercontent.com/assets/8046480/21041167/411f0f84-be24-11e6-946e-126b1036dd15.png" alt="image"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>首部压缩</strong></p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201208094221.png" alt></p>
<p>如上图所示，第2个请求的Header只有:path不一样，因此压缩空间非常可观。</p>
<p>Headers压缩的算法HPACK本身似乎很复杂(其实也不难)，但是算法思想其实非常简单的，假设我们在浏览器发起100个请求，它们的user-agent是不会变的，那我们为什么需要重复传输这个长长的字符串呢？用dictionary记录一次不就行了！</p>
</li>
<li><p><strong>服务端推送</strong>：服务端可以主动推送一些客户端之后可能会请求的资源。</p>
</li>
</ul>
<h3 id="如何升级到http2-0"><a href="#如何升级到http2-0" class="headerlink" title="如何升级到http2.0"></a>如何升级到http2.0</h3><blockquote>
<p>参考FunDebug文章：<a href="https://blog.fundebug.com/2019/10/28/speedup-fundebug-by-using-http2/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/10/28/speedup-fundebug-by-using-http2/</a></p>
</blockquote>
<p>我们使用了Nginx作为前端页面与后端接口的反向代理服务器(Reverse Proxy)，只需要修改一下Nginx配置文件就可以升级HTTP/2了，非常简单。</p>
<p>注意，在 Nginx 上 开启 HTTP/2 需要 Nginx 1.9.5 以上版本（包括1.9.5），并且需要 OpenSSL 1.0.2 以上版本(包括1.0.2)。使用<code>nginx -V</code>命令可以查看Nginx的版本信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br><span class="line">nginx version: nginx&#x2F;1.12.1</span><br><span class="line">built by gcc 6.3.0 20170516 (Debian 6.3.0-18)</span><br><span class="line">built with OpenSSL 1.1.0f  25 May 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix&#x3D;&#x2F;etc&#x2F;nginx --sbin3-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt&#x3D;&#39;-g -O2 -fdebug-prefix-map&#x3D;&#x2F;data&#x2F;builder&#x2F;debuild&#x2F;nginx-1.12.1&#x2F;debian&#x2F;debuild-base&#x2F;nginx-1.12.1&#x3D;. -specs&#x3D;&#x2F;usr&#x2F;share&#x2F;dpkg&#x2F;no-pie-compile.specs -fstack-protector-strong -Wformat -Werror&#x3D;format-security -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fPIC&#39; --with-ld-opt&#x3D;&#39;-specs&#x3D;&#x2F;usr&#x2F;share&#x2F;dpkg&#x2F;no-pie-link.specs -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#39;</span><br></pre></td></tr></table></figure>

<p>可知，我们使用的Nginx版本为1.12.1，OpenSSL版本为1.1.0f，符合要求。</p>
<p>还有一点，虽然HTTP/2标准并没有要求加密，但是所有浏览器都要求HTTP/2必须加密，这样的话，只有HTTPS才能升级HTTP/2。</p>
<p>如果你还没用过HTTPS的话，不妨看看我的博客：<a href="https://blog.fundebug.com/2018/07/06/apply-lets-encrypt-certificate/" target="_blank" rel="noopener">教你快速撸一个免费HTTPS证书</a>，其实也很简单。</p>
<p>一切前提没问题的话(Nginx&gt;=1.9.5，OpenSSL&gt;=1.0.2，HTTPS)，只需要修改1行配置，在listen指令后面添加http2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name www.fundebug.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启Nginx，升级HTTP/2就成功了，可以使用curl命令检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sI https:&#x2F;&#x2F;www.fundebug.com</span><br><span class="line">HTTP&#x2F;2 200</span><br><span class="line">server: nginx&#x2F;1.12.1</span><br><span class="line">date: Mon, 07 Oct 2019 00:12:53 GMT</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">content-length: 4892</span><br><span class="line">x-powered-by: Express</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">cache-control: public, max-age&#x3D;0</span><br><span class="line">last-modified: Sun, 06 Oct 2019 23:07:25 GMT</span><br><span class="line">etag: W&#x2F;&quot;131c-16da353dbc8&quot;</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">strict-transport-security: max-age&#x3D;15768001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>curl指令：用来请求web服务器。它的名字就是客户端（client）的URL工具的意思。</p>
<p>参考：<a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p>
</blockquote>
<h2 id="如何查看当前网站使用哪种协议"><a href="#如何查看当前网站使用哪种协议" class="headerlink" title="如何查看当前网站使用哪种协议"></a>如何查看当前网站使用哪种协议</h2><p>打开chrome的devTool（f12），选择network项：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/image-20201208095906207.png" alt></p>
<p>如果没有的话在Status一栏，点击右键，选择protocol项即可：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20201208100043.png" alt></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库学习及探索之旅</title>
    <url>/2021/02/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名开发人员，不可避免会接触到数据库。虽然大二的时候有学过数据库这门课，但终究是“纸上得来终觉浅”，没有在实际项目中运用，一切都只是“空中楼阁”。趁这次做毕设，有机会比较系统地梳理数据库相关的知识，为自己的项目设计数据库，也是一次收获颇丰的经历。</p>
<h1 id="什么是数据库系统"><a href="#什么是数据库系统" class="headerlink" title="什么是数据库系统"></a>什么是数据库系统</h1><p>数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的 大量数据的集合。</p>
<p>数据库系统的主要目标，是给用户提供一种便捷高效的方式去存储和获取信息。</p>
<h2 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h2><p>关系型数据库和非关系型数据库在使用场景上差别比较大，所以并不存在孰强孰弱，只有结合自身的业务特点才能发挥出这两类数据库的优势。</p>
<ol>
<li><p>数据存储结构</p>
<p>关系型数据库一般有固定的表结构，并且需要通过DDL（Data Definition Language）语句来修改表结构，不容易进行扩展，而非关系型数据库的存储机制就有很多，比如基于文档，K-V键值对，还有基于图等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此，如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择。</p>
</li>
<li><p>可扩展性</p>
<p>传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等印象，而一些非关系型数据库则原生就支持数据的水平扩展（比如<code>mongodb</code>的<code>sharding</code>机制）。</p>
</li>
</ol>
<p>需要注意的是，非关系型数据库不是指没有关系的数据库，非关系型数据库的英文为<strong>Not Only SQL</strong>，译为<strong>不仅仅是SQL</strong>或许更为恰当。NoSQL相对SQL来说，关联性相对更自由，限制更少，阉割了SQL的特性，所以它的性能会更好，速度也更快一些。但在一些对数据安全稳定要求更高的场景下，SQL更为适用。</p>
<p>对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p>
<p>但是近年来这两种数据库都在向着另外一个方向进化。例如：<br>NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能的雏形，比如<code>Couchbase</code>的<code>index</code>以及<code>MONGO</code>的复杂查询。对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国。<br>SQL数据库也开始慢慢进化，比如<code>HandlerSocker</code>技术的实现，可以在MYSQL上实现对于SQL层的穿透，用NOSQL的方式访问数据库，性能可以上可以达到甚至超越NOSQL数据库。可扩展性上例如<code>Percona Server</code>，可以实现无中心化的集群。</p>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="SQL-Data-Definition-DDL"><a href="#SQL-Data-Definition-DDL" class="headerlink" title="SQL Data Definition (DDL)"></a>SQL Data Definition (DDL)</h2><p>最通用的创建表的指令为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table r</span><br><span class="line"> (</span><br><span class="line"> 	A1 D1,</span><br><span class="line"> 	A2 D2,</span><br><span class="line"> 	...,</span><br><span class="line"> 	An Dn,</span><br><span class="line"> 	&lt;integrity-contraint1&gt;</span><br><span class="line"> 	&lt;integrity-constraint2&gt;</span><br><span class="line"> 	...</span><br><span class="line"> 	&lt;integrity-constraintn&gt;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<ul>
<li>r：表的名称</li>
<li>Ai：属性名称</li>
<li>Di：属性Ai的数据类型</li>
</ul>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> instructor (</span><br><span class="line">	<span class="keyword">ID</span> <span class="built_in">char</span>(<span class="number">5</span>),</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	dept_name <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	salary numberic(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> instructor <span class="keyword">values</span> (<span class="string">'10211'</span>, <span class="string">'Smith'</span>, <span class="string">'Biology'</span>, <span class="number">66000</span>)</span><br></pre></td></tr></table></figure>



<p>创建表时的<code>integrity</code> <code>constraints</code>：</p>
<ul>
<li>not null</li>
<li>primary key (A1, …, An)</li>
<li>foreign key (Am, …, An) references r</li>
</ul>
<p>删除或修改表结构（drop，alter）：</p>
<ul>
<li>drop table r （删除表及其内容）</li>
<li>delete from student （删除表中的所有内容，但保留表）</li>
<li>alter table<ul>
<li>alter table r add A D （增加，A为属性，D为属性域）</li>
<li>alter table r drop A （删除）</li>
</ul>
</li>
</ul>
<h2 id="SQL查询语句的基本结构"><a href="#SQL查询语句的基本结构" class="headerlink" title="SQL查询语句的基本结构"></a>SQL查询语句的基本结构</h2><p>SQL DML（Data manipulation language）为我们提供查询、插入、删除、更新条目的能力。</p>
<h4 id="经典的查询语句格式"><a href="#经典的查询语句格式" class="headerlink" title="经典的查询语句格式"></a>经典的查询语句格式</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Ai</code>：代表属性</li>
<li><code>ri</code>：代表关系</li>
<li>P：条件语句</li>
</ul>
<p>在<code>select</code>时加上<code>distinct</code>表示去重选择：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure>



<h4 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h4><p>select语句后可接算术表达式：+、-、*、/。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>, <span class="keyword">name</span>, salary/<span class="number">12</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure>



<h4 id="rename重命名操作"><a href="#rename重命名操作" class="headerlink" title="rename重命名操作"></a>rename重命名操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">old-name as new-name</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span>、<span class="keyword">name</span>、salary/<span class="number">12</span> <span class="keyword">as</span> monthly_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure>



<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><ul>
<li><code>percent(%)</code>：%可以匹配任何子串</li>
<li><code>underscore(_)</code>：_可以匹配任何字符</li>
</ul>
<p>以上两种字符串操作可以应用于数据库表的模糊查询中。</p>
<p>例如：寻找所有导师中名字带有<code>dar</code>的人</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%dar%'</span></span><br></pre></td></tr></table></figure>



<h4 id="tuple的排序"><a href="#tuple的排序" class="headerlink" title="tuple的排序"></a>tuple的排序</h4><p>默认是升序<code>asc</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>



<p>如果要降序需显式声明：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">order by name desc</span><br></pre></td></tr></table></figure>



<p>可以根据多个属性进行排序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">order by dept_name, name</span><br></pre></td></tr></table></figure>



<h4 id="Set-Operation"><a href="#Set-Operation" class="headerlink" title="Set Operation"></a>Set Operation</h4><ul>
<li><p>Question: Find courses that ran in Fall 2009 or in Spring 2010</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">where</span> sem=<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="string">'2009'</span>)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">(<span class="keyword">select</span> course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">where</span> sem=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="string">'2010'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Find courses that ran in Fall 2009 and in Spring 2010</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">where</span> sem=<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span>)</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line">(<span class="keyword">select</span> course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">where</span> sem=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Find courses that ran in Fall 2009 but not in Spring 2010</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">where</span> sem=<span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span>)</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line">(<span class="keyword">select</span> course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">where</span> sem=<span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span>=<span class="number">2009</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以上所有的Set Operation都是自动去重的。</p>
<h4 id="聚集函数Aggregate-Functions"><a href="#聚集函数Aggregate-Functions" class="headerlink" title="聚集函数Aggregate Functions"></a>聚集函数Aggregate Functions</h4><p>聚集函数是对一组数据进行计算，并返回单一结果的函数。除了<code>count(*)</code>以外，聚集函数会忽略<code>null</code>值。聚集函数通常在<code>select</code>语句中会使用<code>group by</code>从句。</p>
<p>只能在以下情况中将聚集函数作为表达式：</p>
<ul>
<li>the select list of a SELECT statement (either a subquery or an outer query).</li>
<li>a having clause</li>
</ul>
<p>常用的聚集函数：</p>
<ul>
<li><code>Count()</code></li>
<li><code>Sum()</code></li>
<li><code>Avg()</code></li>
<li><code>Min()</code></li>
<li><code>Max()</code></li>
</ul>
<p><code>Count()</code>和<code>Sum()</code>的区别在于：<code>Count()</code>是用于计算元组数量，<code>Sum()</code>是用于计算元组的内容总和。</p>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>SQL join语句是基于两个或两个以上表的共同属性来合并表的数据或者行。</p>
<table>
<thead>
<tr>
<th>Join Types</th>
<th>Join Conditions</th>
</tr>
</thead>
<tbody><tr>
<td>inner join</td>
<td>natural</td>
</tr>
<tr>
<td>left outer join</td>
<td>on <predicate></predicate></td>
</tr>
<tr>
<td>right outer join</td>
<td>using (A1, A2, …, An)</td>
</tr>
<tr>
<td>full outer join</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Join Conditions：用于定义哪些属性在多个关系中是要匹配的</li>
<li>Join Types：用于定义哪一个关系中的<code>turple</code>在没有匹配到任何其他关系中的<code>turple</code>时仍然保留</li>
</ul>
<p>natural join默认是inner join，它也可以是left outer join或者right outer join。表达的时候，使用natural join表示inner join内连接，natural left outer join或left outer join表示左外连接，natural right outer join或right outer join表示右外连接。</p>
<p>例如：</p>
<p>course表：</p>
<table>
<thead>
<tr>
<th>course_id</th>
<th>title</th>
<th>dept_name</th>
<th>credits</th>
</tr>
</thead>
<tbody><tr>
<td>BI0-301</td>
<td>Genetics</td>
<td>Bioloty</td>
<td>4</td>
</tr>
<tr>
<td>CS-190</td>
<td>GameDesign</td>
<td>Comp_Sci</td>
<td>4</td>
</tr>
<tr>
<td>CS-315</td>
<td>Robotics</td>
<td>Comp_Sci</td>
<td>3</td>
</tr>
</tbody></table>
<p>prereq表：</p>
<table>
<thead>
<tr>
<th>course_id</th>
<th>prereq_id</th>
</tr>
</thead>
<tbody><tr>
<td>BI0_301</td>
<td>BI0_101</td>
</tr>
<tr>
<td>CS_190</td>
<td>CS_101</td>
</tr>
</tbody></table>
<p>course natural(inner) join prereq：</p>
<table>
<thead>
<tr>
<th>course_id</th>
<th>title</th>
<th>dept_name</th>
<th>credits</th>
<th>prereq_id</th>
</tr>
</thead>
<tbody><tr>
<td>BI0_301</td>
<td>Genetics</td>
<td>Biology</td>
<td>4</td>
<td>BI0_101</td>
</tr>
<tr>
<td>CS_190</td>
<td>Game Design</td>
<td>Comp_Sci</td>
<td>4</td>
<td>CS_101</td>
</tr>
</tbody></table>
<p>自然连接是基于两个表中具有相同名称的属性来进行连接，在这个例子中就是course_id。</p>
<p>course (inner) join prereq using course_id：</p>
<table>
<thead>
<tr>
<th>course_id</th>
<th>title</th>
<th>dept_name</th>
<th>credits</th>
<th>prereq_id</th>
</tr>
</thead>
<tbody><tr>
<td>BI0_301</td>
<td>Genetics</td>
<td>Biology</td>
<td>4</td>
<td>BI0_101</td>
</tr>
<tr>
<td>CS_190</td>
<td>Game Design</td>
<td>Comp_Sci</td>
<td>4</td>
<td>CS_101</td>
</tr>
</tbody></table>
<p>因为两个表的共同属性为course_id，所以以上两种表达方式是等价的。</p>
<p>左外连接和右外连接：</p>
<ul>
<li>左外连接：保留左表的所有行，无法匹配的属性则设置为null</li>
<li>右外连接：保留右表的所有行，无法匹配的属性则设置为null</li>
</ul>
<h4 id="Built-in-Data-Types-in-SQL"><a href="#Built-in-Data-Types-in-SQL" class="headerlink" title="Built-in Data Types in SQL"></a>Built-in Data Types in SQL</h4><ul>
<li>date: date’2005-7-27’</li>
<li>time: time’09:00:30’</li>
<li>timestamp: date加上时间 ‘2005-7-27 09:00:30.75’</li>
<li>interval: subtracting a date/time/timestamp value from another gives an interval value</li>
</ul>
<h4 id="index索引"><a href="#index索引" class="headerlink" title="index索引"></a>index索引</h4><p><strong>索引</strong>是存储的表中一个特定列的值（比如Employee_Name）的<strong>数据结构</strong>（最常见的是B-Tree）。索引是在表的列上创建的。所以要记住的点是，索引包含一个表中列的值，并且这些值存储在一个数据结构中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> student</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">ID</span> <span class="built_in">varchar</span>(<span class="number">5</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">index</span> studentID_index <span class="keyword">on</span> student(<span class="keyword">ID</span>)</span><br></pre></td></tr></table></figure>



<p><strong>我们为什么需要数据库索引？</strong></p>
<p>假设我们有一个数据库表 Employee， 这个表有三个字段（列）分别是 Employee_Name、Employee_Age 和Employee_Address。假设表Employee 有上千行数据。</p>
<p>我们要从这个表中查找出所有名字是‘Jesus’的雇员信息，使用到下面这个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Employee </span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> Employee_Name = <span class="string">'Jesus'</span></span><br></pre></td></tr></table></figure>



<p><strong>如果表中没有索引会发生什么？</strong></p>
<p>如果没有索引的话，直接在数据库中进行查询，数据库需要扫描Employee表的每一行确定雇员的名字（Employee_Name）是否为’Jesus’。由于我们想要得到每个名字为Jesus的雇员信息，在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行。所以，在这种情况下，数据库要一行一行地查找直到最后一行。这就是所谓的全表扫描。</p>
<p><strong>数据库索引是怎样提升性能的？</strong></p>
<p>使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。</p>
<p><strong>什么样的数据结构可以作为索引？</strong></p>
<p>B-Tree是最常用的用于索引的数据结构。因为它们时间复杂度低，查找、删除、插入操作都可以在对数时间内完成。另外一个重要原因是，存储在B-Tree中的数据是有序的。数据库管理系统（DBMS）通常决定索引应该用哪些数据结构。但在某些情况下，你在创建索引时可以指定索引要用的数据结构。</p>
<p><strong>哈希表索引是怎样工作的？</strong></p>
<p>在寻找值时，哈希表效率极高。所以，如果使用哈希索引，对于比较字符串是否相等的查询能够极快地检索出其值。</p>
<p>比如在刚刚的查询（SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’）就可以创建在Employee_Name列上的哈希索引。哈希索引一般的工作方式是，将列的值作为索引的键值（key），和键值对应实际的值（value）是指向该表（Employee）中相应行的指针。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203100203.png" alt></p>
<p>但哈希表是无顺序的数据结构，对于很多类型的查询语句哈希索引都无能为力，比如查找所有小于40岁的员工。哈希表只适合查询键值对，也就是说查询相等的查询。</p>
<p><strong>索引是怎样提升性能的？</strong></p>
<p>索引是用来存储列值的数据结构。如果索引使用最常用的数据结构B-Tree，那么其中的数据是有序的。有序的列值可以极大地提升性能。</p>
<p>假设我们在Employee_Name这一列上创建一个B-Tree索引。这意味着我们用之前的SQL查找姓名是Jesus的雇员时，不需要再扫描全表。而是用索引查找名字为Jesus的雇员，因为索引已经是按照字母顺序排序。索引<strong>已经排序</strong>意味着查询一个名字会快很多，因为名字中首字母为J的员工都是排列在一起的。另外重要的一点是，索引同时存储了表中相应行的指针以获取其他列的数据。</p>
<p><strong>数据库索引里存了什么？</strong></p>
<p>数据库索引是创建在表的某列上的，并存储了这一列的所有值，并且，数据库索引不存储这个表中其他列的值。如果我们在Employee_Name列创建索引，那么列Employee_Age和Employee_Address上的值并不会存储在这个索引当中。如果我们把其他所有字段都存储在这个索引中，那就相当于拷贝了一整张表作为索引，这样会占用太大的空间而且会十分低效。</p>
<p><strong>索引存储了指向表中某一行的指针</strong></p>
<p>数据库索引除了存储表中某列的值外，同时还存储了指向表中相应行的指针。指针是指一块内存区域，该内存区域记录的是对硬盘上记录的相应行的数据的引用。也就是说，索引中的Employee_Name这列的某个值（或者节点）可以描述为（Jesus, 0x82829），0x82829就是包含Jesus那行数据在硬盘上的地址。如果没有这个引用，你就只能访问到一个单独的值Jesus，而这样没有意义。</p>
<p><strong>数据库怎么知道什么时候使用索引？</strong></p>
<p>当这个SQL（SELECT * FROM Employee WHERE Employee_Name = Jesus）运行时，数据库会检查在查询列上是否有索引。假设Employee_Name列上缺失创建了索引，数据库会接着检查使用这个索引做查询是否合理，因为有些场景下，使用索引比起全表扫描会更加低效。</p>
<p><strong>使用数据库索引会有什么代价？</strong></p>
<ol>
<li><p>索引会占用空间，表越大，索引占用的空间越大。</p>
</li>
<li><p>性能损失（主要是值更新操作）。当你在表中添加、删除或者更新行数据时，索引中也会有相同的操作。</p>
</li>
</ol>
<p><strong>基本原则是：如果表中某列在查询过程中使用非常频繁，那就在该列上创建索引。</strong></p>
<h4 id="Large-Object-Types"><a href="#Large-Object-Types" class="headerlink" title="Large-Object Types"></a>Large-Object Types</h4><p>Large objects (photos, videos, CAD files, etc.) are stored as a large object：</p>
<ul>
<li>Blob：binary large object</li>
<li>Clob: character large object</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Book_review clob(10KB)</span><br><span class="line"></span><br><span class="line">Image blob(10MB)</span><br><span class="line"></span><br><span class="line">Movie blob(2GB)</span><br></pre></td></tr></table></figure>

<p>When a query returns a large object, a pointer is returned rather than the large object itself.</p>
<h1 id="数据库设计以及E-R模型"><a href="#数据库设计以及E-R模型" class="headerlink" title="数据库设计以及E-R模型"></a>数据库设计以及E-R模型</h1><p>一个数据库可以被建模为：</p>
<ul>
<li>实体（<code>entity</code>）集合</li>
<li>实体之间的关系（<code>relationship</code>）</li>
</ul>
<h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>一个存在的对象，并能与其他对象区别开来。</p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>多个实体之间的联系。关系集的维度可以是二维，也可以是多维。两个实体集之间的关系就是二维关系，大多数数据库系统中的关系都是二维的。多于两个实体集之间的关系就是多维关系。</p>
<p>多维关系的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student work on research projects under the guidance of an instructor.</span><br><span class="line">Relationship proj_guide is a ternary relationship relationship between instructor, student, and project.</span><br></pre></td></tr></table></figure>



<h4 id="属性的域和类型"><a href="#属性的域和类型" class="headerlink" title="属性的域和类型"></a>属性的域和类型</h4><ul>
<li>属性的域（<code>domain</code>）：表示的是属性的取值范围</li>
<li>属性的类型（<code>types</code>）：<ul>
<li>简单和复合属性（<code>simple</code>/<code>composite</code>）</li>
<li>单值属性和多值属性（<code>single-values</code>/<code>multivalued</code>）</li>
<li>衍生属性（<code>Derives</code>）</li>
</ul>
</li>
</ul>
<h4 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h4><ul>
<li>one to one</li>
<li>one to many</li>
<li>many to one</li>
<li>many to many</li>
</ul>
<img src="/images/loading.png" data-original="C:\Users\alice\Desktop\大三\blog\Hexo\source\_posts\20210203102127.png" style="zoom:80%;">



<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203102153.png" style="zoom:80%;">



<h4 id="Participation-Constraint"><a href="#Participation-Constraint" class="headerlink" title="Participation Constraint"></a>Participation Constraint</h4><ul>
<li><p>total participation（完全参与）：一个实体集在一个关系中是完全参与的话，该实体集中的每个实体都会参与到至少一个关系中。</p>
<p>比如，在古诗词小程序中，用户和用户的朗诵作品之间存在着关系，那朗诵作品是完全参与到这个关系中的，不存在哪个朗诵作品没有对应的用户。又比如，在学生管理系统中，导师和学生之间存在着关系，但导师和学生这两个实体都不是完全参与到该关系中的，因为有些导师可能没有招收学生，有些学生也没有选择导师，这个就是部分参与（partial participation）</p>
</li>
<li><p>partial participation：一个实体集中的有些实体没有参与到关系中，则实体集的参与度就是部分参与。</p>
</li>
</ul>
<h4 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h4><ul>
<li>super key：是属性组合的集合，该集合中的每个属性组合都能够唯一地识别表中的<code>turple</code></li>
<li>candidate key：是super key的最小子集的集合</li>
<li>primary key： 其中一个candidate key会被选择为primary key</li>
</ul>
<h4 id="关系集的key"><a href="#关系集的key" class="headerlink" title="关系集的key"></a>关系集的key</h4><p>关系集可以没有属性，如果关系集有属性，那各个实体集的primary key组合起来可以形成关系集的super key。</p>
<h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203104614.png" style="zoom:80%;">

<ul>
<li>矩形代表实体集</li>
<li>菱形代表关系集</li>
<li>属性列举在矩形中</li>
<li>用下划线标识出primary key</li>
</ul>
<p>带有复合，多值，衍生属性的实体：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203104743.png" style="zoom:67%;">



<p>关系集有自身的属性：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203104818.png" style="zoom:80%;">



<h4 id="基数限制的表达"><a href="#基数限制的表达" class="headerlink" title="基数限制的表达"></a>基数限制的表达</h4><p>实体集和关系集之间，用→表示“one”，用—表示“many”。</p>
<p>one to one relationship：</p>
<p>instructor至多有一个student，student至多有一个instructor</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203105051.png" style="zoom:80%;">



<p>one to many relationship：</p>
<p>instructor可以有多个student（包括0），student至多有一个instructor</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203105250.png" style="zoom: 80%;">



<p>many to one relationship：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203110354.png" style="zoom:80%;">



<p>many to many relationship：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203110423.png" style="zoom:80%;">



<p>total participation：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203110501.png" style="zoom:80%;">



<p>使用cardinality limit：</p>
<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203110553.png" style="zoom:80%;">



<h4 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h4><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203111314.png" style="zoom:80%;">

<ul>
<li><code>top-down</code> design process: specialization</li>
<li><code>bottom-up</code> design process: generalization </li>
</ul>
<ul>
<li><code>overlapping</code>：可重叠</li>
<li><code>disjoint</code>：不可重叠，只能是两者之一</li>
</ul>
<h4 id="E-R标识总结"><a href="#E-R标识总结" class="headerlink" title="E-R标识总结"></a>E-R标识总结</h4><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203111559.png" style="zoom:80%;">

<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203111618.png" style="zoom:80%;">

<img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203111645.png" style="zoom:80%;">



<h4 id="设计关键点"><a href="#设计关键点" class="headerlink" title="设计关键点"></a>设计关键点</h4><ol>
<li>属性间不产生联系，当属性与其他实体有联系时，该属性应作为实体</li>
<li>当一个对象被表达为实体时，在其他实体中不能以属性出现，只能用联系表达</li>
</ol>
<h1 id="MySQL实践"><a href="#MySQL实践" class="headerlink" title="MySQL实践"></a>MySQL实践</h1><p>在大致了解了数据库的基础知识后，我便开始设计，搭建自己的数据库。</p>
<p>首先是画E-R图，对数据库进行简单建模：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203112545.png" alt></p>
<p>在古诗词小程序中，我建立了11个实体集和5个关系集，有些实体集之间是有继承关系的，比如composition与poems，poetry，lunyu，shijing。</p>
<p>在创建表时，选择MySQL的默认存储引擎<code>InnoDB</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line">	openid <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> openid,</span><br><span class="line">	nickname <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'昵称'</span>,</span><br><span class="line">	avatar_url <span class="built_in">varchar</span>(<span class="number">1000</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'头像地址'</span>,</span><br><span class="line">	gender <span class="built_in">int</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">comment</span> <span class="string">'性别'</span>,</span><br><span class="line">	province <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'省份'</span>,</span><br><span class="line">	city <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'城市'</span>,</span><br><span class="line">	country <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">default</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'国家'</span>,</span><br><span class="line">	primary <span class="keyword">key</span> openid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4</span><br><span class="line"><span class="keyword">COLLATE</span>=utf8mb4_general_ci</span><br><span class="line"><span class="keyword">COMMENT</span>=<span class="string">'古诗词小程序'</span>;</span><br></pre></td></tr></table></figure>



<h1 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto_increment"></a>auto_increment</h1><p>当我们在MySQL中建表时，有些属性经常会添加<code>auto_increment</code>这个属性定义，它可以用于为一个表中的记录自动生成ID。<code>auto_increment</code>是用于主键自动增长的，从1开始增长，当你把第一条记录删除时，再插入第二条数据，主键值是2，不是1。</p>
<p>在使用<code>auto_increment</code>时，应注意以下几点：</p>
<ol>
<li><code>auto_increment</code>数据列必须是主键或者是主键的一部分，且必须具备NOT NULL属性</li>
<li>当进行全表删除时，MySQL <code>auto_increment</code>会从1重新开始编号</li>
</ol>
<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>MySQL 从第一个版本发布到现在已经有了 20 多年的历史，在这么多年的发展和演变中，整个应用的体系结构变得越来越复杂：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142728.png" alt></p>
<ul>
<li>最上层：用于连接、线程处理的部分并不是 MySQL 『发明』的，很多服务都有类似的组成部分</li>
<li>第二层：包含了大多数 MySQL 的核心服务，包括了对 SQL 的解析、分析、优化和缓存等功能，存储过程、触发器和视图都是在这里实现的</li>
<li>第三层：MySQL中真正负责<strong>数据的存储和提取的存储引擎</strong>，例如：<code>InnoDB</code>、<code>MyISAM</code></li>
</ul>
<h3 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h3><p>在整个数据库体系结构中，我们可以使用不同的存储引擎来存储数据，而绝大多数存储引擎都以二进制的形式存储数据。</p>
<p>在 <code>InnoDB</code> 存储引擎中，所有的数据都被<strong>逻辑地</strong>存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142705.png" alt></p>
<p>同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 <code>innodb_page_size</code> 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142743.png" alt></p>
<p>从图中可以看出，在 <code>InnoDB</code> 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。</p>
<h3 id="如何存储记录"><a href="#如何存储记录" class="headerlink" title="如何存储记录"></a>如何存储记录</h3><p>与现有的大多数存储引擎一样，<code>InnoDB</code> 使用页作为磁盘管理的最小单位；数据在 <code>InnoDB</code> 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-200 行的记录。</p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>当 <code>InnoDB</code> 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142622.png" alt></p>
<p>但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142642.png" alt></p>
<h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p>页是 <code>InnoDB</code> 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面。</p>
<p>首先，一个 <code>InnoDB</code> 页有以下七个部分：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142606.png" alt></p>
<p>User Records就是整个页面中真正用于存放行记录的部分，而Free Space就是空余空间。</p>
<p>B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 <code>n_owned</code>、<code>next_record</code> 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引在上文中也提到，是数据库非常重要的概念，它是存储引擎能够快速定位记录的秘密武器，是对查询性能优化最有效的手段。</p>
<h4 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h4><p><code>InnoDB</code>存储引擎在绝大多数情况下使用B+树建立索引，这是关系型数据库中最为常用和有效的索引。但是 B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页，然后正如上一节所提到的，数据库把整个页读入到内存中，并在内存中查找具体的数据行。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142553.png" alt></p>
<p>B+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度。</p>
<h4 id="聚集索引和辅助索引"><a href="#聚集索引和辅助索引" class="headerlink" title="聚集索引和辅助索引"></a>聚集索引和辅助索引</h4><p>数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），它们之间的最大区别就是，聚集索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』。</p>
<h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h5><p><code>InnoDB</code>存储引擎中的表都是使用索引组织的，也就是按照键的顺序存放。聚集索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录数据。聚集索引构成的B+树是数据实际存储的形式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    last_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    age <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span>(last_name, first_name, age)</span><br><span class="line">    <span class="keyword">KEY</span>(first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果使用上面的 SQL 在数据库中创建一张表，B+ 树就会使用 <code>id</code> 作为索引的键，并在叶子节点中存储一条记录中的<strong>所有</strong>信息。</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142502.png" alt></p>
<p>聚集索引与表的物理存储方式有着非常密切的关系，所有正常的表应该<strong>有且仅有一个</strong>聚集索引（绝大多数情况下都是主键），表中的所有行记录数据都是按照<strong>聚集索引</strong>的顺序存放的。</p>
<h5 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h5><p>辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 <code>InnoDB</code> 中这个书签就是当前记录的主键。</p>
<p>如果在表 <code>users</code> 中存在一个辅助索引 <code>(first_name, age)</code>，那么它构成的 B+ 树大致就是上图这样，按照 <code>(first_name, age)</code> 的字母顺序对表中的数据进行排序，当查找到主键时，再通过聚集索引获取到整条行记录：</p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142527.png" alt></p>
<p><img src="/images/loading.png" data-original="https://delaprada-1301716802.cos.ap-guangzhou.myqcloud.com/20210203142539.png" alt></p>
<p>上图展示了一个使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://draveness.me/mysql-innodb/" target="_blank" rel="noopener">『浅入浅出』MySQL 和 InnoDB</a></p>
<p><a href="http://www.programmerinterview.com/database-sql/what-is-an-index/" target="_blank" rel="noopener">How do database indexes work? And, how do indexes help? Provide a tutorial on database indexes.</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
