<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>每日一题——合并区间</title>
    <url>/2020/03/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h2><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>将每个区间的第一个数字放入<code>start</code>数组中，将每个区间的第二个数字放入<code>end</code>数组中，对<code>start</code>数组和<code>end</code>数组进行排序。判断<code>start[i+1]</code>和<code>end[i]</code>的大小，如果前者小，则说明区间有覆盖，<code>i++</code>；如果前者大，说明区间没有覆盖，可以将这个结果<code>push</code>进结果数组<code>res</code>中，同时<code>j=i+1</code>（<code>j</code>最开始为0）。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">intervals</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start=[];</span><br><span class="line">    <span class="keyword">var</span> end=[];</span><br><span class="line">    <span class="keyword">var</span> res=[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;intervals.length;++i)&#123;</span><br><span class="line">        start.push(intervals[i][<span class="number">0</span>]);</span><br><span class="line">        end.push(intervals[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    end.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">0</span>,m=<span class="number">0</span>;n&lt;intervals.length;++n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==intervals.length<span class="number">-1</span>||start[n+<span class="number">1</span>]&gt;end[n])&#123;</span><br><span class="line">            res.push([start[m],end[n]]);</span><br><span class="line">            m=n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——编辑距离</title>
    <url>/2020/03/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">编辑距离</a></h2><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>动态规划的思想。</p>
<ul>
<li>如果<code>word1[i]===word2[j]</code>，<code>dp[i][j]=dp[i-1][j-1]</code>，也就是说<code>word1</code>的第<code>i</code>个单词和<code>word2</code>的第<code>j</code>个单词相同的话，那<code>word1</code>前<code>i</code>个单词要变为<code>word2</code>前<code>j</code>个单词的编辑次数就会等于<code>word1</code>前<code>i-1</code>和单词变为<code>word2</code>前<code>j-1</code>个单词的编辑次数。</li>
<li>如果<code>word1[i]!=word2[j]</code>，那<code>dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1</code><ul>
<li><code>dp[i-1][j-1]</code>表示替换操作，也就是将<code>word1[i]</code>替换为<code>word2[j]</code>，那<code>dp[i][j]</code>就等于<code>dp[i-1][j-1]</code>+1，也就是将<code>word1</code>前<code>i-1</code>个单词变为<code>word2</code>前<code>j-1</code>个单词所要执行的编辑次数+1（一次替换操作）。</li>
<li><code>dp[i-1][j]</code>表示删除操作，就是将<code>word1</code>前<code>i-1</code>个字符变为<code>word2</code>前<code>j</code>个字符所要执行的操作+1（一次删除操作，即将<code>word1</code>的第<code>i</code>个字符删掉）</li>
<li><code>dp[i][j-1]</code>表示插入操作，就是将<code>word1</code>前<code>i</code>个字符变为<code>word2</code>前<code>j-1</code>个字符所要执行的操作+1（一次插入操作，在<code>word1</code>插入一个和<code>word2</code>第<code>j</code>个字符一样的字符）</li>
</ul>
</li>
</ul>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">word2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDistance = <span class="function"><span class="keyword">function</span>(<span class="params">word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dp=[];</span><br><span class="line">    <span class="keyword">var</span> len1=word1.length;</span><br><span class="line">    <span class="keyword">var</span> len2=word2.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=len1;++i)&#123;</span><br><span class="line">        dp[i]=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=len1;++j)&#123;</span><br><span class="line">        dp[j][<span class="number">0</span>]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;=len2;++k)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][k]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">1</span>;n&lt;=len1;++n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">1</span>;m&lt;=len2;++m)&#123;</span><br><span class="line">            <span class="comment">//这里表示的是word1[n]==word2[m],但是因为n和m是从1开始取的,所以比较的时候要-1</span></span><br><span class="line">            <span class="keyword">if</span>(word1[n<span class="number">-1</span>]==word2[m<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[n][m]=dp[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[n][m]=<span class="built_in">Math</span>.min(dp[n<span class="number">-1</span>][m<span class="number">-1</span>],dp[n][m<span class="number">-1</span>],dp[n<span class="number">-1</span>][m])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——按摩师</title>
    <url>/2020/03/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%8C%89%E6%91%A9%E5%B8%88/</url>
    <content><![CDATA[<h2 id="面试题-17-16-按摩师"><a href="#面试题-17-16-按摩师" class="headerlink" title="面试题 17.16. 按摩师"></a><a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">面试题 17.16. 按摩师</a></h2><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>动态规划的思想。但是这题和最大上升子序列的动态规划思想不同。这题与背包问题都是要求一个对于整体来说最大的和，但是最大上升子序列是求一个最长的上升子序列，之前的数要比当前的数小才能做一次计算，和是否相邻无关，所以最大上升子序列还需要在内层加多一层循环。</p>
<p>题解：</p>
<p>最初想的方案：</p>
<p>内层多了一个循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> massage = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F=[];</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;nums.length;++m)&#123;</span><br><span class="line">        F[m]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    F[<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-2</span>;++j)&#123;</span><br><span class="line">            F[i]=<span class="built_in">Math</span>.max(F[j]+nums[i],F[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;F.length;++t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(F[t]&gt;max)&#123;</span><br><span class="line">            max=F[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>后来看评论优化的题解：</p>
<p><code>dp</code>思想：<code>F[i]=Math.max(F[i-1],F[i-2]+nums[i]);</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> massage = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F=[];</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;nums.length;++m)&#123;</span><br><span class="line">        F[m]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    F[<span class="number">1</span>]=<span class="built_in">Math</span>.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        F[i]=<span class="built_in">Math</span>.max(F[i<span class="number">-1</span>],F[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F[nums.length<span class="number">-1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>由instanceof原生实现理解__proto__和prototype的区别</title>
    <url>/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>前几天面试的时候被问到<code>instanceof</code>的原生实现，当时对<code>__proto__</code>和<code>prototype</code>的区别理解不是很透彻，一直记得的是几个月前在网上的某篇博客上看到的结论：“<code>__proto__</code>：和prototype其实是一个东西，prototype是官方所定义的属性，<code>__proto__</code>是浏览器自己对prototype所做的实现。”后来仔细再查了些文章发现似乎并不是这样。</p>
<br>

<h2 id="proto-和prototype的区别"><a href="#proto-和prototype的区别" class="headerlink" title="__proto__和prototype的区别"></a><code>__proto__</code>和<code>prototype</code>的区别</h2><h3 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h3><p>原型的定义：每个<code>js</code>对象（除了null）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。</p>
<p>比如我们定义一个构造函数<code>Person</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就创建了一个对象（function也是对象），那这个Person构造函数是有它的<code>prototype</code>的。这个Person prototype的构造函数constructor就是这个Person构造函数。我们还可以在这个Person prototype上去定义一些共享的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"Alice"</span>;</span><br><span class="line">Person.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Hello "</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写就在Person prototype上定义了公用的属性<code>name</code>和<code>sayHello</code>。</p>
<p>现在创建两个对象实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</span><br><span class="line">person1.name=<span class="string">"Emma"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">//Emma</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">//Alice</span></span><br></pre></td></tr></table></figure>

<p>我们为这个<code>person1</code>定义了它的实例属性name为”Emma”，那<code>person2</code>没有定义它的实例属性，所以它会沿着原型链去找它的原型去找是否有这个属性，因为<code>Person.prototype</code>里定义了<code>name</code>属性，所以输出<code>Alice</code>。</p>
<p>如果<code>Person.prototype</code>中没有定义<code>name</code>属性，那<code>person2.name</code>输出的是<code>undefined</code>，构造函数里的<code>this.name</code>是不起作用的。</p>
<img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/1.png" class>

<br>



<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h2><img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/4.png" class>

<p>以上这幅图大致可以说明<code>__proto__</code>和<code>prototype</code>的关系。</p>
<p>现在来说一下我们使用new去创建一个构造函数实例的时候做了些什么：</p>
<p><code>new</code>的原生实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">Parent,...args</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">	obj.__proto__=Parent.prototype;</span><br><span class="line">	<span class="keyword">var</span> res=Parent.apply(obj,args);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> res==<span class="string">"object"</span>?res:obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>new</code>创建一个实例的时候，我们将这个实例的<code>__proto__</code>指向构造函数的原型。</p>
<img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/2.png" class>

<p><code>__proto__</code>和<code>prototype</code>并不是一样的：</p>
<img src="/images/loading.png" data-original="/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/3.png" class>

<br>



<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.constructor===Person;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这个由上图可以看出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br><span class="line">person1.constructor===Person; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>但是<code>person1</code>是没有<code>constructor</code>属性的，而是通过原型链去找到<code>Person.prototype</code>上的<code>constructor</code>属性。</p>
<br>

<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a><code>Object.prototype</code></h2><p><code>Object.prototype</code>是没有原型的，<code>Object.prototype</code>就是尽头。</p>
<br>



<h2 id="instanceof的原生实现"><a href="#instanceof的原生实现" class="headerlink" title="instanceof的原生实现"></a><code>instanceof</code>的原生实现</h2><p><code>instanceof</code>在MDN当中的定义就是<code>object instanceof constructor</code>，判断这个<code>constructor</code>的<code>prototype</code>是否在<code>object</code>的原型链上。<code>object</code>原型链上的原型我们可以通过<code>__proto__</code>来去获取。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myinstanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> leftval=left.__proto__;  <span class="comment">//实例用__proto__</span></span><br><span class="line">	<span class="keyword">var</span> rightval=right.prototype;  <span class="comment">//构造函数用prototype</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(leftval==<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//Object.prototype.__proto__为null</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(leftval==rightval)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		leftval=leftval.__proto__;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise实现任务顺序执行&amp;并行执行&amp;发起ajax请求</title>
    <url>/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="Promise实现任务并行执行"><a href="#Promise实现任务并行执行" class="headerlink" title="Promise实现任务并行执行"></a>Promise实现任务并行执行</h2><p>使用<code>Promise.all</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'hi'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">result</span>=&gt;</span>result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p=<span class="built_in">Promise</span>.all([p1,p2]);</span><br><span class="line">p.then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result));</span><br></pre></td></tr></table></figure>

<br>



<h2 id="Promise实现任务顺序执行"><a href="#Promise实现任务顺序执行" class="headerlink" title="Promise实现任务顺序执行"></a>Promise实现任务顺序执行</h2><p>在<code>.then</code>里要<code>return</code>一个<code>new Promise</code>，这样后续才能继续使用<code>.then</code>执行后续操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		resolve(<span class="string">"one"</span>);</span><br><span class="line">	&#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			resolve(<span class="string">"two"</span>);</span><br><span class="line">		&#125;,<span class="number">3000</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/images/loading.png" data-original="/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/1.png" class>

<br>



<h2 id="Promise封装ajax请求"><a href="#Promise封装ajax请求" class="headerlink" title="Promise封装ajax请求"></a>Promise封装ajax请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHttpClient</span>(<span class="params">method,url,data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">            xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft XMLHttp'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> method=method||<span class="string">'GET'</span>;</span><br><span class="line">        <span class="keyword">var</span> data=data||<span class="literal">null</span>;</span><br><span class="line">        xhr.open(method,url,<span class="literal">true</span>);</span><br><span class="line">        xhr.onReadyStateChange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((xhr.status&gt;=<span class="number">200</span>&amp;&amp;xhr.status&lt;=<span class="number">300</span>)||xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">                    resolve(xhr.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.statusText));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">myHttpClient(<span class="string">'GET'</span>,url,<span class="literal">null</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>思想就是：将整个使用<code>XMLHttpRequest</code>去发起异步网络请求的操作封装在<code>new Promise</code>当中，执行函数返回一个Promise，那后续可以使用<code>.then</code>来执行后续的操作。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>设置display:none对DOM树和渲染树的影响</title>
    <url>/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h2 id="原本的样式"><a href="#原本的样式" class="headerlink" title="原本的样式"></a>原本的样式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">            background-color: lightyellow;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">        display属性testing</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/1.png" class>

<br>

<h2 id="设置display-none对渲染树的影响"><a href="#设置display-none对渲染树的影响" class="headerlink" title="设置display:none对渲染树的影响"></a>设置<code>display:none</code>对渲染树的影响</h2><p>在原本的<code>style</code>中添加上<code>display:none</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.main</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">        <span class="attribute">display</span>:none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>页面上没有显示任何东西：</p>
<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/2.png" class>

<p>所以设置<code>display:none</code>是会将节点从渲染树中摘除的。</p>
<br>



<h2 id="设置display-none对DOM树的影响"><a href="#设置display-none对DOM树的影响" class="headerlink" title="设置display:none对DOM树的影响"></a>设置<code>display:none</code>对DOM树的影响</h2><p>我们在刚才的代码中添加上一段<code>js</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> node=<span class="built_in">document</span>.getElementsByClassName(<span class="string">"main"</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(node.innerText);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/3.png" class>

<p>说明DOM树中该节点并没有消失，否则不会获取到DOM上的信息。</p>
<br>



<h2 id="设置display-none对CSS规则树的影响"><a href="#设置display-none对CSS规则树的影响" class="headerlink" title="设置display:none对CSS规则树的影响"></a>设置<code>display:none</code>对CSS规则树的影响</h2><p>我们在div当中添加style样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width:100px"</span>&gt;</span></span><br><span class="line">	display属性testing</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>script</code>中添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(node.style.width);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<img src="/images/loading.png" data-original="/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/4.png" class>

<p>说明CSS规则树中该节点的样式没有消失。</p>
<br>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——水壶问题</title>
    <url>/2020/03/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>有两个容量分别为 <em>x</em>升 和 <em>y</em>升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 <em>z</em>升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 <em>z升</em> 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <a href="https://www.youtube.com/watch?v=BVtQNK_ZUJg" target="_blank" rel="noopener">*”Die Hard”* example</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>当x=3,y=5,z=4的时候怎么倒出4L水：</p>
<ul>
<li>首先装满x，将x中的3L水倒入y中，</li>
<li>然后再装满x，将x的水倒入y中，此时只能倒2L，那x中就剩下1L水</li>
<li>将y中的水倒掉，将x中的1L水倒入</li>
<li>x再装满3L水，倒入y中，此时y就有4L水</li>
</ul>
<p>它的思路就是：x和y的最大公约数是否能够被z整除。与此同时要考虑，x和y加起来的大小是否比z要小，如果小的话就不可能装得下。还要考虑，两个壶为0的情况，因为mod操作是不能mod0的。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">y</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">z</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canMeasureWater = <span class="function"><span class="keyword">function</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">        temp=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x+y&lt;z)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">        temp=y;</span><br><span class="line">        y=x;</span><br><span class="line">        x=temp%x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>&amp;&amp;z==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>&amp;&amp;z!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(z%y==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——矩阵重叠</title>
    <url>/2020/03/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/</url>
    <content><![CDATA[<h2 id="矩形重叠"><a href="#矩形重叠" class="headerlink" title="矩形重叠"></a><a href="https://leetcode-cn.com/problems/rectangle-overlap/" target="_blank" rel="noopener">矩形重叠</a></h2><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。<br>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</p>
<p>思路：</p>
<p><img src="/images/loading.png" data-original="./%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/1.jpg" alt="img"></p>
<p>两个矩形，我们只需要关注它们离彼此最近的两个点。两个矩阵只要靠左边矩形的右上角的x比右边矩形左下角的x要小（小于等于）的话，就不会重叠；或者是，靠左边矩形的右下角的y比右边矩形右上角y要大（大于等于）的话，也不会重叠。因为rec1和rec2的顺序不一定就是rec1在左，rec2在右，所以要考虑反过来情况。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">rec1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">rec2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isRectangleOverlap = <span class="function"><span class="keyword">function</span>(<span class="params">rec1, rec2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(rec1[<span class="number">2</span>]&lt;=rec2[<span class="number">0</span>]||rec2[<span class="number">2</span>]&lt;=rec1[<span class="number">0</span>]||rec1[<span class="number">1</span>]&gt;=rec2[<span class="number">3</span>]||rec2[<span class="number">1</span>]&gt;=rec1[<span class="number">3</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——岛屿的最大面积</title>
    <url>/2020/03/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="岛屿的最大面积"><a href="#岛屿的最大面积" class="headerlink" title="岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">岛屿的最大面积</a></h2><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure>

<p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure>

<p>对于上面这个给定的矩阵, 返回 0。</p>
<p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p>
<p>思路：<br>和腐烂的橘子的思想类似，使用广度优先遍历，然后queue来实现（JS中用普通数组，使用shift来获取列头元素，不要写错成pop()，c++中队列的pop()和JS中普通数组的shift()才是对应的）。而且要另外维护一个flag数组，用来记录每个数组中的元素是否已经判断过了，如果判断过了的话，就要将flag变为true，下一次不用再去判断。</p>
<p>用JS声明二维数组的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;        <span class="comment">//一维长度为3</span></span><br><span class="line">	a[i] = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)&#123;    <span class="comment">//二维长度为5</span></span><br><span class="line">		a[i][j] = i+j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> q=[];</span><br><span class="line">    <span class="keyword">var</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> step=[[<span class="number">-1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>]]; <span class="comment">//用来进行广度遍历</span></span><br><span class="line">    <span class="keyword">var</span> flag=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n=<span class="number">0</span>;n&lt;grid.length;++n)&#123;</span><br><span class="line">        flag[n]=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> m=<span class="number">0</span>;m&lt;grid[<span class="number">0</span>].length;++m)&#123;</span><br><span class="line">            flag[n][m]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;grid.length;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>&amp;&amp;flag[i][j]==<span class="literal">false</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                q.push([i,j]);</span><br><span class="line">                flag[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(q.length!==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> temp=q.shift();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;step.length;++k)&#123;</span><br><span class="line">                        <span class="keyword">var</span> x=temp[<span class="number">0</span>]+step[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">var</span> y=temp[<span class="number">1</span>]+step[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;grid.length&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(grid[x][y]==<span class="number">1</span>&amp;&amp;flag[x][y]==<span class="literal">false</span>)&#123;</span><br><span class="line">                                q.push([x,y]);</span><br><span class="line">                                flag[x][y]=<span class="literal">true</span>;</span><br><span class="line">                                count++;</span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;res)&#123;</span><br><span class="line">                    res=count;</span><br><span class="line">                &#125;</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——最大上升子序列</title>
    <url>/2020/03/14/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure>



<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>思路：</p>
<p>动态规划的思想。先初始化每个元素的最大上升子序列长度为1。当前元素的最大上升子序列数应为在它前面比该元素小的元素的最大上升子序列数的最大值+1。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dp=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;j;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[k])&#123;</span><br><span class="line">                dp[j]=<span class="built_in">Math</span>.max(dp[k]+<span class="number">1</span>,dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> p=<span class="number">0</span>;p&lt;nums.length;++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[p]&gt;res)&#123;</span><br><span class="line">            res=dp[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解异步</title>
    <url>/2020/03/13/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p>所谓”异步”，简单说就是一个任务<strong>不是连续完成的</strong>，可以理解成该<strong>任务被人为分成两段</strong>，<strong>先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</strong>。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	XXX;</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"XXX"</span>);</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。<code>setTimeout</code>是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行<code>setTimeout</code>任务的第二部分，执行XXX。</p>
<p>如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。</p>
<br>

<br>



<h3 id="异步编程的解决方案"><a href="#异步编程的解决方案" class="headerlink" title="异步编程的解决方案"></a>异步编程的解决方案</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。<code>callback</code>的意思就是“重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<br>

<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。</p>
<p>Promise的话任务也是分为两个部分，new Promise作为第一部分立即执行，然后将执行权交给其他任务，当执行完毕后才会执行event queue当中的回调函数。</p>
<p><strong>Promise的最大问题是代码冗余</strong>：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p>
<br>

<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul>
<li>第一步，协程<code>A</code>开始执行。</li>
<li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>
<li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li>
<li>第四步，协程<code>A</code>恢复执行。</li>
</ul>
<p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<strong><code>yield</code>命令是异步两个阶段的分界线</strong>。</p>
<p>（其他代码部分属于一个协程，中间的yield部分属于另一个协程）</p>
<p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p>
<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以<strong>交出函数的执行权（即暂停执行）</strong>。</p>
<h5 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h5><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p>
<p>执行这段代码的方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行gen（）的时候，它执行了<code>var url = &#39;https://api.github.com/users/github&#39;;</code>操作，因为遇到了yield，所以交出了当前异步任务的执行权。执行.next()方法的时候才会执行<code>fetch(url)</code>操作，<code>fetch(url)</code>任务执行完毕之后，才会将执行权交还给异步任务，去执行异步任务的第二部分。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——零钱兑换</title>
    <url>/2020/03/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>



<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>



<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<p>思路：<br>动态规划的思想，每种硬币都找到当前自身的最优解，从而求出结果为amount时的最优解。在初始化的时候，要为每种金额的硬币声明一个初始的解，这个解应该是个比amount要大的值（因为解最大为amount）。这样我们在做结果判断的时候就可以知道，如果当前解是amount+1就说明没有组合能组成总金额。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">coins</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">amount</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    coins.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(coins);</span><br><span class="line">    <span class="keyword">var</span> F=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=amount;++i)&#123;</span><br><span class="line">        F[i]=amount+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=amount;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;coins.length;++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;coins[k])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                F[j]=<span class="built_in">Math</span>.min(F[j-coins[k]]+<span class="number">1</span>,F[j]);  <span class="comment">//注意此处是F[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F[amount]!==amount+<span class="number">1</span>?F[amount]:<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——腐烂的橘子</title>
    <url>/2020/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<p> <img src="/images/loading.png" data-original="./%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/oranges.png" alt="img"></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure>




<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; grid.length &lt;&#x3D; 10</span><br><span class="line">1 &lt;&#x3D; grid[0].length &lt;&#x3D; 10</span><br><span class="line">grid&#96;[i][j]&#96; 仅为 0、1 或 2</span><br></pre></td></tr></table></figure>



<p>思路：</p>
<p>广度优先搜索。广度优先搜索的话一般会使用队列的思想，深度优先搜索使用栈的思想。最主要还有如何去控制节点去上下左右遍历，所以我们要设置一个<code>locs</code>数组为：[[0,-1],[0,1],[1,0],[-1,0]]，在遍历每个队列元素时，都让它去和<code>locs</code>数组的每个元素进行相加减，得到这个元素上下左右的元素，将为1的元素（即新鲜橙子），变为2（即腐烂橙子）。因为我们要计算时间，但又不能将循环次数用来计时，所以我们将时间和节点的x，y坐标一齐作为一个元素进入队列。</p>
<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[][]&#125;</span> <span class="variable">grid</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> row=grid.length;</span><br><span class="line">    <span class="keyword">var</span> col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">var</span> queue=[];</span><br><span class="line">    <span class="keyword">var</span> locs=[[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">var</span> time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;row;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;col;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                queue.push([i,j,time]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(queue.length!==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//这是queue！！不要写成stack,先进先出是用shift</span></span><br><span class="line">        [x,y,time]=queue.shift();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;locs.length;++t)&#123;</span><br><span class="line">            <span class="keyword">var</span> new_x=x+locs[t][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> new_y=y+locs[t][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(new_x&gt;=<span class="number">0</span>&amp;&amp;new_x&lt;row&amp;&amp;new_y&gt;=<span class="number">0</span>&amp;&amp;new_y&lt;col)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[new_x][new_y]===<span class="number">1</span>)&#123;</span><br><span class="line">                    queue.push([new_x,new_y,time+<span class="number">1</span>]);</span><br><span class="line">                    grid[new_x][new_y]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> p=<span class="number">0</span>;p&lt;row;++p)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> q=<span class="number">0</span>;q&lt;col;++q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[p][q]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——版本号比较 随机生成字符串 类型比较</title>
    <url>/2020/03/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="版本号比较"><a href="#版本号比较" class="headerlink" title="版本号比较"></a>版本号比较</h2><p>比较版本号 （类似1.0.1/1.2.0/1.2/0.1）<br>实现一个方法，用于比较两个版本号（version1、version2）<br>如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则<code>x.y.z</code>，xyz均为大于等于0的整数，至少有x位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">str1,str2</span>)</span>&#123;</span><br><span class="line">    str1=str1.split(<span class="string">"."</span>);</span><br><span class="line">    str2=str2.split(<span class="string">"."</span>);</span><br><span class="line">    str1=str1.map(<span class="built_in">Number</span>);</span><br><span class="line">    str2=str2.map(<span class="built_in">Number</span>);</span><br><span class="line">    <span class="keyword">var</span> len;</span><br><span class="line">    <span class="keyword">var</span> len1=str1.length;</span><br><span class="line">    <span class="keyword">var</span> len2=str2.length;</span><br><span class="line">    <span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line">        len=len2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        len=len1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]&gt;str2[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str1[i]&lt;str2[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1===len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(compare(<span class="string">'1.0.1'</span>,<span class="string">'1.0'</span>));</span><br></pre></td></tr></table></figure>





<h2 id="随机生成字符串"><a href="#随机生成字符串" class="headerlink" title="随机生成字符串"></a>随机生成字符串</h2><p>随机生成字符串<br>实现一个随机符串生成函数 <code>randomStr()</code>，要求如下：<br>生成的随机的字符串应该以字母开头，并包含  <code>[a-z][0-9]</code> 这些字符。<br>生成的字符串长度为 8。<br>生成的字符串不能够在程序运行的生命周期中存在重复的情形。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">len,chars</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="comment">//因为Math.random()包括0但不包括1，所以可以直接乘上chars.length</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            res+=chars[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">26</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res+=chars[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*chars.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(randomString(<span class="number">8</span>,<span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span>));</span><br></pre></td></tr></table></figure>





<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><h3 id="下面代码中-a-在什么情况下会打印-1？"><a href="#下面代码中-a-在什么情况下会打印-1？" class="headerlink" title="下面代码中 a 在什么情况下会打印 1？"></a>下面代码中 a 在什么情况下会打印 1？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ?;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>)&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;</span><br><span class="line">	i:<span class="number">1</span>,</span><br><span class="line">	toString()&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>&amp;&amp;a==<span class="number">2</span>&amp;&amp;a==<span class="number">3</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>易混淆JS题目——this指向 闭包</title>
    <url>/2020/02/18/%E6%98%93%E6%B7%B7%E6%B7%86JS%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94this%E6%8C%87%E5%90%91-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>Q：代码运行结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.b = <span class="number">3</span>; &#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> a();</span><br><span class="line">a.prototype.b = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">7</span>;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c.b);</span><br></pre></td></tr></table></figure>

<p>解：</p>
<p>整个代码在变量提升之后可以写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line">a=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.b=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">c=<span class="keyword">new</span> a();</span><br><span class="line">a.prototype.b=<span class="number">9</span>;</span><br><span class="line">b=<span class="number">7</span>;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(c.b);</span><br></pre></td></tr></table></figure>

<p><strong>注意：函数声明的时候还没有执行！不要弄混了。</strong>当执行<code>c=new a()</code>的时候，会将函数a内部的this指向c，所以<code>c.b</code>此时就是3。<code>a.prototype.b=9</code>没有什么影响。<code>b=7;</code>表示将全局变量b赋值为7。此后执行了函数<code>a()</code>，要注意在默认情况下，函数中this的指向是指向全局作用域的，所以执行函数<code>a()</code>的话是把全局变量b的值变为3。所以输出的是3 3。</p>
<hr>  

<p>Q：以最小的改动解决以下代码的错误（可以使用es6）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">name: <span class="string">" jsCoder"</span>,</span><br><span class="line">skill: [<span class="string">"es6"</span>, <span class="string">"react"</span>, <span class="string">"angular"</span>],</span><br><span class="line">say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.skill.length; i&lt; len; i++)&#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'No.'</span> + i + <span class="keyword">this</span>.name);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.skill[i]);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'--------------------------'</span>);</span><br><span class="line">   &#125;, <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>

<p><img src="/images/loading.png" data-original="https://uploadfiles.nowcoder.com/images/20191107/5097896_1573106521909_62B29BD26061B47E81ED3150A290E160" alt="图片说明"></p>
<p>解：</p>
<ul>
<li>第一点：for循环当中有个异步函数，而且异步函数根据for循环<code>i</code>的值依次输出No.1，No.2，No.3，这样的话for循环中<code>i</code>必须使用let去声明，因为使用let才能让异步函数记住每一轮<code>i</code>的值，得到相应的输出结果。</li>
<li>第二点：在对象函数say中，有一个异步函数，它使用了this。源代码的意图是想让这个this表示对象<code>obj</code>，但是对象的方法say的this指向的是<code>obj</code>，但是这个方法内部的函数（使用了闭包）是指向全局变量的！这么写是得不到想要的结果的。所以要将<code>setTimeout</code>函数改为箭头函数，因为箭头函数它会继承上一层作用域的this，所以它会继承say函数的this，就会指向<code>obj</code>了。</li>
</ul>
<p>修改后的代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">" jsCoder"</span>,</span><br><span class="line">    skill: [<span class="string">"es6"</span>, <span class="string">"react"</span>, <span class="string">"angular"</span>],</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,len=<span class="keyword">this</span>.skill.length; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="comment">//闭包！！</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'No.'</span> + (i+<span class="number">1</span>) + <span class="keyword">this</span>.name);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.skill[i]);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'--------------------------'</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>



<hr>

<p>Q：repeat 实现，使用JS实现一个repeat方法，调用这个 repeatedFunc(“helloworld”)，会alert4次 helloworld, 每次间隔3秒</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> repeatFunc = repeat(alert, <span class="number">4</span>, <span class="number">3000</span>)</span><br><span class="line">repearFunc(<span class="string">"helloworld"</span>);</span><br></pre></td></tr></table></figure>

<p>解：</p>
<p>这种问题一般要结合闭包来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">func, times, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args=[].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        timer=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==(times<span class="number">-1</span>))&#123;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">            &#125;</span><br><span class="line">            func(args.join(<span class="string">""</span>));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目中说，调用<code>repeatedFunc(&quot;helloworld&quot;)</code>会有相关的结果，所以它应该是在函数中还有一个函数的，所以应该有个闭包。通过闭包可以记住count的值。注意<code>clearTimeout</code>要写在<code>setInterval</code>函数当中，这个和防抖节流不同，因为它只执行了一次函数，它是通过<code>setInterval</code>函数的循环才会输出多次结果，所以要写在里面才能够判断count的值是否已经到达输出次数。</p>
<hr>

<p>Q：实现每隔1s输出一个数组的元素及其索引</p>
<p>解：</p>
<p>这题和上一题的思路类似，但是它没有需要说要调用的时候再去执行，那就不需要写<code>return functionf(){}</code>了。因为<code>setInterval</code>函数已经是output函数的内部函数，有闭包能够记住count的值了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">output</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = arr.length;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == length - <span class="number">1</span>) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[count]);</span><br><span class="line">    <span class="built_in">console</span>.log(count);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue之计算属性的应用</title>
    <url>/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>昨天面试的时候被问到了Vue计算属性相关的代码题，又是一脸懵逼呀…赶紧来总结一下。</p>
<p>面试官先出了第一道题，点击div时输出是什么？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"b += 1"</span>&gt;</span>&#123;&#123;c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        c() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.a;</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出是3。</p>
<p>首先，computed中的属性都是以函数的形式声明的，看看官网的例子：</p>
<img src="/images/loading.png" data-original="/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/1.png" class>

<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Original message: &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">Computed reversed message: &quot;olleH&quot;</span><br></pre></td></tr></table></figure>

<p>computed属性它所依赖的数据是data当中的，是要使用this来去获取的。所以计算属性c中的<code>this.b</code>和<code>this.a</code>其实是data当中的属性值。执行点击事件之后，b是会发生变化的，所以在计算属性c中输出<code>this.b</code>是会发生变化的，所以在控制台会输出3。因为计算属性c<code>return</code>的是<code>this.a</code>，所以<code></code>的值是不变的，是1。</p>
<p>接着面试官又出了第二道题，此时又输出什么？（其实面试官人真的好好，他的表述是此时会输出么？他这么问的话我就会倾向于回答不会输出）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"b += 1"</span>&gt;</span>&#123;&#123;c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        c() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span> <span class="keyword">this</span>.a;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>答案是不输出。此时c连渲染都不会发生。</p>
<p>最后面试官又问了第三道题，此时会输出什么？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> @<span class="attr">click</span>=<span class="string">"b += 1"</span>&gt;</span>absdflj<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123; a: <span class="number">1</span>, b: <span class="number">2</span> &#125;;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      computed: &#123;</span><br><span class="line">        c() &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.b);</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.a;</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时这个计算属性并没有写在页面上，所以是不会监听c的值，此时控制台没有输出，页面显示的是：<code>absdflj</code>。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript之变量提升</title>
    <url>/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>今天面试的时候被问到了变量提升的问题，一脸懵逼，掌握得不够熟练，写篇博客来总结一下。</p>
<h2 id="JS代码解析规则"><a href="#JS代码解析规则" class="headerlink" title="JS代码解析规则"></a>JS代码解析规则</h2><ul>
<li>第一步为解释：先扫描所有的JS代码，把所有声明提升到顶端。</li>
<li>第二步为执行：执行就是操作一类的。</li>
</ul>
<br>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>例一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为有变量提升，上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><h4 id="函数声明的两种方式"><a href="#函数声明的两种方式" class="headerlink" title="函数声明的两种方式"></a>函数声明的两种方式</h4><ul>
<li><p>函数声明式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123; &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>函数字面量式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：函数字面量式的提升和变量提升一样，都是只提升声明，不提升赋值，比如上面代码中函数字面量式，只会把<code>var bar</code>提升上去，但是函数声明式是会将整个函数体都提升上去。</strong></p>
<br>

<p>例二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();  <span class="comment">//aaa</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为存在函数声明提升，函数声明提升会直接把整个函数提升到执行环境的最顶端。相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>



<p><strong>注意：变量提升只提升变量名，而函数提升是会提升整个函数体。函数提升在变量提升之前。</strong></p>
<br>

<p>例三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//foo is not a function</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/1.png" class>



<p>因为进行了变量提升（函数字面量式），上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo();</span><br><span class="line">foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS解析在遇到foo()时会默认当做函数来解析，所以会输出foo is not a function。</p>
<br>

<p>例四：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">var</span> foo=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/2.png" class>



<p>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">//foo()&#123;console.log(10);&#125;</span></span><br><span class="line">foo=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>第一个console.log(foo)之所以输出函数体，是因为<code>var foo</code>只是声明（提升了的声明），并没有赋值，所以它会调用上面的函数体。</p>
<br>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>先看一道经典面试题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(v1);</span><br><span class="line"><span class="keyword">var</span> v1 = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);</span><br><span class="line">	<span class="keyword">var</span> v1 = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(v1);</span><br></pre></td></tr></table></figure>

<p>输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;undefined</span><br><span class="line">&#x2F;&#x2F;undefined</span><br><span class="line">&#x2F;&#x2F;200</span><br><span class="line">&#x2F;&#x2F;100</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1;</span><br><span class="line"><span class="built_in">console</span>.log(v1); <span class="comment">//undefined</span></span><br><span class="line">v1=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v1;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);  <span class="comment">//undefined</span></span><br><span class="line">	v1=<span class="number">200</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(v1);  <span class="comment">//200</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(v1);  <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，如果内部没有声明v1的时候，函数才会到全局作用域去查找变量的赋值。但是如果函数作用域内部定义了的话，就不会到全局作用域去找。参照作用域链的定义。</strong></p>
<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/3.png" class>

<br>

<p>看一道字节面试时候的题目：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'byte'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">'dance'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="string">'bytedance'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;dance</span><br><span class="line">&#x2F;&#x2F;byte</span><br></pre></td></tr></table></figure>

<p>上面代码实际效果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line">	<span class="keyword">if</span>(a===<span class="literal">undefined</span>)&#123;</span><br><span class="line">		a=<span class="string">'dance'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		a=<span class="string">'bytedance'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a=<span class="string">'byte'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>在当前作用域有对变量进行声明的时候，是不会去上一级作用域去寻找变量的声明的。</p>
<img src="/images/loading.png" data-original="/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/4.png" class>

<p>因为console.log(a)在当前函数作用域找到了<code>var a;</code>，即a的定义，所以它不会去全局作用域去找a的声明（及值）。</p>
<p>上面的代码也是这个道理，<code>a===undefined</code>会找到当前函数作用域的<code>var a;</code>的定义，所以a的值为undefined。</p>
<br>

<p>参考：<a href="https://blog.csdn.net/qq_39712029/article/details/80951958" target="_blank" rel="noopener">https://blog.csdn.net/qq_39712029/article/details/80951958</a></p>
<p>​            <a href="https://blog.csdn.net/Demo_18/article/details/78493489" target="_blank" rel="noopener">https://blog.csdn.net/Demo_18/article/details/78493489</a></p>
<br>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Math.floor()和~~运算符的异同</title>
    <url>/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/</url>
    <content><![CDATA[<p>今天在用JavaScript实现大数相加的时候，发现网上的解法当中有使用<code>~~</code>运算符，之前没有见过。在网上一查，说是<code>Math.floor()</code>的更好的一种表示方法，运行速度更快。但是将大数相加的代码中的<code>~~</code>换成<code>Math.floor()</code>发觉得不到正确的答案，所以想来分析一下异同。</p>
<h2 id="和"><a href="#和" class="headerlink" title="~和~~"></a><code>~</code>和<code>~~</code></h2><h4 id="运算符"><a href="#运算符" class="headerlink" title="~运算符"></a><code>~</code>运算符</h4><p>用于将整数变为<code>-(N+1)</code>。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~2 &#x3D;&#x3D;&#x3D; -3; &#x2F;&#x2F;true</span><br><span class="line">~1 &#x3D;&#x3D;&#x3D; -2; &#x2F;&#x2F;true</span><br><span class="line">~0 &#x3D;&#x3D;&#x3D; -1; &#x2F;&#x2F;true</span><br><span class="line">~-1 &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>



<h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="~~运算符"></a><code>~~</code>运算符</h4><p><code>~~</code>是<code>Math.floor()</code>的一个替代，相同的操作但是更快。可以使用它将任何浮点数转换为整数（下取整）。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~2 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2</span><br><span class="line">~~2.4 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2</span><br><span class="line">~~3.9 &#x3D;&#x3D;&#x3D; Math.floor(3); &#x2F;&#x2F;true, 3</span><br></pre></td></tr></table></figure>



<p><code>~~</code>和<code>Math.floor()</code>在性能上的不同：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Browser</th>
<th>Math.floor()</th>
<th>Bitwise double NOT ~~</th>
</tr>
</thead>
<tbody><tr>
<td>#1</td>
<td>Firefox 7.0.1</td>
<td>42ms</td>
<td>29ms</td>
</tr>
<tr>
<td>#2</td>
<td>Firefox 7.0.1</td>
<td>44ms</td>
<td>28ms</td>
</tr>
<tr>
<td>#3</td>
<td>Chrome 15</td>
<td>63ms</td>
<td>64ms</td>
</tr>
<tr>
<td>#4</td>
<td>Chrome 15</td>
<td>63ms</td>
<td>68ms</td>
</tr>
<tr>
<td>#5</td>
<td>IE8</td>
<td>265ms</td>
<td>192ms</td>
</tr>
<tr>
<td>#6</td>
<td>IE8</td>
<td>324ms</td>
<td>190ms</td>
</tr>
</tbody></table>
<br>



<h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><p>在大数相加时，使用<code>~~</code>能够的到正确的结果：</p>
<img src="/images/loading.png" data-original="/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/1.png" class>



<p>但是使用<code>Math.floor()</code>时，结果是：</p>
<img src="/images/loading.png" data-original="/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/2.png" class>



<p>主要是因为当a数组已经pop完毕之后，再对a执行pop操作时，输出的是undefined。而<code>~~</code>操作undefined和<code>Math.floor()</code>操作undefined是会得出不同的结果的：</p>
<img src="/images/loading.png" data-original="/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/3.png" class>

<p>所以才会导致上面的结果。</p>
<br>

<p>参考：<a href="http://rocha.la/JavaScript-bitwise-operators-in-practice" target="_blank" rel="noopener">http://rocha.la/JavaScript-bitwise-operators-in-practice</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存</title>
    <url>/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="缓存过程分析："><a href="#缓存过程分析：" class="headerlink" title="缓存过程分析："></a>缓存过程分析：</h2><ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找请求的结果以及缓存标识</li>
<li>如果没有该请求的缓存结果和缓存标识的话，浏览器会向服务器发起http请求，服务器返回该请求结果和缓存规则</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<img src="/images/loading.png" data-original="/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/1.png" class>

<br>

<h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><h4 id="浏览器缓存分为：强缓存和协商缓存"><a href="#浏览器缓存分为：强缓存和协商缓存" class="headerlink" title="浏览器缓存分为：强缓存和协商缓存"></a>浏览器缓存分为：强缓存和协商缓存</h4><br>

<ul>
<li><p><strong>强缓存</strong>：不会向服务器发送请求，直接从缓存中读取资源。可以通过设置两种http header实现：Expires和Cache-Control。</p>
<ul>
<li><p>Expires是http/1的产物。它用来指定资源到期的时间，Expires是web服务器响应消息头字段，在响应http请求时<strong>告诉浏览器在过期时间之前浏览器可以直接从浏览器缓存取数据，而无需再次请求</strong>。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Thu, 10 Nov 2017 08:45:11 GMT</span><br></pre></td></tr></table></figure>

<p>这个字段设置时有两个缺点：</p>
<ol>
<li>由于是<strong>绝对时间</strong>，用户可能会将客户端本地的时间修改，而导致浏览器判断缓存失效，重新请求该资源。</li>
<li><strong>写法太复杂</strong>，表示时间的字符串多个空格，少个字母都会导致非法属性从而失效</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Cache-control是http/1.1的产物。和Expires的差别在于，Expires是绝对时间，Cache-control表示的是相对时间</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-control</span>: max-age=2592000</span><br></pre></td></tr></table></figure>

<p><code>Cache-control</code>字段常用的值：</p>
<ol>
<li><code>max-age</code>：即最大有效时间</li>
<li><code>must-revalidate</code>：如果超过了<code>max-age</code>的时间，浏览器必须向服务器发送请求，验证资源是否还有效</li>
<li><code>no-cache</code>：<strong>不是不缓存的意思！</strong>表示可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用。<ol start="4">
<li><code>no-store</code>：彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取</li>
</ol>
</li>
<li><code>public</code>：所有内容都可以被缓存（包括客户端和代理服务器，如CDN）</li>
<li><code>private</code>：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li>
</ol>
<p>自从http/1.1开始，Expires逐渐被<code>Cache-control</code>取代。<code>Cache-control</code>是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且<code>Cache-control</code>的可配置性比较强大。</p>
</li>
</ul>
<p>  强缓存判断是否缓存的依据来自于是否超出某个时间或者时间段，而不关心服务器端文件是否已经更新，这可能导致加载文件不是服务器端最新的内容。<strong>那我们如何获知服务器端内容是否已经发生了更新呢？</strong>此时我们需要用到协商缓存策略。</p>
<br>



<ul>
<li><p><strong>协商缓存</strong>：是由服务器来确定缓存资源是否可用，所以客户端与服务器端需要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p>
<p>主要有以下两种标识：</p>
<ul>
<li><p>Last-Modified和If-Modified-Since：</p>
<ul>
<li>Last-Modified：浏览器在第一次访问资源时，<strong>服务器返回资源的同时，在response header中添加Last-Modified的header</strong>，值是这个资源在服务器端的最后修改时间。</li>
<li>If-Modified-Since：浏览器下一次请求这个资源，浏览器检测有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值。服务器再次收到这个资源的请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，可以直接从缓存读取。如果服务器端这个资源在If-Modified-Since之后被修改了，说明文件有更新，返回新的资源文件和200。</li>
</ul>
</li>
</ul>
<img src="/images/loading.png" data-original="/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/2.png" class>



</li>
</ul>
<ul>
<li><p><code>Etag</code>和If-None-Match:</p>
<p><code>Etag</code>和If-None-Match返回的是一个校验码。<code>Etag</code>可以保证每一个资源是唯一的，资源变化都会导致<code>Etag</code>变化。</p>
<p>当浏览器第一次请求资源的时候，服务器会在响应报文中添加<code>Etag</code>（表示资源的标签）。当浏览器再次发起请求的时候，请求报文中会添加If-None-Match字段，其值是上一次响应报文中<code>Etag</code>的值。服务器收到请求报文的时候，会检查If-None-Match的值与当前资源<code>Etag</code>的值是否匹配。如果匹配，也就是资源没有被修改，返回304；如果不匹配，也就是服务器端资源被修改了，返回200，并返回新的资源。</p>
</li>
</ul>
<ul>
<li>为什么有了Last-Modified和If-Modified-Since还要<code>Etag</code>和If-None-Match呢？<ul>
<li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用</li>
<li>某些文件修改非常频繁，比如在秒以下级别的时间内进行修改（比如1s内修改了N次），If-Modified-Since能检查到的粒度只能是秒级别的，这种修改无法判断。</li>
</ul>
</li>
</ul>
<ul>
<li>协商缓存生效：返回304和Not Modified。即服务器端资源并没有更新，可以继续使用浏览器缓存中的结果。</li>
<li>协商缓存失败，返回200和请求结果。即服务器端资源更新了，获取服务器端的返回结果，并把请求结果和缓存标识存入浏览器缓存中</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>缓存机制：</p>
<ul>
<li><strong>强制缓存优先于协商缓存进行</strong></li>
<li><strong>若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和<code>Etag</code> / If-None-Match)</strong></li>
<li><strong>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存</strong>。</li>
<li>Last-Modified/If-Modified-Since 和 <code>Etag</code>/If-None-Match的主要区别就是一个是<strong>通过时间判断资源是否已被更改</strong>，一个是<strong>通过<code>Etag</code>来判断</strong>。<code>Etag</code>/If-None-Match相比于Last-Modified/If-Modified-Since来说更好。</li>
</ul>
<br>

<p>  摘自：<a href="https://www.cnblogs.com/yayaxuping/p/9707471.html" target="_blank" rel="noopener">https://www.cnblogs.com/yayaxuping/p/9707471.html</a></p>
<p>​             <a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect</a></p>
<br>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染过程</title>
    <url>/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="浏览器渲染的过程主要包括以下5步"><a href="#浏览器渲染的过程主要包括以下5步" class="headerlink" title="浏览器渲染的过程主要包括以下5步"></a>浏览器渲染的过程主要包括以下5步</h2><ol>
<li>浏览器将获取的HTML文档解析为DOM树</li>
<li>处理CSS标记，构成CSS规则树</li>
<li>将DOM树和CSS规则树合并为渲染树（rendering tree），生成渲染树</li>
<li>渲染树布局，确定每个节点对象在页面上的确切大小和位置</li>
<li>将渲染树的各个节点绘制到屏幕上</li>
</ol>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/1.png" class>

<br>



<h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>当浏览器接受到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。注意：DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。</p>
<h3 id="构建CSS规则树"><a href="#构建CSS规则树" class="headerlink" title="构建CSS规则树"></a>构建CSS规则树</h3><p>浏览器解析CSS文件并生成CSS规则树。注意：CSS解析可以与DOM解析同时执行，但与<code>script</code>的执行互斥。</p>
<h3 id="构建渲染树（Render-Tree）"><a href="#构建渲染树（Render-Tree）" class="headerlink" title="构建渲染树（Render Tree）"></a>构建渲染树（Render Tree）</h3><p>通过DOM树和CSS规则树，浏览器可以通过它们构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。</p>
<p>渲染树生成后，还不能渲染到屏幕上。因为渲染到屏幕上需要得到各个节点的位置信息，这就需要布局的处理。</p>
<h3 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h3><p>布局阶段从渲染树的根节点开始遍历，渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。浏览器通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。</p>
<h3 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h3><p>将渲染树绘制到浏览器上。</p>
<h4 id="主流的一些浏览器排版（渲染）引擎"><a href="#主流的一些浏览器排版（渲染）引擎" class="headerlink" title="主流的一些浏览器排版（渲染）引擎"></a>主流的一些浏览器排版（渲染）引擎</h4><table>
<thead>
<tr>
<th>浏览器</th>
<th>排版引擎</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome Opera</td>
<td>Blink</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
</tr>
<tr>
<td>Safari</td>
<td>WebKit</td>
</tr>
</tbody></table>
<br>



<h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p>渲染阻塞的原因：由于JavaScript可以操作DOM来修改DOM结构，可以操作CSS规则树来修改节点样式，这就导致浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直到脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。</p>
<p>现在可以通过在<code>&lt;script&gt;</code>标签上增加属性<code>defer</code>或者<code>async</code>，解决上述问题。这两个属性使得<code>script</code>标签不会阻塞DOM的渲染，<strong>能够异步加载script脚本，不阻塞DOM渲染</strong>。</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a><code>defer</code></h3><p>如果<code>script</code>标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行）</p>
<p>使用方法：</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/2.png" class>



<h3 id="async"><a href="#async" class="headerlink" title="async"></a><code>async</code></h3><p><code>async</code>的设置，会使得<code>script</code>脚本异步加载。<code>async</code>的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/3.png" class>



<p>用图表来展示：</p>
<p><strong>文档渲染 应该为 文档解析</strong></p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/4.png" class>



<h4 id="普通的script"><a href="#普通的script" class="headerlink" title="普通的script"></a>普通的script</h4><p>文档解析的过程中，如果遇到<code>script</code>脚本，就会停止页面的解析进行下载。</p>
<p>资源的下载是在解析过程中进行的，虽说<code>script1</code>脚本会很快的加载完毕，但是他前边的<code>script2</code>并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待<code>script2</code>执行完毕后再执行。<br>当这两个脚本都执行完毕后，才会继续解析页面。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/5.png" class>



<h4 id="defer-1"><a href="#defer-1" class="headerlink" title="defer"></a><code>defer</code></h4><p>文档解析时，遇到设置了<code>defer</code>的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。<br>会等到所有的<code>defer</code>脚本加载完毕并按照顺序执行，执行完毕后会触发<code>DOMContentLoaded</code>事件。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/6.png" class>



<h4 id="async-1"><a href="#async-1" class="headerlink" title="async"></a><code>async</code></h4><p><code>async</code>脚本会在加载完毕后执行。<br><code>async</code>脚本的加载不计入<code>DOMContentLoaded</code>事件统计，也就是说下图两种情况都是有可能发生的。</p>
<img src="/images/loading.png" data-original="/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/7.png" class>

<br>



<h2 id="浏览器的回流与重绘"><a href="#浏览器的回流与重绘" class="headerlink" title="浏览器的回流与重绘"></a>浏览器的回流与重绘</h2><p><code>回流</code>：对于整个网页重新渲染一遍。</p>
<ul>
<li>会导致回流的操作有：<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生变化</li>
<li>元素尺寸或位置发生变化</li>
<li>元素内容发生变化（文字数量或图片大小等）</li>
<li>元素字体大小变化</li>
<li>添加或删除<strong>可见</strong>的DOM元素</li>
<li>激活<code>css</code>伪类（例如<code>:hover</code>）</li>
</ul>
</li>
</ul>
<p><code>重绘</code>：浏览器只需要对某个元素进行重新绘制即可</p>
<ul>
<li>会导致重绘的操作有：<ul>
<li>修改<code>color</code>/<code>background-color</code>/<code>visibility</code></li>
</ul>
</li>
</ul>
<p>由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流操作一定会伴随重绘，重绘却不一定伴随回流。</p>
<p>那么如何针对回流和重绘写出性能更好的代码呢？</p>
<p><code>CSS</code>：</p>
<ul>
<li>避免使用<code>table</code>布局</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code></li>
<li>避免设置多层内联样式</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li>
<li>避免使用<code>css</code>表达式（例如：<code>calc()</code>）</li>
</ul>
<p><code>JavaScript</code></p>
<ul>
<li>避免频繁操作样式</li>
<li>避免频繁操作DOM。创建一个<code>documentFragment</code>，在它上面应用所有的DOM操作，最后再把它添加到文档中</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h2 id="DOM-CSS-JS之间的关系"><a href="#DOM-CSS-JS之间的关系" class="headerlink" title="DOM CSS JS之间的关系"></a>DOM CSS JS之间的关系</h2><ul>
<li>CSS是不会阻塞DOM的解析的，JS是会阻塞DOM的解析的</li>
<li>CSS是会阻塞DOM的渲染的。如果没有这个策略的话，页面首先会呈现一个原始的模样，待CSS下载完后又变成另一个模样，这样会导致用户体验变差而且渲染是有成本的。</li>
<li>JS是会等待CSS加载完才会执行的（如果CSS文件在JS文件之前声明的话，那JS需要等待CSS文件加载完毕后才会执行）。<ul>
<li>原因：因为JS有时需要查询（获取）元素的一些样式，这些样式是定义在CSS文件里的，所以CSS加载完之后再去执行JS会更好一些。</li>
</ul>
</li>
</ul>
<p>所以<code>&lt;script&gt;</code>最好放在底部，<code>&lt;link&gt;</code>最好放在头部，是因为JS会阻塞DOM树的解析，CSS不会阻塞DOM树的解析。</p>
<p>如果头部同时有<code>&lt;script&gt;</code>和<code>&lt;link&gt;</code>的情况下，最好将<code>&lt;script&gt;</code>放在<code>&lt;link&gt;</code>上面，是因为JS会等待CSS加载完毕后才会执行，但是放在头部的JS一般不会对样式进行查询修改，所以放在前面没有太大影响（比如说引入VUE的CDN的js代码就会在头部，但是和CSS样式是无关的）</p>
<br>

<p>参考：</p>
<p><a href="https://www.cnblogs.com/jiasm/p/7683930.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiasm/p/7683930.html</a></p>
<p><a href="https://www.jianshu.com/p/e6252dc9be32" target="_blank" rel="noopener">https://www.jianshu.com/p/e6252dc9be32</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是哈希hash</title>
    <url>/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/</url>
    <content><![CDATA[<h1 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h1><h2 id="什么是Hash"><a href="#什么是Hash" class="headerlink" title="什么是Hash"></a>什么是Hash</h2><p>通过一些计算，把关键码值映射到数组中的位置来访问记录，这个过程称为散列（hash）。</p>
<p>重要组成：</p>
<ul>
<li>hash函数：把关键码值映射到位置的函数称为散列函数。用h表示。</li>
<li>hash表：存放记录的数组称为散列表。用HT表示。</li>
<li>槽（slot）：散列表中的一个位置称为一个槽。</li>
</ul>
<p>设计hash表的目标是：使得对于任何关键码值K和某个散列函数h，<code>i=h(K)</code>是表中满足0&lt;=h(K)&lt;M（M为HT中槽的数目）的一个槽，并且记录在<code>HT[i]</code>存储的关键码值与K相等。</p>
<h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>在实际情况中，我们根据散列方法组织的数据库必须把存储的记录存放在不大的散列表中，以避免浪费过多的空间。这样的话，有可能有多个关键码值计算出来的h(K)是一样的，但又不能同时放在同一个槽中，此时就要使用冲突解决策略。</p>
<h3 id="冲突解决策略"><a href="#冲突解决策略" class="headerlink" title="冲突解决策略"></a>冲突解决策略</h3><p>冲突解决策略一般分为两类：</p>
<ul>
<li>开散列方法（open hashing；也称为单链方法）</li>
<li>闭散列方法（closed hashing；也称为开地址方法）</li>
</ul>
<h4 id="开散列方法"><a href="#开散列方法" class="headerlink" title="开散列方法"></a>开散列方法</h4><p>开散列方法的最简单形式把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放在这个槽的链表内。</p>
<img src="/images/loading.png" data-original="/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/1.png" class>



<h4 id="闭散列方法"><a href="#闭散列方法" class="headerlink" title="闭散列方法"></a>闭散列方法</h4><p>闭散列方法把所有记录直接存储到散列表中。每条关键码值标记为k<sub>R</sub>，记录R有一个基槽，就是h(k<sub>R</sub>)，即由散列函数计算出来的槽。如果要插入一条记录R，而另一条记录已经占据了R的基槽，那么就把R存储在表的其他槽内。</p>
<h5 id="桶式散列"><a href="#桶式散列" class="headerlink" title="桶式散列"></a>桶式散列</h5><ul>
<li>一种实现闭散列的方法是把散列表中的槽分成多个桶(bucket)。把散列表中的M个槽分成B个桶，每个桶中包含M/B个槽。</li>
<li>散列函数把每一条记录分配到某个桶的第一个槽中。</li>
<li>如果这个槽已经被占用，那么就顺序地沿着桶查找，直到找到一个空槽。</li>
<li>如果一个桶全部被占满了，那么就把这条记录存储在表后具有无限容量的溢出桶（overflow bucket）中。</li>
</ul>
<img src="/images/loading.png" data-original="/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/2.png" class>



<h4 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h4><p>最常用的散列方法。当发生冲突时，从当前基槽开始往后查找，有空位则将记录放进去。例如，2037原本应放在7的槽中，但是7已经被占用，所以往后查找空位，8是空的，于是将2037放进去。</p>
<img src="/images/loading.png" data-original="/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/3.png" class>



<p>但是这种方法会导致基本聚集。例如在上例中，下一条记录放到第2个槽的概率就是6/10了，因为取模后值为7,8,9,0,1,2都会放到第2个槽中。在理想情况下，表中的每个空槽都应该有相同的机会接受到下一个要插入的记录。</p>
<h3 id="改进的冲突解决方法"><a href="#改进的冲突解决方法" class="headerlink" title="改进的冲突解决方法"></a>改进的冲突解决方法</h3><p>如何避免基本聚集呢？</p>
<p>一种可能的改进方式是仍然使用线性探查，但是跳过一些槽，而且每次跳过常数c个而不是1个槽。这会生成探查函数：<code>P(K,i)=ci</code>。</p>
<p>例如，如果常数c是2的话：如果基槽被占用的话，第一次会找基槽+2的位置，看是否被占用，如果被占用了，第二次会找基槽+4的位置，如果还是被占用，则找基槽+6的位置，以此类推。即从基槽开始的偏移量将会为2,4,6。</p>
<p>另一种方法是使用二次探查函数（对于某些常数c1,c2,c3）：<code>p(K,i)=c1i&lt;sup&gt;2&lt;/sup&gt;+c2i+c3</code>。一个最简单的变体就是<code>p(K,i)=i&lt;sup&gt;2&lt;/sup&gt;</code>。</p>
<p>例如，对于一个长度M=101的散列表，假定对于关键码k1和k2，h(k1)=30，h(k2)=29。k1的探查序列为30,31,34,39；k2的探查序列为29,30,33,38。这样，尽管k2会在第二步探查k1的基槽，这两个关键码的探查序列此后就立即分开了。</p>
<h4 id="双散列方法"><a href="#双散列方法" class="headerlink" title="双散列方法"></a>双散列方法</h4><p>即由两个散列函数，一个散列函数用于计算基槽，另一个散列函数用于确定线性探查中的常数。即线性探查此时的形式为：<code>p(K,i)=i*h2(K)</code>。</p>
<p>例如，假定散列表的长度是M=101，有3个关键码k1，k2，k3，h(k1)=30，h(k2)=28，h(k3)=30，h2(k1)=2，h2(k2)=5，h2(k3)=5。那么k1的探查序列为：30,32,34,36等；k2的探查序列为：28,33,38,43等；k3的探查序列为：30,35,40,45等。这样关键码之间就不会共享同一段探查序列了。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>事件绑定 事件监听 事件委托</title>
    <url>/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>为了让JavaScript对用户的操作作出响应，首先要对DOM元素绑定事件处理函数。</p>
<p>三种常用的绑定事件的方法：</p>
<ol>
<li>在DOM元素中直接绑定</li>
<li>在JavaScript代码中绑定</li>
<li>绑定事件监听函数</li>
</ol>
<h3 id="在DOM元素中直接绑定"><a href="#在DOM元素中直接绑定" class="headerlink" title="在DOM元素中直接绑定"></a>在DOM元素中直接绑定</h3><p>我们可以在DOM元素上绑定<code>onclick</code>、<code>onmouseover</code>、<code>onmouseout</code>、<code>onmousedown</code>、<code>onmouseup</code>、<code>ondblclick</code>、<code>onkeydown</code>、<code>onkeypress</code>、<code>onkeyup</code>等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">onclick</span>=<span class="string">"hello()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello world!"</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="在JavaScript代码中绑定事件"><a href="#在JavaScript代码中绑定事件" class="headerlink" title="在JavaScript代码中绑定事件"></a>在JavaScript代码中绑定事件</h3><p>在JavaScript代码中（即<code>script</code>标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello world!"</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用事件监听绑定事件"><a href="#使用事件监听绑定事件" class="headerlink" title="使用事件监听绑定事件"></a>使用事件监听绑定事件</h3><p>绑定事件的另一种方法是用 <code>addEventListener()</code> 或 <code>attachEvent()</code>来绑定事件监听函数。</p>
<p>事件监听的优点：</p>
<ol>
<li>可以绑定多个事件</li>
</ol>
<p>常规的事件绑定（例如<code>onclick</code>）只执行最后绑定的事件，会产生事件覆盖。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn3 = <span class="built_in">document</span>.getElementById(<span class="string">"btn3"</span>);</span></span><br><span class="line"><span class="actionscript">btn3.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 1"</span>); <span class="comment">//不执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript">btn3.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 2"</span>); <span class="comment">//执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>使用<code>addEventListener</code>的话两个事件都会执行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click me"</span> <span class="attr">id</span>=<span class="string">"btn4"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn4 = <span class="built_in">document</span>.getElementById(<span class="string">"btn4"</span>);</span></span><br><span class="line"><span class="actionscript">btn4.addEventListener(<span class="string">"click"</span>,hello1);</span></span><br><span class="line"><span class="actionscript">btn4.addEventListener(<span class="string">"click"</span>,hello2);</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hello1</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 1"</span>); <span class="comment">//执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">hello2</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">	alert(<span class="string">"hello 2"</span>);  <span class="comment">//执行</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>关于事件监听，有3个事件阶段（事件流包括三个状态）：<strong>捕获阶段</strong>，目标阶段，<strong>冒泡阶段</strong>。<strong>这三个阶段也叫作事件流。</strong></p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>当一个事件触发后，从window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。<strong>所有经过的节点，都会触发对应事件</strong>。</p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>当事件到达目标节点后，会沿着捕获阶段路线原路返回。同样，<strong>所有经过的节点，都会触发对应的事件</strong>。</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/1.png" class>

<p>通过栗子来理解两个事件机制：</p>
<p>假设有body和body节点下的div1均有绑定了一个点击事件。</p>
<p>效果：</p>
<ul>
<li>当为事件捕获(<code>useCapture:true</code>)时,先执行body的事件,再执行div的事件</li>
<li>当为事件冒泡(<code>useCapture:false</code>)时,先执行div的事件,再执行body的事件（默认是false，在事件冒泡阶段执行）</li>
</ul>
<p><code>useCapture</code>：用于指定事件是否在捕获或冒泡阶段执行</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/3.png" class>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//当useCapture为默认false时,为事件冒泡</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="actionscript">    body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="actionscript">    div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//结果:打印div1  打印body</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//当useCapture为true时,为事件捕获</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span></span><br><span class="line"><span class="actionscript">    body.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印body'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;,<span class="literal">true</span>)</span></span><br><span class="line"><span class="actionscript">    div1.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'打印div1'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">//结果:打印body   打印div1</span><br></pre></td></tr></table></figure>



<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p><strong>利用冒泡原理，把事件加到父元素或祖先元素上，触发执行效果</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>);</span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        div.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(e.target)</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> div3 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="actionscript">        div3.setAttribute(<span class="string">'class'</span>,<span class="string">'div3'</span>)</span></span><br><span class="line"><span class="actionscript">        div3.innerHTML = <span class="string">'div3'</span>;</span></span><br><span class="line">        div.appendChild(div3)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然没有给div1和div2添加点击事件，但是无论是点击div1还是div2都会打印当前节点（<code>console.log(e.target)</code>）。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。</p>
<p>举个栗子：</p>
<p>分别点击div1、div2、div3：</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/2.png" class>

<p><strong>无论后代新增了多少个节点，一样具有点击事件的功能。但是如果是传统的事件绑定的话无法对动态添加的元素而动态地添加事件</strong>。</p>
<h4 id="事件委托的优点"><a href="#事件委托的优点" class="headerlink" title="事件委托的优点"></a>事件委托的优点</h4><ol>
<li>提高性能：每一个函数都会占用内存空间。只需要添加一个事件处理程序代理所有事件，所占用的内存空间更少。</li>
<li>动态监听：使用事件委托可以自动绑定动态添加的元素。即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。</li>
</ol>
<p>参考：<a href="https://www.cnblogs.com/soyxiaobi/p/9498357.html" target="_blank" rel="noopener">https://www.cnblogs.com/soyxiaobi/p/9498357.html</a></p>
<p>​            <a href="http://blog.xieliqun.com/2016/08/12/event-delegate/" target="_blank" rel="noopener">http://blog.xieliqun.com/2016/08/12/event-delegate/</a></p>
<br>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>分析parseInt()</title>
    <url>/2020/01/18/%E5%88%86%E6%9E%90parseInt/</url>
    <content><![CDATA[<h3 id="parseInt-公式"><a href="#parseInt-公式" class="headerlink" title="parseInt()公式"></a><code>parseInt()公式</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。要被解析的字符串。</td>
</tr>
<tr>
<td>radix</td>
<td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</td>
</tr>
</tbody></table>
<br>



<h3 id="parseInt-071-和parseInt-quot-071-quot-的区别"><a href="#parseInt-071-和parseInt-quot-071-quot-的区别" class="headerlink" title="parseInt(071)和parseInt(&quot;071&quot;)的区别"></a><code>parseInt(071)和parseInt(&quot;071&quot;)的区别</code></h3><p><code>parseInt(&quot;071&quot;)</code>就是简单将字符串转换为数字：</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E5%88%86%E6%9E%90parseInt/1.png" class>

<ul>
<li><p>如果 string 以 “0x” 开头，<code>parseInt()</code> 会把 string 的其余部分解析为十六进制的整数。</p>
</li>
<li><p>如果 string 以 1 ~ 9 的数字开头，<code>parseInt()</code> 将把它解析为十进制的整数。</p>
</li>
<li><p>以0开头也是转换为十进制。也有说转换为十六进制或者八进制，但是在chrome中实践是十进制。</p>
</li>
</ul>
<img src="/images/loading.png" data-original="/2020/01/18/%E5%88%86%E6%9E%90parseInt/2.png" class>



<p><code>parseInt(071)</code>就是将071用八进制进行转换：</p>
<img src="/images/loading.png" data-original="/2020/01/18/%E5%88%86%E6%9E%90parseInt/3.png" class>

<br>



<h3 id="判断-‘1’-’2’-’3’-map-parseInt-的输出"><a href="#判断-‘1’-’2’-’3’-map-parseInt-的输出" class="headerlink" title="判断[‘1’,’2’,’3’].map(parseInt)的输出"></a>判断[‘1’,’2’,’3’].map(<code>parseInt</code>)的输出</h3><p>你可能觉得会是[1,2,3]，但实际上是[1,<code>NaN</code>,<code>NaN</code>]。我们来仔细分析一下：</p>
<p><strong>map的函数格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map((item, index, thisArr) &#x3D;&gt; ( newArr ))</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>item: callback 的第一个参数，数组中正在处理的当前元素</li>
<li>index: callback 的第二个参数，数组中正在处理的当前元素的索引</li>
<li><code>thisArr</code>: callback 的第三个参数，map 方法被调用的数组</li>
</ul>
<p><strong><code>parseInt</code>的格式</strong></p>
<p>上面讲到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(string, radix)</span><br></pre></td></tr></table></figure>



<p>通过上述对 map 和 <code>parseInt</code> 函数的分析可以知道，执行方法时，map给<code>parseInt</code>传递了三个参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(item, index, thisArr)</span><br></pre></td></tr></table></figure>

<p>因此，索引<code>index</code>会传入<code>parseInt</code>函数当做基数<code>radix</code>。</p>
<p>其中第三个参数会被 <code>parseInt</code> 忽略，因此会依次执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// radix 为 0，默认以十进制解析字符串，返回 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// radix 为 1，不在 2 ~ 36 之间，返回 NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN</span></span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://www.cnblogs.com/wx1993/p/8417817.html" target="_blank" rel="noopener">https://www.cnblogs.com/wx1993/p/8417817.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p>如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖（debounce）和节流（throttle）的方式来减少调用频率，同时又不影响实际效果。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>含义：当持续触发事件时，一定时间段内没有在触发事件，事件处理函数才会执行一次；如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>
<img src="/images/loading.png" data-original="/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/1.jpg" class>



<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//取消由 setTimeout() 方法设置的 timeout</span></span><br><span class="line">        <span class="keyword">if</span>(timeout!==<span class="literal">null</span>) </span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>防抖是通过<strong>闭包</strong>实现的，所以timeout是会被缓存的。如果在频繁触发事件之后的一段时间内，又再次触发了事件，那就会使用<code>clearTimeout</code>清除<code>setTimout</code>设置的<code>timout</code>，重新计时。</p>
<p>具体完整代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(fn, wait)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//取消由 setTimeout() 方法设置的 timeout</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span>(timeout!==<span class="literal">null</span>) </span></span><br><span class="line">                    clearTimeout(timeout);</span><br><span class="line">            timeout = setTimeout(fn, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 处理函数</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 滚动事件</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示4<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示5<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示6<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示7<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示8<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示9<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示10<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示11<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示12<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示13<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示14<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示15<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>防抖演示16<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在网页运行的时候我们会看到，当在滚动页面操作停止后1s，控制台会有输出。这就是防抖。</p>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>当持续触发事件时，保证每隔一定时间段内只调用一次事件处理函数。</p>
<img src="/images/loading.png" data-original="/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/2.jpg" class>



<p>用定时器实现节流：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle=<span class="function"><span class="keyword">function</span>(<span class="params">func,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context=<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args=<span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context,args);</span><br><span class="line">                timer=<span class="literal">null</span>;</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>,throttle(handle,<span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>节流也是通过<strong>闭包</strong>实现的。所以会把timer缓存起来，但是由于每次执行<code>setTimeout</code>函数时都设置timer为null，所以每次调用都可以执行if语句当中的内容。同时，下一次滚动事件不会影响上一次的事件处理函数，所以不会重新计时。</p>
<p>将节流代码放入上个例子的具体实现中会发现，执行滚动页面操作后，都会以同一频率在控制台中输出值。</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>https SSL/TLS握手过程</title>
    <url>/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="SSL-TLS-握手过程详解"><a href="#SSL-TLS-握手过程详解" class="headerlink" title="SSL/TLS 握手过程详解"></a>SSL/TLS 握手过程详解</h1><p>http协议是明文传输，不确认通信方，不保证传输数据完整的协议。它带来了三大风险：</p>
<blockquote>
<p>（1） <strong>窃听风险</strong>（eavesdropping）：第三方可以获知通信内容。</p>
<p>（2） <strong>篡改风险</strong>（tampering）：第三方可以修改通信内容。</p>
<p>（3） <strong>冒充风险</strong>（pretending）：第三方可以冒充他人身份参与通信。</p>
</blockquote>
<p>http协议是明文传输，在安全性方面比较差。https协议使用了SSL/TLS协议来进行加密。SSL/TLS握手是为了安全地协商出一份<strong>对称加密</strong>的秘钥。</p>
<img src="/images/loading.png" data-original="/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/1.jpg" class>



<h2 id="SSL-TLS握手过程"><a href="#SSL-TLS握手过程" class="headerlink" title="SSL/TLS握手过程"></a>SSL/TLS握手过程</h2><img src="/images/loading.png" data-original="/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/2.jpg" class>



<ol>
<li>Client Hello</li>
</ol>
<p>握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数<strong>Random1</strong>，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。</p>
<ol start="2">
<li>Server Hello</li>
</ol>
<p>第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。</p>
<p>注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。</p>
<ol start="3">
<li>Certificate</li>
</ol>
<p>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<ol start="4">
<li>Server Hello Done</li>
</ol>
<p>Server Hello Done通知客户端Server Hello过程结束。</p>
<ol start="5">
<li>Certificate Verify</li>
</ol>
<p>客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。</p>
<blockquote>
<p>https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的</p>
</blockquote>
<ol start="6">
<li>Client Key Exchange</li>
</ol>
<p>上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。</p>
<p>至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是<strong>使用这个秘钥进行对称加密</strong>。</p>
<p>为什么要使用三个随机数？</p>
<p>这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。</p>
<blockquote>
<p>最重要理解前六步</p>
</blockquote>
<ol start="7">
<li>Change Cipher Spec（Client）</li>
</ol>
<p>这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。</p>
<ol start="8">
<li>Encrypted Handshake Message(Client)</li>
</ol>
<p>这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。</p>
<ol start="9">
<li>Change Cipher Spec(Server)</li>
</ol>
<p>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</p>
<ol start="10">
<li>Encrypted Handshake Message(Server)</li>
</ol>
<p>这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p>
<p>Application Data</p>
<p><strong>到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输</strong>。</p>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a></p>
<p>​            <a href="https://juejin.im/post/584b76d3a22b9d0058d5036f" target="_blank" rel="noopener">https://juejin.im/post/584b76d3a22b9d0058d5036f</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 圣杯布局和双飞翼布局</title>
    <url>/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="CSS-圣杯布局和双飞翼布局"><a href="#CSS-圣杯布局和双飞翼布局" class="headerlink" title="CSS 圣杯布局和双飞翼布局"></a>CSS 圣杯布局和双飞翼布局</h1><p>两个常见的前端布局。圣杯布局和双飞翼布局作为经典的三栏式布局是面试中的常客。两种布局达到效果上基本相同，都是<strong>两边两栏宽度固定，中间栏宽度自适应</strong>。在HTML结构上<strong>中间栏在最前面</strong>保证了最先渲染中间提升性能（因为这两种布局都比较老，我认为在现代浏览器中这点儿性能优化效果并不是很大），并且兼容性良好。两种布局的实现方法前半部分相同，后半部分的实现各有利弊，下面会简单介绍两者的区别。</p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>, <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line">            background-color: skyblue;</span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:60px</span>;  <span class="comment">/*文字水平垂直居中*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;  <span class="comment">/*因为内部都是浮动元素，所以要设置overflow来撑起父元素*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span> 100<span class="selector-tag">px</span>;  <span class="comment">/*左右内边距为100px*/</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">            background-color: peachpuff; </span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">            line-height: 100px;</span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            background-color: lightgreen;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100</span>%;  <span class="comment">/*让left前移一行*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">left</span><span class="selector-pseudo">:-100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            background-color: pink;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100px</span>; <span class="comment">/*right只需要前移right的宽度即可*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;  <span class="comment">/*container设置了padding,所以要相对定位移动才能将left和right移动到对应的位置*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">right</span><span class="selector-pseudo">:-100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/1.png" class>



<p>实现原理：</p>
<ol>
<li><p>设置父元素<code>container</code>为<code>overflow:hidden</code>，撑起父元素，子元素<code>main</code>、<code>left</code>、<code>right</code>均设为<code>float:left</code>，浮动起来。效果如下：</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/2.png" class>
</li>
<li><p>为了让<code>main</code>模块自适应，将其设为100%</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/3.png" class>
</li>
<li><p>为了让<code>left</code>和<code>right</code>模块跑上去，设置<code>left</code>模块的<code>margin:-100%</code>，可以理解为：负的话就是向上前进，正值的话就是直接的间隔；<code>right</code>模块就设置为<code>margin:-100px</code>，大小为<code>right</code>模块的宽度</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/4.png" class>
</li>
<li><p>为了使<code>main</code>模块往里收，设置<code>.container{ padding: 0 100px}</code>，即设置左右内边距。</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/5.png" class>



</li>
</ol>
<ol start="5">
<li><p>利用相对定位移动left和right</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/6.png" class>





</li>
</ol>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>, <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line">            background-color: skyblue;</span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:60px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.container</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">            background-color: peachpuff;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.inner-main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:100px</span>;  <span class="comment">/*通过在main内部再设置一个div来进行左右模块的间隔布局*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-right</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            background-color: lightgreen;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100</span>%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            background-color: yellow;</span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner-main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<img src="/images/loading.png" data-original="/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/7.png" class>

<p>实现原理：</p>
<p>双飞翼布局则不设置<code>container</code>里的<code>padding</code>属性，而是通过在<code>main</code>模块中添加<code>inner-main</code>模块，然后对这个<code>div</code>进行<code>margin-left</code>和<code>margin-right</code>计算。</p>
<h2 id="圣杯布局和双飞翼布局的主要区别："><a href="#圣杯布局和双飞翼布局的主要区别：" class="headerlink" title="圣杯布局和双飞翼布局的主要区别："></a>圣杯布局和双飞翼布局的主要区别：</h2><ul>
<li>圣杯布局是设置<code>container</code>的<code>padding</code>属性以及<code>left</code>和<code>right</code>模块的<code>position:relative</code>，<code>left:-100px</code>或<code>right:-100px</code></li>
<li>双飞翼布局则不设置<code>container</code>里的<code>padding</code>属性，而是通过在<code>main</code>模块中添加<code>inner-main</code>模块，然后对这个<code>div</code>进行<code>margin-left</code>和<code>margin-right</code>计算</li>
</ul>
<p>参考：<a href="https://segmentfault.com/a/1190000004579886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004579886</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块化编程</title>
    <url>/2020/01/14/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h1><p>目录：</p>
<ul>
<li>AMD</li>
<li>CMD</li>
<li><code>commom.js</code></li>
<li>ES6 Module</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD是<strong>依赖前置，提前执行</strong>。AMD一开始是<code>CommonJS</code>规范中的一个草案，即异步模块加载机制。后来由该草案的作者以<code>RequireJS</code>实现了AMD规范，所以一般说AMD也是指<code>RequireJS</code>。</p>
<h4 id="AMD的基本语法"><a href="#AMD的基本语法" class="headerlink" title="AMD的基本语法"></a><code>AMD</code>的基本语法</h4><p>通过<code>define</code>来定义一个模块，使用<code>require</code>可以导入定义的模块。</p>
<p>用<code>define</code>定义无依赖的模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="comment">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>用<code>define</code>定义有依赖的模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">"alpha"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"> alpha </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        verb : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> alpha.verb() + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>用<code>require</code>进行模块加载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">　math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="AMD的特点"><a href="#AMD的特点" class="headerlink" title="AMD的特点"></a><code>AMD的特点</code></h4><p>对于依赖的模块，AMD推崇<strong>依赖前置，提前执行。</strong>也就是定义模块和加载模块都要在一开始就把依赖写好。例如<code>define</code>函数当中的<code>[&quot;alpha&quot;]</code>，就是定义模块当中的依赖；<code>require</code>函数当中的<code>[&quot;math&quot;]</code>是加载模块当中的依赖。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD是<strong>依赖就近，延迟执行</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>,<span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//依赖一开始就写好</span></span><br><span class="line">    a.test();</span><br><span class="line">    b.test();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, exports, module</span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.test();</span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//软依赖</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">'./b'</span>);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>CMD</code>是在用到了某个模块的时候再去<code>require</code>，类似按需加载。</p>
<h4 id="CMD的特点"><a href="#CMD的特点" class="headerlink" title="CMD的特点"></a><code>CMD的特点</code></h4><p>对于依赖的模块，CMD推崇<strong>依赖就近，延迟执行</strong>。也就是说，只有到<code>require</code>时依赖模块才执行。</p>
<p>摘自：<a href="https://segmentfault.com/a/1190000004873947" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004873947</a></p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><code>CommonJS</code></h2><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li>通过<code>module.exports</code>或者<code>exports</code>来输出模块</li>
<li>通过<code>require</code>来导入模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"></span><br><span class="line">a();<span class="comment">//"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a2.js</span></span><br><span class="line">exports.num = <span class="number">1</span>;</span><br><span class="line">exports.obj = &#123;<span class="attr">xx</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2.js</span></span><br><span class="line"><span class="keyword">var</span> a2 = <span class="built_in">require</span>(<span class="string">'./a2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a2);<span class="comment">//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="CommonJS的特点"><a href="#CommonJS的特点" class="headerlink" title="CommonJS的特点"></a><code>CommonJS</code>的特点</h4><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域</li>
<li>模块都是同步加载的，即只有加载完成，才能执行后面的操作</li>
<li>模块在首次执行后就会缓存，再次加载只返回缓存结果。如果想要再次执行，可清楚缓存</li>
<li><code>require</code>返回的值是被输出的值的拷贝，模块内部的变化不会影响这个值</li>
</ul>
<h2 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h2><h4 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h4><ul>
<li><code>export</code>或<code>export default</code>来输出模块</li>
<li><code>import</code>来导入模块</li>
</ul>
<p>（<code>export default</code>就是能够为导入的模块自定义名称，这样就不用知道模块在原本的<code>js</code>文件当中的名字，按名字导入了）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'lin'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">var</span> job = <span class="string">'ninja'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, age, job&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, job&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, age, job);<span class="comment">// lin 13 ninja</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a2.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'default '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b2.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./a2.js'</span>;</span><br><span class="line">customName(); <span class="comment">// 'default'</span></span><br></pre></td></tr></table></figure>



<h4 id="ES6-Module的特点（对比CommonJS）"><a href="#ES6-Module的特点（对比CommonJS）" class="headerlink" title="ES6 Module的特点（对比CommonJS）"></a>ES6 Module的特点（对比<code>CommonJS</code>）</h4><ul>
<li><code>CommonJS</code>模块是运行时加载，ES6 Module是编译时输出接口；</li>
<li><code>CommonJS</code>加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口（对应名字单独加载，加载这个模块想=需要的）；</li>
<li><code>CommonJS</code>输出是值的拷贝，ES6 Module输出的是值的引用，被输出模块的内部的改变会影响引用的改变；</li>
<li><code>CommonJS</code> <code>this</code>指向当前模块，ES6 Module <code>this</code>指向<code>undefined</code>;</li>
</ul>
<p>参考：<a href="https://juejin.im/post/5db95e3a6fb9a020704bcd8d" target="_blank" rel="noopener">https://juejin.im/post/5db95e3a6fb9a020704bcd8d</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Generator函数 async函数</title>
    <url>/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h2 id="重要概念："><a href="#重要概念：" class="headerlink" title="重要概念："></a>重要概念：</h2><ul>
<li><p><code>Generator</code> 函数是 ES6 提供的一种<strong>异步编程解决方案</strong></p>
</li>
<li><p>执行<code>Generator</code>函数会返回一个<strong>遍历器对象</strong></p>
</li>
<li><p>形式上<code>Generator</code>函数是一个普通函数，有两个特征：1）<code>function</code>关键字与函数名之间有个星号； 2）函数内部使用<code>yield</code>表达式，定义不同的内部状态</p>
</li>
<li><p>调用<code>Generator</code>函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象</p>
</li>
<li><p>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态，输出返回的结果</p>
</li>
<li><p><code>next</code>方法返回的是一个对象。它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>则表示遍历还没有结束（即没有遇到return）。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<p>另一个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">const</span> y = <span class="keyword">yield</span> x + <span class="number">6</span>;</span><br><span class="line"> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = gen(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: false &#125;</span></span><br><span class="line"><span class="comment">//调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行</span></span><br><span class="line"><span class="comment">// 执行完成会返回一个 Object,</span></span><br><span class="line"><span class="comment">// value 就是执行 yield 后面的值,done 表示函数是否执行完毕</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// 因为最后一行 return y 被执行完成,所以done 为 true</span></span><br></pre></td></tr></table></figure>

<p>next方法传参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125; </span></span><br><span class="line"><span class="comment">// next 的参数是作为上个阶段异步任务的返回结果</span></span><br></pre></td></tr></table></figure>



<h2 id="异步应用"><a href="#异步应用" class="headerlink" title="异步应用"></a>异步应用</h2><p>因为<code>yield</code>能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序。</p>
<p>例如有两个异步的函数 <code>A</code> 和 <code>B</code>, 并且 <code>B</code> 的参数是 <code>A</code> 的返回值，也就是说，如果 <code>A</code> 没有执行结束，我们不能执行 <code>B</code>。</p>
<p>那这时候我们写一段伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">effect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; param &#125; = <span class="keyword">yield</span> A();</span><br><span class="line">  <span class="keyword">const</span> &#123; result &#125; = <span class="keyword">yield</span> B(param);</span><br><span class="line">  <span class="built_in">console</span>.table(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候我们如果需要得到 <code>result</code> 那么我们就需要:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = effect()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>

<p><code>co</code>库可以用来每次执行<code>A()/b()</code>的请求结束之后，都会自动执行<code>next()</code>方法。</p>
<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a><code>async</code>和<code>await</code></h2><p><code>async</code>函数就是<code>Generator</code>的语法糖。</p>
<p><strong>形式上的不同</strong>：</p>
<ul>
<li><code>async</code>函数将<code>Generator</code>函数的星号（*）替换成<code>async</code></li>
<li>将<code>yield</code>替换成<code>await</code></li>
</ul>
<p><strong><code>async</code></strong>函数对<code>Generator</code>函数的改进体现在以下4点：</p>
<ol>
<li><p>内置执行器</p>
<p>也就是说<code>async</code>函数的执行，和普通函数一样，只需要一行就可以。不用像<code>Generator</code>函数需要调用<code>next</code>方法才能真正执行。</p>
<p>例如对于一个<code>async</code>函数来说：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用时只需要：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>更好的语义</li>
</ol>
<p><code>async</code>和<code>await</code>比起星号和<code>yield</code>，语义更加清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<ol start="3">
<li>返回值是<code>Promise</code></li>
</ol>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p><strong><code>async</code>函数基本用法</strong></p>
<p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>先执行了第一个<code>await</code>后的<code>getStockSymbol(name)</code>函数；得到了股票的名称<code>symbol</code>后，将<code>symbol</code>传给第二个<code>await</code>后面的<code>getStockPrice(symbol)</code>作为参数；最后返回股票价格<code>stockPrice</code>。</p>
<h2 id="执行顺序问题"><a href="#执行顺序问题" class="headerlink" title="执行顺序问题"></a>执行顺序问题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span></span><br></pre></td></tr></table></figure>

<p>当<code>async</code>函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了<code>async</code>函数体。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>

<p>执行顺序为：</p>
<p><img src="/images/loading.png" data-original="./Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/1.png" alt="img"></p>
<p>执行async1的时候遇到await先去执行async2，然后跳出了函数体，去执行后续的代码，然后再回到当前async1函数当中执行await后续语句。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2020/01/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>柯里化的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<p>看一个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用了<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。</p>
<p>因为一次性地调用它有点繁琐，所以使用一个特殊的<code>curry</code>帮助函数使得这类函数的定义和调用更加容易。</p>
<p><strong>一些柯里函数实例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="built_in">require</span>(<span class="string">'lodash'</span>).curry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = curry(<span class="function"><span class="keyword">function</span>(<span class="params">what, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.match(what);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">match(<span class="regexp">/\s+/g</span>, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br><span class="line"></span><br><span class="line">match(<span class="regexp">/\s+/g</span>)(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br></pre></td></tr></table></figure>

<p>以上两种方法都可以执行。第二种方法是比较常见的柯里化方法。先传递一部分参数（题目中为正则表达式）来调用函数，然后返回一个函数（题目中为<code>str.match()</code>来处理剩下的函数）。（题目中是匹配空格）</p>
<p>以上的形式可以更加具体化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasSpaces = match(<span class="regexp">/\s+/g</span>);</span><br><span class="line"><span class="comment">// function(x) &#123; return x.match(/\s+/g) &#125;</span></span><br><span class="line"></span><br><span class="line">hasSpaces(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br></pre></td></tr></table></figure>



<p><strong>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</strong></p>
<p><strong>再举一个非常常见的例子：</strong></p>
<p>如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPhone</span>(<span class="params">phoneNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>.test(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而如果想要验证是否是邮箱呢？这么封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkEmail</span>(<span class="params">email</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>.test(email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">targetString, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reg.test(targetString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>, <span class="string">'14900000088'</span>);</span><br><span class="line">check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">'test@163.com'</span>);</span><br></pre></td></tr></table></figure>

<p>这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _check = createCurry(check);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPhone = _check(<span class="regexp">/^1[34578]\d&#123;9&#125;$/</span>);</span><br><span class="line"><span class="keyword">var</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br></pre></td></tr></table></figure>

<p>最后在使用的时候就会变得更加直观与简洁了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkPhone(<span class="string">'183888888'</span>);</span><br><span class="line">checkEmail(<span class="string">'xxxxx@test.com'</span>);</span><br></pre></td></tr></table></figure>



<p><strong>再看一个前端面试中常考的题目：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何实现add(2)(3)(4) &#x3D; 9</span><br></pre></td></tr></table></figure>

<p>函数柯里化解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a+b+c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = fn.length;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> _args = args || [];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">        args = <span class="built_in">Array</span>.prototype.concat.call(_args, args);</span><br><span class="line">        <span class="comment">// 当接收到的参数小于fn所需参数个数时，继续接收参数</span></span><br><span class="line">        <span class="keyword">if</span>(args.length &lt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> curry.call(_this, fn, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add = curry(myAdd);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>));  <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.loh(add(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>));   <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));    <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>但是这个例子不具有普遍性。如果传入的参数不是3个的话不能这么用。</p>
<p>所以有了下面的进化之后的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></span><br><span class="line">    <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></span><br><span class="line">    _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString()                <span class="comment">// 6</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>).toString()             <span class="comment">// 10</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>).toString()          <span class="comment">// 15</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>).toString()                <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>



<p>参考的博客说隐式转换的原因是因为函数进行计算的时候会变为字符串，但理解了代码之后觉得并不是这么回事。每次调用函数的时候执行的是这个语句体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个语句体实际上是用于将所有传入的实参放进数组<code>args</code>中。最后执行<code>toString</code>方法的时候是将数组<code>args</code>的每个元素通过reduce函数求和，返回求和的值。单纯执行<code>_adder</code>函数和执行<code>toString()</code>函数做的事情是不一样的。</p>
<p>看到一个面试题目：</p>
<p>实现一个sum函数使得sum(1, 2, 3).valueOf()和sum(1)(2)(3).valueOf()执行输出的结果都等于6 。</p>
<p>解法和上面一致，只需要把<code>toString()</code>改为<code>valueOf()</code>就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args=[].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> _adder=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> _adder;</span><br><span class="line">    &#125;</span><br><span class="line">    _adder.valueOf=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _adder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).valueOf());</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).valueOf());</span><br></pre></td></tr></table></figure>





<p><strong>为什么要进行隐式转化？</strong></p>
<p>因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>);     <span class="comment">// 输出结果 function fn() &#123; return 20 &#125;10</span></span><br></pre></td></tr></table></figure>

<p>我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">30</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<p>除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">20</span>; &#125;</span><br><span class="line">fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">60</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn + <span class="number">10</span>); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure>



<p>参考博客：</p>
<p> <a href="https://www.jianshu.com/p/5e1899fe7d6b" target="_blank" rel="noopener">https://www.jianshu.com/p/5e1899fe7d6b</a> </p>
<p><a href="https://www.cnblogs.com/hmchen/p/11564394.html" target="_blank" rel="noopener">https://www.cnblogs.com/hmchen/p/11564394.html</a></p>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1" target="_blank" rel="noopener">https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this解析</title>
    <url>/2020/01/13/JavaScript-this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this"></a>为什么要使用this</h4><p><code>this</code>提供了一种更优雅的方式来隐式“传递”一个对象引用。</p>
<p>看下面的例子：</p>
<p>没有使用this的情况下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> me=&#123;</span><br><span class="line">    name:<span class="string">"Kyle"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you=&#123;</span><br><span class="line">    name:<span class="string">"Reader"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> greeting=<span class="string">"Hello, I'm "</span>+identify(context);</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">identify(you); <span class="comment">//READER</span></span><br><span class="line">speak(me); <span class="comment">//hello, I'm KYLE</span></span><br></pre></td></tr></table></figure>



<p>使用了this的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting=<span class="string">"Hello, I'm "</span>+identify.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify.call(me); <span class="comment">//KYLE</span></span><br><span class="line">identify.call(you); <span class="comment">//READER</span></span><br><span class="line">speak.call(me); <span class="comment">//Hello, I'm KYLE</span></span><br><span class="line">speak.call(you); <span class="comment">//Hello, I'm READER</span></span><br></pre></td></tr></table></figure>

<p>表达上更加的简洁。如果不使用this的话，就需要给identify()和speak()显式传入一个上下文对象。</p>
<br>

<h4 id="this绑定对象的规则"><a href="#this绑定对象的规则" class="headerlink" title="this绑定对象的规则"></a>this绑定对象的规则</h4><p>我们可以顺序应用下面四条规则来判断this的绑定对象：</p>
<ol>
<li>如果是由<code>new</code>调用，绑定到新创建的对象。</li>
<li>如果是由<code>call</code>或者<code>apply</code>、<code>bind</code>调用，绑定到指定的对象上。</li>
<li>如果是由上下文对象调用（即this是对象中的方法里使用的），绑定到那个上下文对象上。</li>
<li>如果是默认情况下，严格模式绑定到undefined，否则绑定到全局对象上。</li>
</ol>
<p>但是ES6中的箭头函数并不会使用者四条标准的绑定规则。箭头函数会继承外层函数调用的this绑定。<br><br></p>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a><code>new</code>绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar=<span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>我们使用<code>new</code>来调用foo(…)时，会构造一个新对象并把它绑定到foo(…)调用中的this上。<br><br><br><br></p>
<h4 id="显式绑定call、apply、bind"><a href="#显式绑定call、apply、bind" class="headerlink" title="显式绑定call、apply、bind"></a>显式绑定<code>call</code>、<code>apply</code>、<code>bind</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><code>call</code>用来将函数foo中的this绑定到obj上。<br><br><br><br></p>
<h4 id="隐式绑定（上下文对象调用）"><a href="#隐式绑定（上下文对象调用）" class="headerlink" title="隐式绑定（上下文对象调用）"></a>隐式绑定（上下文对象调用）</h4><p>如果<code>this</code>所在的函数是对象中的方法的话，this就会指向这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><code>foo</code>此时是obj对象的一个方法，所以<code>this</code>就会指向obj。</p>
<p>但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">	a:<span class="number">42</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	obj2:obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj1.obj2.foo();  <span class="comment">//42</span></span><br></pre></td></tr></table></figure>
<br>

<p>隐式丢失也是<code>this</code>隐式绑定中常见的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar=obj.foo;  <span class="comment">//函数别名！</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops, global"</span>;  <span class="comment">//a是全局对象的属性</span></span><br><span class="line">bar();  <span class="comment">//“oops, global”</span></span><br></pre></td></tr></table></figure>
<p>此时<code>bar</code>是<code>obj.foo</code>的一个引用，但实际上它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<br>

<p>回调函数丢失<code>this</code>绑定是也是非常常见的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	fn();  <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops global"</span>;  <span class="comment">//全局对象属性</span></span><br><span class="line">doFoo(obj.foo);  <span class="comment">//"oops global"</span></span><br></pre></td></tr></table></figure>
<p>函数<code>doFoo</code>传入了函数作为参数，并在<code>doFoo</code>中调用。我们可以把它看做将函数copy到了<code>doFoo</code>函数体中，调用的时候<code>this</code>指向的是全局作用域。<br><br><br><br></p>
<h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。</p>
<p>例一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar=obj.foo;  <span class="comment">//函数别名！把函数体赋值了</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops,global"</span>;  <span class="comment">//a是全局对象的属性</span></span><br><span class="line">bar(); <span class="string">"oops, global"</span></span><br></pre></td></tr></table></figure>

<p>bar实际上它引用的是foo函数本身。</p>
<p>例二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo:foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops, global"</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line">doFoo(obj.foo); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>

<p>参数传递实际上是一种隐式赋值，因此我们传入函数时也会被隐式赋值。</p>
<p>例三：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	a:<span class="number">2</span>,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"oops, global"</span>;</span><br><span class="line">setTimeout(obj.foo,<span class="number">100</span>); <span class="comment">//"oops, global"</span></span><br></pre></td></tr></table></figure>

<p>回调函数丢失this绑定是非常常见的！</p>
<p>栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    id: <span class="string">"a"</span>,</span><br><span class="line">    cool: <span class="function"><span class="keyword">function</span> <span class="title">coolFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log( <span class="keyword">this</span>.id );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> id = <span class="string">"b"</span></span><br><span class="line">obj.cool(); <span class="comment">// a</span></span><br><span class="line">setTimeout( obj.cool, <span class="number">100</span> ); <span class="comment">// b</span></span><br></pre></td></tr></table></figure>







<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">foo();  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，函数调用应用了this的默认绑定，this指向全局对象。</p>
<p>如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，<code>this</code>会绑定到<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">foo();  <span class="comment">//TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>
<br>
<br>

<h4 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的<code>this</code></h4><p>箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">	a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">	a:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar=foo.call(obj1);</span><br><span class="line">bar.call(obj2);  <span class="comment">//2,不是3！</span></span><br></pre></td></tr></table></figure>
<p><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的this。由于<code>foo()</code>的<code>this</code>绑定到<code>obj1</code>，所以bar（引用箭头函数）的<code>this</code>也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改。</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>
<p><code>foo</code>调用时传入的是什么对象，this就指向谁。<strong>如果是普通函数，执行时this应该指向全局对象window，这时应该输出21</strong>（严格模式则输出undefined）。</p>
<p>如果foo函数内部是普通函数的话：</p>
<p><img src="/images/loading.png" data-original="C:%5CUsers%5Calice%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200205154039804.png" alt="image-20200205154039804"></p>
<p>由此可以看出，foo函数的<code>this</code>是指向<code>call</code>传入的对象<code>{id:42}</code>，但是foo函数内部的<code>setTimeout</code>函数中的<code>this</code>是指向全局的。</p>
<br>

<p>参考书籍：《你不知道的JavaScript》 </p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本知识</title>
    <url>/2019/12/30/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="ES6和JavaScript的关系"><a href="#ES6和JavaScript的关系" class="headerlink" title="ES6和JavaScript的关系"></a>ES6和JavaScript的关系</h2><p>ES6的全称为ECMAScript 6.0，是JavaScript语言下一代的标准，是使得JavaScript可以用来编写复杂的大型应用程序，称为企业级开发语言。ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。</p>
<br>

<h2 id="JavaScript前言"><a href="#JavaScript前言" class="headerlink" title="JavaScript前言"></a>JavaScript前言</h2><p>JavaScript是世界上最流行的脚本语言，是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</p>
<br>

<h2 id="JavaScript引入"><a href="#JavaScript引入" class="headerlink" title="JavaScript引入"></a>JavaScript引入</h2><ol>
<li>用<script></script>直接包含js代码</li>
<li>把js代码放到一个单独的.js文件，在html中通过<script src="..."></script>引入这个文件，这么做更有利于代码维护</li>
</ol>
<br>

<h2 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h2><ol>
<li>JavaScript的语法和Java类似，每个语句以；结束</li>
<li>JavaScript严格区分大小写</li>
</ol>
<br>

<h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><p>基本数据类型：Number, String, Boolean, null, undefined, Symbol（ES6中新添加的类型，一种实例是唯一且不可改变的数据类型）</p>
<br>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript不区分整数和浮点数，统一用Number表示。可以表示</p>
<ul>
<li>整数</li>
<li>浮点数</li>
<li>科学计数法</li>
<li>负数</li>
<li>NaN（表示Not a Number，当无法计算结果时用NaN表示）</li>
<li>Infinity（表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity）</li>
</ul>
<br>

<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串是以单引号或双引号括起来的文本。</p>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>要把多个字符串连接起来，可以用+号连接：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">'你好, '</span> + name + <span class="string">', 你今年'</span> + age + <span class="string">'岁了!'</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>



<p>如果有很多变量需要连接，用<code>+</code>号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>



<h4 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h4><p>获取字符串长度：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</span><br><span class="line">s.length; <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>

<p>要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>]; <span class="comment">// 'H'</span></span><br><span class="line">s[<span class="number">6</span>]; <span class="comment">// ' '</span></span><br><span class="line">s[<span class="number">7</span>]; <span class="comment">// 'w'</span></span><br><span class="line">s[<span class="number">12</span>]; <span class="comment">// '!'</span></span><br><span class="line">s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是</strong>，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Test'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'X'</span>;</span><br><span class="line">alert(s); <span class="comment">// s仍然为'Test'</span></span><br></pre></td></tr></table></figure>



<h4 id="字符串常用方法："><a href="#字符串常用方法：" class="headerlink" title="字符串常用方法："></a>字符串常用方法：</h4><p>注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：</p>
<p><strong>toUpperCase</strong>：</p>
<p><code>toUpperCase()</code>把一个字符串全部变为大写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line">s.toUpperCase(); <span class="comment">// 返回'HELLO'</span></span><br></pre></td></tr></table></figure>



<p><strong>toLowerCase</strong>：</p>
<p><code>toLowerCase()</code>把一个字符串全部变为小写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">var</span> lower = s.toLowerCase(); <span class="comment">// 返回'hello'并赋值给变量lower</span></span><br><span class="line">lower; <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>



<p><strong>substring</strong>:</p>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello, world'</span></span><br><span class="line">s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回'hello'</span></span><br><span class="line">s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回'world'</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>true或者false</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>当我们对Number做比较时，可以通过比较运算符得到一个布尔值，要特别注意比较运算符==和===：</p>
<ul>
<li>==比较：它会自动转换数据类型再比较，很多时候会得到很奇怪的结果</li>
<li>===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>
</ul>
<p>由于JavaScript这个设计缺陷，<em>不要</em>使用<code>==</code>比较，始终坚持使用<code>===</code>比较</p>
<p>另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p>
<p><code>NaN===NaN   //false</code></p>
<p>唯一能判断NaN的方法是通过isNaN()函数：<br><code>isNaN(NaN)   //true</code></p>
<p>最后要注意浮点数的相等比较：</p>
<p><code>1 / 3 === (1 - 2 / 3); // false</code></p>
<p>比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<br>

<h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul>
<li><p><code>null</code>表示一个“空”的值、表示“无”的对象，转为数值是为0；<code>undefined</code>是一个表示“无”的原始值，转为数值是NaN，当声明的变量还未被初始化时，变量的默认值为undefined。</p>
</li>
<li><p>Null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象</p>
</li>
<li><p>Undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义，典型用法是：</p>
<ul>
<li>变量被声明了，但没有赋值时，就等于undefined</li>
<li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li>
<li>对象没有赋值属性，该属性的值为undefined</li>
<li>函数没有返回值时，默认返回undefined</li>
</ul>
</li>
<li><p>null表示”没有对象”，即该处不应该有值。典型用法是：</p>
<ul>
<li>作为函数的参数，表示该函数的参数不是对象</li>
<li>作为对象原型链的终点</li>
</ul>
</li>
</ul>
<br>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br></pre></td></tr></table></figure>

<p>上述数组包含6个元素。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔。</p>
<p>另一种创建数组的方法是通过<code>Array()</code>函数实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。</p>
<p>数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br><span class="line">arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1</span><br><span class="line">arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即true</span><br><span class="line">arr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined</span><br></pre></td></tr></table></figure>



<p>要取得<code>Array</code>的长度，直接访问<code>length</code>属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line">arr.length; <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，直接给<code>Array</code>的<code>length</code>赋一个新的值会导致<code>Array</code>大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.length; <span class="comment">// 3</span></span><br><span class="line">arr.length = <span class="number">6</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2]</span></span><br></pre></td></tr></table></figure>



<p><code>Array</code>可以通过索引把对应的元素修改为新的值，因此，对<code>Array</code>的索引进行赋值会直接修改这个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">arr; <span class="comment">// arr现在变为['A', 99, 'C']</span></span><br></pre></td></tr></table></figure>

<p>(注意此处与String的不同，String是不可变的)</p>
<p><strong>请注意</strong>，如果通过索引赋值时，索引超过了范围，同样会引起<code>Array</code>大小的变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">'x'</span>;</span><br><span class="line">arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></span><br></pre></td></tr></table></figure>

<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的<code>Array</code>却不会有任何错误。在编写代码时，不建议直接修改<code>Array</code>的大小，访问索引时要确保索引不会越界。</p>
<p><strong>indexOf</strong></p>
<p>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></span><br></pre></td></tr></table></figure>

<p>注意了，数字<code>30</code>和字符串<code>&#39;30&#39;</code>是不同的元素。</p>
<p><strong>slice</strong></p>
<p><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></span><br></pre></td></tr></table></figure>



<p>如果不给<code>slice()</code>传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</span><br><span class="line"><span class="keyword">var</span> aCopy = arr.slice();</span><br><span class="line">aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></span><br><span class="line">aCopy === arr; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>



<p><strong>push和pop</strong></p>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 'A', 'B']</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回'B'</span></span><br><span class="line">arr; <span class="comment">// [1, 2, 'A']</span></span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>



<p><strong>unshift和shift</strong></p>
<p>如果要往<code>Array</code>的头部添加若干元素，使用<code>unshift()</code>方法，<code>shift()</code>方法则把<code>Array</code>的第一个元素删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// 'A'</span></span><br><span class="line">arr; <span class="comment">// ['B', 1, 2]</span></span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br><span class="line">arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></span><br><span class="line">arr; <span class="comment">// []</span></span><br></pre></td></tr></table></figure>



<p><strong>sort</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>];</span><br><span class="line">arr.sort();</span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure>



<p><strong>reverse</strong></p>
<p><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; <span class="comment">// ['three', 'two', 'one']</span></span><br></pre></td></tr></table></figure>



<p><strong>splice</strong></p>
<p><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br></pre></td></tr></table></figure>



<p><strong>concat</strong></p>
<p><code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></span><br><span class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，<code>concat()</code>方法并没有修改当前<code>Array</code>，而是返回了一个新的<code>Array</code>。</p>
<p>实际上，<code>concat()</code>方法可以接收任意个元素和<code>Array</code>，并且自动把<code>Array</code>拆开，然后全部添加到新的<code>Array</code>里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>



<p><strong>join</strong></p>
<p><code>join()</code>方法是一个非常实用的方法，它把当前<code>Array</code>的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Array</code>的元素不是字符串，将自动转换为字符串后再连接。</p>
<br>



<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript的对象是一组由<code>键-值</code>组成的无序集合，用一个<code>{...}</code>表示一个对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'Bob'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</span><br><span class="line">    city: <span class="string">'Beijing'</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，最后一个键值对不需要在末尾加<code>,</code>，如果加了，有的浏览器（如低版本的IE）将报错。</p>
<p>JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述<code>person</code>对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，<code>person</code>的<code>name</code>属性为<code>&#39;Bob&#39;</code>，<code>zipcode</code>属性为<code>null</code>。</p>
<p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name; <span class="comment">// 'Bob'</span></span><br><span class="line">person.zipcode; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>



<p>访问属性是通过<code>.</code>操作符完成的，但这要求属性名必须是一个有效的变量名。如果<strong>属性名包含特殊字符</strong>，就必须用<code>&#39;&#39;</code>括起来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaohong = &#123;</span><br><span class="line">    name: <span class="string">'小红'</span>,</span><br><span class="line">    <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>xiaohong</code>的属性名<code>middle-school</code>不是一个有效的变量，就需要用<code>&#39;&#39;</code>括起来。访问这个属性也无法使用<code>.</code>操作符，必须用<code>[&#39;xxx&#39;]</code>来访问：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaohong[<span class="string">'middle-school'</span>]; <span class="comment">// 'No.1 Middle School'</span></span><br><span class="line">xiaohong[<span class="string">'name'</span>]; <span class="comment">// '小红'</span></span><br><span class="line">xiaohong.name; <span class="comment">// '小红'</span></span><br></pre></td></tr></table></figure>

<p>实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。</p>
<p>如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回<code>undefined</code></p>
<p>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line">xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></span><br><span class="line">xiaoming.age; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></span><br><span class="line">xiaoming.name; <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></span><br></pre></td></tr></table></figure>



<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    school: <span class="string">'No.1 Middle School'</span>,</span><br><span class="line">    height: <span class="number">1.70</span>,</span><br><span class="line">    weight: <span class="number">65</span>,</span><br><span class="line">    score: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不过要小心，如果<code>in</code>判断一个属性存在，这个属性不一定是<code>xiaoming</code>的，它可能是<code>xiaoming</code>继承得到的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为<code>toString</code>定义在<code>object</code>对象中，而所有对象最终都会在原型链上指向<code>object</code>，所以<code>xiaoming</code>也拥有<code>toString</code>属性。</p>
<p>要判断一个属性是否是<code>xiaoming</code>自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span></span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<br>



<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefined</span><br><span class="line">var $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1</span><br><span class="line">var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串</span><br><span class="line">var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值true</span><br><span class="line">var t &#x3D; null; &#x2F;&#x2F; t的值是null</span><br></pre></td></tr></table></figure>



<p>在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意<strong>只能用<code>var</code>申明一次</strong>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure>

<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言（例如int）</p>
<p>使用<code>var</code>申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p>
<br>



<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>要过滤掉对象继承的属性，用<code>hasOwnProperty()</code>来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// '0', '1', '2'</span></span><br><span class="line">    <span class="built_in">console</span>.log(a[i]); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>请注意</strong>，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</p>
<br>



<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>Map</code>是一组键值对的结构，具有极快的查找速度。</p>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>];</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>];</span><br></pre></td></tr></table></figure>

<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>

<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">88</span>);</span><br><span class="line">m.get(<span class="string">'Adam'</span>); <span class="comment">// 88</span></span><br></pre></td></tr></table></figure>

<br>



<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在<code>Set</code>中，没有重复的key。</p>
<p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>



<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>);</span><br><span class="line">s; <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>



<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

<br>



<h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。</p>
<p>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。</p>
<p><code>for...in</code>和<code>for...of</code>的区别：</p>
<ul>
<li>for in 循环的是对象的属性（普通数组的属性就是index）</li>
<li>for of 循环的是迭代器中的每一个元素</li>
</ul>
<p>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></span><br><span class="line">    <span class="built_in">console</span>.log(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你可能会有疑问，<code>for ... of</code>循环和<code>for ... in</code>循环有何区别？</p>
<p>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.name = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// '0', '1', '2', 'name'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。</p>
<p><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.name = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 'A', 'B', 'C'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// element: 指向当前元素的值</span></span><br><span class="line">    <span class="comment">// index: 指向当前索引</span></span><br><span class="line">    <span class="comment">// array: 指向Array对象本身</span></span><br><span class="line">    <span class="built_in">console</span>.log(element + <span class="string">', index = '</span> + index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><code>Map</code>的回调函数参数依次为<code>value</code>、<code>key</code>和<code>map</code>本身：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>基本数据类型和引用数据类型的区别：<a href="https://www.cnblogs.com/c2016c/articles/9328725.html" target="_blank" rel="noopener">https://www.cnblogs.com/c2016c/articles/9328725.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用指令及美化博客页面</title>
    <url>/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><p>Hexo的命令总体来说比较简单，安装成功之后只需要记住常用的四种即可。在当前blog文件夹根目录下右键点击git bash：</p>
<ul>
<li><code>hexo s</code>：server启动服务器</li>
<li><code>hexo clean</code>：clean清除缓存文件（db.json）和已生成的静态文件（public）</li>
<li><code>hexo generate</code>或<code>hexo g</code>：generate生成静态文件</li>
<li><code>hexo deploy</code>或<code>hexo d</code>：deploy部署网站，部署网站前需预先生成静态文件</li>
</ul>
<p>一般更改完后执行三条指令：<code>hexo clean</code>，<code>hexo generate</code>，<code>hexo deploy</code>即可（按顺序）</p>
<p>如果要进行文件压缩，在<code>hexo generate</code>指令后，执行<code>gulp</code>指令。</p>
<p>参考<a href="https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/" target="_blank" rel="noopener">https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/</a></p>
<h2 id="hexo各种美化"><a href="#hexo各种美化" class="headerlink" title="hexo各种美化"></a>hexo各种美化</h2><h3 id="新建page"><a href="#新建page" class="headerlink" title="新建page"></a>新建page</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章名称&quot;</span><br></pre></td></tr></table></figure>

<p>会在source文件夹下_post中新建文件夹和.md文件</p>
<h3 id="侧栏增加标签和分类页面"><a href="#侧栏增加标签和分类页面" class="headerlink" title="侧栏增加标签和分类页面"></a>侧栏增加标签和分类页面</h3><h4 id="创建标签页面"><a href="#创建标签页面" class="headerlink" title="创建标签页面"></a>创建标签页面</h4><ul>
<li><p>创建标签页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2017-12-02 21:01:24</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="创建分类页面"><a href="#创建分类页面" class="headerlink" title="创建分类页面"></a>创建分类页面</h4><ul>
<li><p>创建分类页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2017-12-02 21:01:24</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="文章中插入图片"><a href="#文章中插入图片" class="headerlink" title="文章中插入图片"></a>文章中插入图片</h3><ol>
<li><p>将图片放置在页面对应的文件夹中</p>
</li>
<li><p>在文章中引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片名称 %&#125;</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h3 id="设置站点图标"><a href="#设置站点图标" class="headerlink" title="设置站点图标"></a>设置站点图标</h3><ol>
<li><p>先在images文件夹下放入你的图标</p>
</li>
<li><p>在主题配置页面_config.yml中搜索<code>favicon</code>，找到以下位置，并将路径修改为你的图标：</p>
<img src="/images/loading.png" data-original="/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/1.png" class>

</li>
</ol>
<p>部署之后就可以看到效果了，查看效果：<a href="http://delaprada.com">http://delaprada.com</a></p>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><ol>
<li>在images文件夹中放入你的头像图片</li>
<li>在主题配置页面中修改avatar为你的图片地址：</li>
</ol>
<img src="/images/loading.png" data-original="/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/2.png" class>



<h3 id="首页文章不显示全文只显示摘要"><a href="#首页文章不显示全文只显示摘要" class="headerlink" title="首页文章不显示全文只显示摘要"></a>首页文章不显示全文只显示摘要</h3><p>修改<code>/themes/next/_config.yml</code>主题配置文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scroll_to_more: true        #如果文章有摘要,会自动滚动到摘要下面</span><br><span class="line">save_scroll: true           #通过cookies来缓存阅读进度</span><br><span class="line">excerpt_description: true   #自动摘录描述作为序言</span><br><span class="line">auto_excerpt:               #设置阅读全文</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150                 #摘要次数</span><br><span class="line">read_more_btn: true         #阅读全文按钮</span><br></pre></td></tr></table></figure>



<h3 id="修改文章底部的带-的标签"><a href="#修改文章底部的带-的标签" class="headerlink" title="修改文章底部的带#的标签"></a>修改文章底部的带#的标签</h3><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将#改为<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>（如果想换成其他图标可到font-awesome中文网查看）</p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p>在<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>，并加入以下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> <span class="keyword">not</span> is_index %&#125;</span><br><span class="line">        &lt;div style="text-align:center;color: #ccc;font-size:15px;"&gt;-------本&amp;nbsp;文&amp;nbsp;		结&amp;nbsp;束&amp;nbsp;&amp;nbsp;&lt;i class="fa fa-heart" aria-hidden="true"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;感			&amp;nbsp;谢&amp;nbsp;您&amp;nbsp;的&amp;nbsp;阅&amp;nbsp;读-------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在post-body标签之后，post-footer标签之前，添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">    	&#123;% include &#39;passage-end-tag.swig&#39; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<h3 id="修改网页背景颜色和侧栏上方brand的颜色"><a href="#修改网页背景颜色和侧栏上方brand的颜色" class="headerlink" title="修改网页背景颜色和侧栏上方brand的颜色"></a>修改网页背景颜色和侧栏上方brand的颜色</h3><p>打开<code>themes/next/layout/source/css/_custom/custom.styl</code>，加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改网页背景颜色</span><br><span class="line">body &#123;</span><br><span class="line">    background-color: #F0F8FF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer a &#123;</span><br><span class="line">    color:#eee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改网站头部颜色</span><br><span class="line">.headband &#123;</span><br><span class="line">    height: 3px;</span><br><span class="line">    background: #ADD8E6;</span><br><span class="line">&#125;</span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: 20px 0;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background: #ADD8E6;</span><br><span class="line">&#125;</span><br><span class="line">.site-title &#123;</span><br><span class="line">    color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="侧边栏社交设置和友情链接"><a href="#侧边栏社交设置和友情链接" class="headerlink" title="侧边栏社交设置和友情链接"></a>侧边栏社交设置和友情链接</h3><p>修改主题配置页面：<code>themes/next/_config.yml</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">site_state: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to <span class="built_in">end</span> users.</span><br><span class="line"># Value before `||` delimeter is the target permalink.</span><br><span class="line"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span><br><span class="line">social:</span><br><span class="line">  CSDN: https:<span class="comment">//blog.csdn.net/weixin_41973410 || copyright</span></span><br><span class="line">  GitHub: https:<span class="comment">//github.com/delaprada || github</span></span><br><span class="line"></span><br><span class="line">social_icons:  #这里是上面社交链接的对应图标</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  CSDN: copyright</span><br><span class="line">  Github: github</span><br><span class="line">  icons_only: <span class="literal">false</span></span><br><span class="line">  transition: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># Follow me on GitHub banner in right-top corner.</span><br><span class="line"># Usage: `permalink || title`</span><br><span class="line"># Value before `||` delimeter is the target permalink.</span><br><span class="line"># Value after `||` delimeter is the title <span class="keyword">and</span> aria-label name.</span><br><span class="line">#github_banner: https:<span class="comment">//github.com/Fitz1318 || Follow me on GitHub</span></span><br><span class="line"></span><br><span class="line"># Blog rolls  #这里时设置一些相关链接 我这里设置了一些推荐阅读的网站</span><br><span class="line">#links_icon: link</span><br><span class="line">links_title: 实用网站</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: <span class="keyword">inline</span></span><br><span class="line">links:</span><br><span class="line">  W3Cschool: http:<span class="comment">//www.w3school.com.cn/</span></span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo categories和tags页面不显示解决办法</title>
    <url>/2019/12/25/hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>﻿官网也有给出具体步骤，但是有坑<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Hexo官网教程</a></p>
<h4 id="第一步-在终端窗口下，定位到-Hexo-站点目录下。使用-hexo-new-page指令新建一个页面，命名为-categories-："><a href="#第一步-在终端窗口下，定位到-Hexo-站点目录下。使用-hexo-new-page指令新建一个页面，命名为-categories-：" class="headerlink" title="第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ："></a>第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd hexo <span class="comment">//根目录</span></span><br><span class="line">hexo <span class="keyword">new</span> page categories <span class="comment">//tags和这个操作一致</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="第二步-找到新建的页面，添加type"><a href="#第二步-找到新建的页面，添加type" class="headerlink" title="第二步 找到新建的页面，添加type"></a>第二步 找到新建的页面，添加type</h4><p>新建的页面一般在source/categories/index.md中，添加以下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">45</span></span><br><span class="line">type: <span class="string">"categories"</span></span><br><span class="line">layout: <span class="string">"categories"</span></span><br></pre></td></tr></table></figure>

<br>

<h4 id="第三步-给你的页面添加分类"><a href="#第三步-给你的页面添加分类" class="headerlink" title="第三步 给你的页面添加分类"></a>第三步 给你的页面添加分类</h4><p>找到你的页面，在页面上方添加如下内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: 利用gitpages+hexo搭建自己的博客</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">12</span>:<span class="number">55</span></span><br><span class="line">categories:</span><br><span class="line">- Hexo</span><br><span class="line">tags:</span><br><span class="line">- 前端</span><br></pre></td></tr></table></figure>

<p>但此时部署到github上后，打开网页点击分类和标签页面还是出现404！</p>
<br>

<h4 id="第四步-解决方案"><a href="#第四步-解决方案" class="headerlink" title="第四步 解决方案"></a>第四步 解决方案</h4><p>实属官方坑人系列！！<br>主题配置文件_config.yml中的menu：<br>把 / 后面的空格全部去掉（刚开始的时候默认后面是加了空格导致点击页面出现404）<br><img src="/images/loading.png" data-original="hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/1.png" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用gitpages+hexo搭建自己的博客</title>
    <url>/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始开始着手搭建到完成大概花了一个下午的时间，采坑不少，在此记录一下</p>
<h2 id="第一步-准备工作"><a href="#第一步-准备工作" class="headerlink" title="第一步 准备工作"></a>第一步 准备工作</h2><p>node.js下载好，github有已注册的账号<br>在github中新建一个repository，命名为：你的github名称.github.io（下面是我的仓库名称）：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/1.png" class>

<p>（有些博客直接让我们fork它们的项目，个人感觉这么做不太好，很多东西自己动手做一遍更好）</p>
<h2 id="第二步-安装Hexo"><a href="#第二步-安装Hexo" class="headerlink" title="第二步 安装Hexo"></a>第二步 安装Hexo</h2><p>Hexo就是一个博客框架，官网上也有安装教程<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官网</a></p>
<p><strong>step1</strong>：windows系统鼠标右键git bash，输入两个安装指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g   &#x2F;&#x2F;用于安装hexo</span><br><span class="line">npm install hexo-deployer-git --save   &#x2F;&#x2F;用于安装hexo部署到git page的deployer</span><br></pre></td></tr></table></figure>



<p><strong>step2</strong>：创建hexo文件夹<br>hexo安装完成之后，在电脑中新建一个hexo文件夹：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/2.png" class>

<p>右键点击git bash，输入两个命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install   &#x2F;&#x2F;安装所有package.json里的包</span><br></pre></td></tr></table></figure>
<p>执行完成后，hexo文件夹中会多出一些文件：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/3.png" class>



<p>如果想看本地效果的话，执行以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo generate  &#x2F;&#x2F;自动将md文件生成静态html，css文件</span><br><span class="line">hexo server  &#x2F;&#x2F;启动本地hexo服务器（localhost:4000）</span><br></pre></td></tr></table></figure>


<p>打开 localhost:4000就可以看到页面啦：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/4.png" class>

<p>（页面会不太一样，我的配了一下主题）</p>
<h2 id="第三步-了解hexo文件夹中的-config-yml"><a href="#第三步-了解hexo文件夹中的-config-yml" class="headerlink" title="第三步 了解hexo文件夹中的_config.yml"></a>第三步 了解hexo文件夹中的_config.yml</h2><p>hexo文件夹中比较重要的文件是：_config.yml：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/5.png" class>



<p>它是一个全局配置文件，包括和github上传链接都在这里配置，例如title之类的：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/6.png" class>





<h2 id="第四步-本地上传到github"><a href="#第四步-本地上传到github" class="headerlink" title="第四步 本地上传到github"></a>第四步 本地上传到github</h2><p><strong>step1</strong>：执行命令，安装deploy.git插件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>



<p><strong>step2</strong>：在主题配置文件_config.yml中修改仓库地址，在_config.yml最下面一行（注意每个冒号后面都有一个空格）</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/7.png" class>



<p><strong>step3</strong>：配置提交github认证方式<br>执行指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>直接提交到github仓库中，如果没有认证github和本地的关系，会提示输入用户名和密码</p>
<p>此时打开github的项目会发现原本是空的项目现在有了刚刚上传的文件</p>
<h2 id="第五步-添加域名"><a href="#第五步-添加域名" class="headerlink" title="第五步 添加域名"></a>第五步 添加域名</h2><p>在阿里云中购买了一个.com的域名（加优惠一年23块，虽然比其他贵一些但是觉得.com好听一些(#^ . ^#)）</p>
<p><strong>step1</strong>：cmd ping一下github.io获得真实ip地址</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/8.png" class>



<p><strong>step2：</strong>然后再域名操作栏点击解析，添加记录</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/9.png" class>

<p>注意要两个都要添加（之前一开始只添加了www不知道为啥就显示不出来）</p>
<p><strong>step3</strong>：去hexo文件夹的source目录下新建名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/10.png" class>



<p><strong>step4：</strong>然后部署</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> hexo clean</span><br><span class="line"><span class="number">2.</span> hexo generate</span><br><span class="line"><span class="number">3.</span> hexo deploy</span><br></pre></td></tr></table></figure>
<p>（每次做出更改建议都部署一遍）</p>
<p><strong>step5：</strong>点击设置，拉到下面，在custom domain中输入你的域名。如果上面的信息不是显示Your site is published at <a href="https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证" target="_blank" rel="noopener">https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证</a></p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/12.png" class>

<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/11.png" class>



<p>输入域名，成功：</p>
<img src="/images/loading.png" data-original="/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/13.png" class>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
