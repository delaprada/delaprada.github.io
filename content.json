{"meta":{"title":"Alice的博客","subtitle":"","description":"Goals determine what you going to be!","author":"Alice","url":"http://delaprada.com","root":"/"},"pages":[{"title":"categories","date":"2019-12-25T01:15:45.000Z","updated":"2019-12-26T12:39:38.305Z","comments":false,"path":"categories/index.html","permalink":"http://delaprada.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-25T01:50:31.000Z","updated":"2019-12-26T12:39:54.263Z","comments":false,"path":"tags/index.html","permalink":"http://delaprada.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"每日一题——腐烂的橘子","slug":"每日一题——腐烂的橘子","date":"2020-03-04T01:47:21.000Z","updated":"2020-03-04T01:49:58.798Z","comments":true,"path":"2020/03/04/每日一题——腐烂的橘子/","link":"","permalink":"http://delaprada.com/2020/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","excerpt":"","text":"在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 123456789101112输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。示例 3：输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1231 &lt;&#x3D; grid.length &lt;&#x3D; 101 &lt;&#x3D; grid[0].length &lt;&#x3D; 10grid&#96;[i][j]&#96; 仅为 0、1 或 2 思路： 广度优先搜索。广度优先搜索的话一般会使用队列的思想，深度优先搜索使用栈的思想。最主要还有如何去控制节点去上下左右遍历，所以我们要设置一个locs数组为：[[0,-1],[0,1],[1,0],[-1,0]]，在遍历每个队列元素时，都让它去和locs数组的每个元素进行相加减，得到这个元素上下左右的元素，将为1的元素（即新鲜橙子），变为2（即腐烂橙子）。因为我们要计算时间，但又不能将循环次数用来计时，所以我们将时间和节点的x，y坐标一齐作为一个元素进入队列。 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var orangesRotting = function(grid) &#123; var row=grid.length; var col=grid[0].length; var queue=[]; var locs=[[0,-1],[0,1],[1,0],[-1,0]]; var time=0; var x,y; for(var i=0;i&lt;row;++i)&#123; for(var j=0;j&lt;col;++j)&#123; if(grid[i][j]==2)&#123; queue.push([i,j,time]); &#125; &#125; &#125; while(queue.length!==0)&#123; //这是queue！！不要写成stack,先进先出是用shift [x,y,time]=queue.shift(); for(var t=0;t&lt;locs.length;++t)&#123; var new_x=x+locs[t][0]; var new_y=y+locs[t][1]; if(new_x&gt;=0&amp;&amp;new_x&lt;row&amp;&amp;new_y&gt;=0&amp;&amp;new_y&lt;col)&#123; if(grid[new_x][new_y]===1)&#123; queue.push([new_x,new_y,time+1]); grid[new_x][new_y]=2; &#125; &#125; &#125; &#125; for(var p=0;p&lt;row;++p)&#123; for(var q=0;q&lt;col;++q)&#123; if(grid[p][q]==1)&#123; return -1; &#125; &#125; &#125; return time;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——版本号比较 随机生成字符串 类型比较","slug":"每日一题——版本号比较-随机生成字符串","date":"2020-03-03T09:01:38.000Z","updated":"2020-03-03T14:14:37.536Z","comments":true,"path":"2020/03/03/每日一题——版本号比较-随机生成字符串/","link":"","permalink":"http://delaprada.com/2020/03/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"版本号比较比较版本号 （类似1.0.1/1.2.0/1.2/0.1）实现一个方法，用于比较两个版本号（version1、version2）如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则x.y.z，xyz均为大于等于0的整数，至少有x位 123456789101112131415161718192021222324252627282930313233function compare(str1,str2)&#123; str1=str1.split(\".\"); str2=str2.split(\".\"); str1=str1.map(Number); str2=str2.map(Number); var len; var len1=str1.length; var len2=str2.length; if(len1&gt;len2)&#123; len=len2; &#125; else&#123; len=len1; &#125; for(var i=0;i&lt;len;++i)&#123; if(str1[i]&gt;str2[i])&#123; return 1; &#125; else if(str1[i]&lt;str2[i])&#123; return -1; &#125; &#125; if(len1===len2)&#123; return 0; &#125; else if(len1&gt;len2)&#123; return 1; &#125; else&#123; return -1; &#125;&#125;console.log(compare('1.0.1','1.0')); 随机生成字符串随机生成字符串实现一个随机符串生成函数 randomStr()，要求如下：生成的随机的字符串应该以字母开头，并包含 [a-z][0-9] 这些字符。生成的字符串长度为 8。生成的字符串不能够在程序运行的生命周期中存在重复的情形。 1234567891011121314function randomString(len,chars)&#123; var res=''; for(var i=0;i&lt;len;++i)&#123; //因为Math.random()包括0但不包括1，所以可以直接乘上chars.length if(i==0)&#123; res+=chars[Math.floor(Math.random()*26)]; &#125; else&#123; res+=chars[Math.floor(Math.random()*chars.length)]; &#125; &#125; return res;&#125;console.log(randomString(8,'abcdefghijklmnopqrstuvwxyz0123456789')); 隐式类型转换下面代码中 a 在什么情况下会打印 1？1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 题解： 123456789var a=&#123; i:1, toString()&#123; return this.i++; &#125;&#125;if(a==1&amp;&amp;a==2&amp;&amp;a==3)&#123; console.log(1);&#125;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"易混淆JS题目——this指向 闭包","slug":"易混淆JS题目——this指向-闭包","date":"2020-02-18T02:23:00.000Z","updated":"2020-02-18T02:24:06.154Z","comments":true,"path":"2020/02/18/易混淆JS题目——this指向-闭包/","link":"","permalink":"http://delaprada.com/2020/02/18/%E6%98%93%E6%B7%B7%E6%B7%86JS%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94this%E6%8C%87%E5%90%91-%E9%97%AD%E5%8C%85/","excerpt":"","text":"Q：代码运行结果 1234567var a = function () &#123; this.b = 3; &#125;var c = new a();a.prototype.b = 9;var b = 7;a();console.log(b);console.log(c.b); 解： 整个代码在变量提升之后可以写为： 123456789101112var a;var c;var b;a=function()&#123; this.b=3;&#125;c=new a();a.prototype.b=9;b=7;a();console.log(b);console.log(c.b); 注意：函数声明的时候还没有执行！不要弄混了。当执行c=new a()的时候，会将函数a内部的this指向c，所以c.b此时就是3。a.prototype.b=9没有什么影响。b=7;表示将全局变量b赋值为7。此后执行了函数a()，要注意在默认情况下，函数中this的指向是指向全局作用域的，所以执行函数a()的话是把全局变量b的值变为3。所以输出的是3 3。 Q：以最小的改动解决以下代码的错误（可以使用es6） 123456789101112131415const obj = &#123;name: \" jsCoder\",skill: [\"es6\", \"react\", \"angular\"],say: function () &#123; for(var i = 0, len = this.skill.length; i&lt; len; i++)&#123; setTimeout(function()&#123; console.log('No.' + i + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i); &#125;&#125;&#125;;obj.say(); 解： 第一点：for循环当中有个异步函数，而且异步函数根据for循环i的值依次输出No.1，No.2，No.3，这样的话for循环中i必须使用let去声明，因为使用let才能让异步函数记住每一轮i的值，得到相应的输出结果。 第二点：在对象函数say中，有一个异步函数，它使用了this。源代码的意图是想让这个this表示对象obj，但是对象的方法say的this指向的是obj，但是这个方法内部的函数（使用了闭包）是指向全局变量的！这么写是得不到想要的结果的。所以要将setTimeout函数改为箭头函数，因为箭头函数它会继承上一层作用域的this，所以它会继承say函数的this，就会指向obj了。 修改后的代码为： 12345678910111213141516const obj = &#123; name: \" jsCoder\", skill: [\"es6\", \"react\", \"angular\"], say: function () &#123; for(let i = 0,len=this.skill.length; i&lt;len; i++)&#123; //闭包！！ setTimeout(()=&gt;&#123; console.log('No.' + (i+1) + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i+1); &#125; &#125;&#125;;obj.say(); Q：repeat 实现，使用JS实现一个repeat方法，调用这个 repeatedFunc(“helloworld”)，会alert4次 helloworld, 每次间隔3秒 1234function repeat(func, times, wait) &#123;&#125;const repeatFunc = repeat(alert, 4, 3000)repearFunc(\"helloworld\"); 解： 这种问题一般要结合闭包来实现。 1234567891011121314function repeat(func, times, wait)&#123; var count=0; var timer=null; return function()&#123; var args=[].slice.call(arguments); timer=setInterval(function()&#123; if(count==(times-1))&#123; clearTimeout(timer); &#125; func(args.join(\"\")); count++; &#125;,wait) &#125;&#125; 题目中说，调用repeatedFunc(&quot;helloworld&quot;)会有相关的结果，所以它应该是在函数中还有一个函数的，所以应该有个闭包。通过闭包可以记住count的值。注意clearTimeout要写在setInterval函数当中，这个和防抖节流不同，因为它只执行了一次函数，它是通过setInterval函数的循环才会输出多次结果，所以要写在里面才能够判断count的值是否已经到达输出次数。 Q：实现每隔1s输出一个数组的元素及其索引 解： 这题和上一题的思路类似，但是它没有需要说要调用的时候再去执行，那就不需要写return functionf(){}了。因为setInterval函数已经是output函数的内部函数，有闭包能够记住count的值了。 123456789101112131415function output(arr) &#123; var length = arr.length; var count = 0; var timer = null; timer = setInterval(function() &#123; if (count == length - 1) &#123; clearTimeout(timer); &#125; console.log(arr[count]); console.log(count); count++; &#125;, 1000);&#125;output([1, 2, 3, 4, 5]);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Vue之计算属性的应用","slug":"Vue之计算属性的应用","date":"2020-02-17T02:52:19.000Z","updated":"2020-02-17T02:54:22.665Z","comments":true,"path":"2020/02/17/Vue之计算属性的应用/","link":"","permalink":"http://delaprada.com/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"昨天面试的时候被问到了Vue计算属性相关的代码题，又是一脸懵逼呀…赶紧来总结一下。 面试官先出了第一道题，点击div时输出是什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 输出是3。 首先，computed中的属性都是以函数的形式声明的，看看官网的例子： 结果是： 123Original message: &quot;Hello&quot;Computed reversed message: &quot;olleH&quot; computed属性它所依赖的数据是data当中的，是要使用this来去获取的。所以计算属性c中的this.b和this.a其实是data当中的属性值。执行点击事件之后，b是会发生变化的，所以在计算属性c中输出this.b是会发生变化的，所以在控制台会输出3。因为计算属性creturn的是this.a，所以的值是不变的，是1。 接着面试官又出了第二道题，此时又输出什么？（其实面试官人真的好好，他的表述是此时会输出么？他这么问的话我就会倾向于回答不会输出） 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; if(false)&#123; console.log(this.b); return this.a; &#125; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 答案是不输出。此时c连渲染都不会发生。 最后面试官又问了第三道题，此时会输出什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;absdflj&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 此时这个计算属性并没有写在页面上，所以是不会监听c的值，此时控制台没有输出，页面显示的是：absdflj。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"JavaScript之变量提升","slug":"JavaScript之变量提升","date":"2020-02-17T01:58:59.000Z","updated":"2020-02-17T02:32:12.967Z","comments":true,"path":"2020/02/17/JavaScript之变量提升/","link":"","permalink":"http://delaprada.com/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"今天面试的时候被问到了变量提升的问题，一脸懵逼，掌握得不够熟练，写篇博客来总结一下。 JS代码解析规则 第一步为解释：先扫描所有的JS代码，把所有声明提升到顶端。 第二步为执行：执行就是操作一类的。 变量提升例一： 12console.log(a); //undefinedvar a=10; 因为有变量提升，上面的代码相当于： 123var a;console.log(a);a=10; 函数提升函数声明的两种方式 函数声明式 1function bar()&#123; &#125; 函数字面量式 1var bar=function()&#123; &#125; 注意：函数字面量式的提升和变量提升一样，都是只提升声明，不提升赋值，比如上面代码中函数字面量式，只会把var bar提升上去，但是函数声明式是会将整个函数体都提升上去。 例二： 1234foo(); //aaafunction foo()&#123; console.log(\"aaa\");&#125; 因为存在函数声明提升，函数声明提升会直接把整个函数提升到执行环境的最顶端。相当于： 1234function foo()&#123; console.log(\"aaa\");&#125;foo(); 注意：变量提升只提升变量名，而函数提升是会提升整个函数体。函数提升在变量提升之前。 例三： 1234foo(); //foo is not a functionvar foo = function()&#123; console.log(\"aaa\");&#125; 因为进行了变量提升（函数字面量式），上面的代码相当于： 12345var foo;foo();foo=function()&#123; console.log(\"aaa\");&#125; JS解析在遇到foo()时会默认当做函数来解析，所以会输出foo is not a function。 例四： 1234567console.log(foo);var foo=10;console.log(foo);function foo()&#123; console.log(10);&#125;console.log(foo); 输出： 上面的代码相当于： 12345678function foo()&#123; console.log(10);&#125;var foo;console.log(foo); //foo()&#123;console.log(10);&#125;foo=10;console.log(foo); //10console.log(foo); //10 第一个console.log(foo)之所以输出函数体，是因为var foo只是声明（提升了的声明），并没有赋值，所以它会调用上面的函数体。 面试题先看一道经典面试题： 123456789console.log(v1);var v1 = 100;function foo() &#123; console.log(v1); var v1 = 200; console.log(v1);&#125;foo();console.log(v1); 输出是： 1234&#x2F;&#x2F;undefined&#x2F;&#x2F;undefined&#x2F;&#x2F;200&#x2F;&#x2F;100 上面的代码相当于： 1234567891011var v1;console.log(v1); //undefinedv1=100;function foo()&#123; var v1; console.log(v1); //undefined v1=200; console.log(v1); //200&#125;foo();console.log(v1); //100 注意，如果内部没有声明v1的时候，函数才会到全局作用域去查找变量的赋值。但是如果函数作用域内部定义了的话，就不会到全局作用域去找。参照作用域链的定义。 看一道字节面试时候的题目： 1234567891011var a = 'byte'function foo() &#123; if (a === undefined) &#123; var a = 'dance' &#125; else &#123; a = 'bytedance' &#125; return a;&#125;console.log(foo());console.log(a); 输出为： 12&#x2F;&#x2F;dance&#x2F;&#x2F;byte 上面代码实际效果是： 1234567891011121314function foo()&#123; var a; if(a===undefined)&#123; a='dance'; &#125; else&#123; a='bytedance'; &#125; return a;&#125;var a;a='byte';console.log(foo());console.log(a); 在当前作用域有对变量进行声明的时候，是不会去上一级作用域去寻找变量的声明的。 因为console.log(a)在当前函数作用域找到了var a;，即a的定义，所以它不会去全局作用域去找a的声明（及值）。 上面的代码也是这个道理，a===undefined会找到当前函数作用域的var a;的定义，所以a的值为undefined。 参考：https://blog.csdn.net/qq_39712029/article/details/80951958 ​ https://blog.csdn.net/Demo_18/article/details/78493489","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Math.floor()和~~运算符的异同","slug":"Math-floor-和-的异同","date":"2020-02-10T03:14:06.000Z","updated":"2020-02-10T03:30:38.297Z","comments":true,"path":"2020/02/10/Math-floor-和-的异同/","link":"","permalink":"http://delaprada.com/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"今天在用JavaScript实现大数相加的时候，发现网上的解法当中有使用~~运算符，之前没有见过。在网上一查，说是Math.floor()的更好的一种表示方法，运行速度更快。但是将大数相加的代码中的~~换成Math.floor()发觉得不到正确的答案，所以想来分析一下异同。 ~和~~~运算符用于将整数变为-(N+1)。 例如： 1234~2 &#x3D;&#x3D;&#x3D; -3; &#x2F;&#x2F;true~1 &#x3D;&#x3D;&#x3D; -2; &#x2F;&#x2F;true~0 &#x3D;&#x3D;&#x3D; -1; &#x2F;&#x2F;true~-1 &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;true ~~运算符~~是Math.floor()的一个替代，相同的操作但是更快。可以使用它将任何浮点数转换为整数（下取整）。 例如： 123~~2 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~2.4 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~3.9 &#x3D;&#x3D;&#x3D; Math.floor(3); &#x2F;&#x2F;true, 3 ~~和Math.floor()在性能上的不同： # Browser Math.floor() Bitwise double NOT ~~ #1 Firefox 7.0.1 42ms 29ms #2 Firefox 7.0.1 44ms 28ms #3 Chrome 15 63ms 64ms #4 Chrome 15 63ms 68ms #5 IE8 265ms 192ms #6 IE8 324ms 190ms 大数相加在大数相加时，使用~~能够的到正确的结果： 但是使用Math.floor()时，结果是： 主要是因为当a数组已经pop完毕之后，再对a执行pop操作时，输出的是undefined。而~~操作undefined和Math.floor()操作undefined是会得出不同的结果的： 所以才会导致上面的结果。 参考：http://rocha.la/JavaScript-bitwise-operators-in-practice","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2020-02-04T10:17:33.000Z","updated":"2020-02-17T10:17:45.311Z","comments":true,"path":"2020/02/04/浏览器缓存/","link":"","permalink":"http://delaprada.com/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"缓存过程分析： 浏览器每次发起请求，都会先在浏览器缓存中查找请求的结果以及缓存标识 如果没有该请求的缓存结果和缓存标识的话，浏览器会向服务器发起http请求，服务器返回该请求结果和缓存规则 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强缓存和协商缓存浏览器缓存分为：强缓存和协商缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源。可以通过设置两种http header实现：Expires和Cache-Control。 Expires是http/1的产物。它用来指定资源到期的时间，Expires是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间之前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 1Expires: Thu, 10 Nov 2017 08:45:11 GMT 这个字段设置时有两个缺点： 由于是绝对时间，用户可能会将客户端本地的时间修改，而导致浏览器判断缓存失效，重新请求该资源。 写法太复杂，表示时间的字符串多个空格，少个字母都会导致非法属性从而失效 Cache-control是http/1.1的产物。和Expires的差别在于，Expires是绝对时间，Cache-control表示的是相对时间 1Cache-control: max-age=2592000 Cache-control字段常用的值： max-age：即最大有效时间 must-revalidate：如果超过了max-age的时间，浏览器必须向服务器发送请求，验证资源是否还有效 no-cache：不是不缓存的意思！表示可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用。 no-store：彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取 public：所有内容都可以被缓存（包括客户端和代理服务器，如CDN） private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。 自从http/1.1开始，Expires逐渐被Cache-control取代。Cache-control是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且Cache-control的可配置性比较强大。 强缓存判断是否缓存的依据来自于是否超出某个时间或者时间段，而不关心服务器端文件是否已经更新，这可能导致加载文件不是服务器端最新的内容。那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存：是由服务器来确定缓存资源是否可用，所以客户端与服务器端需要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 主要有以下两种标识： Last-Modified和If-Modified-Since： Last-Modified：浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加Last-Modified的header，值是这个资源在服务器端的最后修改时间。 If-Modified-Since：浏览器下一次请求这个资源，浏览器检测有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值。服务器再次收到这个资源的请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，可以直接从缓存读取。如果服务器端这个资源在If-Modified-Since之后被修改了，说明文件有更新，返回新的资源文件和200。 Etag和If-None-Match: Etag和If-None-Match返回的是一个校验码。Etag可以保证每一个资源是唯一的，资源变化都会导致Etag变化。 当浏览器第一次请求资源的时候，服务器会在响应报文中添加Etag（表示资源的标签）。当浏览器再次发起请求的时候，请求报文中会添加If-None-Match字段，其值是上一次响应报文中Etag的值。服务器收到请求报文的时候，会检查If-None-Match的值与当前资源Etag的值是否匹配。如果匹配，也就是资源没有被修改，返回304；如果不匹配，也就是服务器端资源被修改了，返回200，并返回新的资源。 为什么有了Last-Modified和If-Modified-Since还要Etag和If-None-Match呢？ 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用 某些文件修改非常频繁，比如在秒以下级别的时间内进行修改（比如1s内修改了N次），If-Modified-Since能检查到的粒度只能是秒级别的，这种修改无法判断。 协商缓存生效：返回304和Not Modified。即服务器端资源并没有更新，可以继续使用浏览器缓存中的结果。 协商缓存失败，返回200和请求结果。即服务器端资源更新了，获取服务器端的返回结果，并把请求结果和缓存标识存入浏览器缓存中 总结缓存机制： 强制缓存优先于协商缓存进行 若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match) 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。 Last-Modified/If-Modified-Since 和 Etag/If-None-Match的主要区别就是一个是通过时间判断资源是否已被更改，一个是通过Etag来判断。Etag/If-None-Match相比于Last-Modified/If-Modified-Since来说更好。 摘自：https://www.cnblogs.com/yayaxuping/p/9707471.html ​ https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器渲染过程","slug":"浏览器渲染过程","date":"2020-01-31T01:50:01.000Z","updated":"2020-02-18T03:29:31.895Z","comments":true,"path":"2020/01/31/浏览器渲染过程/","link":"","permalink":"http://delaprada.com/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","excerpt":"","text":"浏览器渲染的过程主要包括以下5步 浏览器将获取的HTML文档解析为DOM树 处理CSS标记，构成CSS规则树 将DOM树和CSS规则树合并为渲染树（rendering tree），生成渲染树 渲染树布局，确定每个节点对象在页面上的确切大小和位置 将渲染树的各个节点绘制到屏幕上 具体流程构建DOM树当浏览器接受到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。注意：DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。 构建CSS规则树浏览器解析CSS文件并生成CSS规则树。注意：CSS解析可以与DOM解析同时执行，但与script的执行互斥。 构建渲染树（Render Tree）通过DOM树和CSS规则树，浏览器可以通过它们构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。 渲染树生成后，还不能渲染到屏幕上。因为渲染到屏幕上需要得到各个节点的位置信息，这就需要布局的处理。 渲染树布局布局阶段从渲染树的根节点开始遍历，渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。浏览器通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。 渲染树绘制将渲染树绘制到浏览器上。 主流的一些浏览器排版（渲染）引擎 浏览器 排版引擎 Chrome Opera Blink Firefox Gecko IE Trident Safari WebKit 渲染阻塞渲染阻塞的原因：由于JavaScript可以操作DOM来修改DOM结构，可以操作CSS规则树来修改节点样式，这就导致浏览器在遇到&lt;script&gt;标签时，DOM构建将暂停，直到脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。 现在可以通过在&lt;script&gt;标签上增加属性defer或者async，解决上述问题。这两个属性使得script标签不会阻塞DOM的渲染，能够异步加载script脚本，不阻塞DOM渲染。 defer如果script标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行） 使用方法： asyncasync的设置，会使得script脚本异步加载。async的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。 用图表来展示： 文档渲染 应该为 文档解析 普通的script文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载。 资源的下载是在解析过程中进行的，虽说script1脚本会很快的加载完毕，但是他前边的script2并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待script2执行完毕后再执行。当这两个脚本都执行完毕后，才会继续解析页面。 defer文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。 asyncasync脚本会在加载完毕后执行。async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的。 浏览器的回流与重绘回流：对于整个网页重新渲染一遍。 会导致回流的操作有： 页面首次渲染 浏览器窗口大小发生变化 元素尺寸或位置发生变化 元素内容发生变化（文字数量或图片大小等） 元素字体大小变化 添加或删除可见的DOM元素 激活css伪类（例如:hover） 重绘：浏览器只需要对某个元素进行重新绘制即可 会导致重绘的操作有： 修改color/background-color/visibility 由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流操作一定会伴随重绘，重绘却不一定伴随回流。 那么如何针对回流和重绘写出性能更好的代码呢？ CSS： 避免使用table布局 尽可能在DOM树的最末端改变class 避免设置多层内联样式 将动画效果应用到position属性为absolute或fixed的元素上 避免使用css表达式（例如：calc()） JavaScript 避免频繁操作样式 避免频繁操作DOM。创建一个documentFragment，在它上面应用所有的DOM操作，最后再把它添加到文档中 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 DOM CSS JS之间的关系 CSS是不会阻塞DOM的解析的，JS是会阻塞DOM的解析的 CSS是会阻塞DOM的渲染的。如果没有这个策略的话，页面首先会呈现一个原始的模样，待CSS下载完后又变成另一个模样，这样会导致用户体验变差而且渲染是有成本的。 JS是会等待CSS加载完才会执行的（如果CSS文件在JS文件之前声明的话，那JS需要等待CSS文件加载完毕后才会执行）。 原因：因为JS有时需要查询（获取）元素的一些样式，这些样式是定义在CSS文件里的，所以CSS加载完之后再去执行JS会更好一些。 所以&lt;script&gt;最好放在底部，&lt;link&gt;最好放在头部，是因为JS会阻塞DOM树的解析，CSS不会阻塞DOM树的解析。 如果头部同时有&lt;script&gt;和&lt;link&gt;的情况下，最好将&lt;script&gt;放在&lt;link&gt;上面，是因为JS会等待CSS加载完毕后才会执行，但是放在头部的JS一般不会对样式进行查询修改，所以放在前面没有太大影响（比如说引入VUE的CDN的js代码就会在头部，但是和CSS样式是无关的） 参考： https://www.cnblogs.com/jiasm/p/7683930.html https://www.jianshu.com/p/e6252dc9be32","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"什么是哈希hash","slug":"什么是哈希hash","date":"2020-01-29T10:55:11.000Z","updated":"2020-01-30T09:36:28.293Z","comments":true,"path":"2020/01/29/什么是哈希hash/","link":"","permalink":"http://delaprada.com/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/","excerpt":"","text":"哈希Hash什么是Hash通过一些计算，把关键码值映射到数组中的位置来访问记录，这个过程称为散列（hash）。 重要组成： hash函数：把关键码值映射到位置的函数称为散列函数。用h表示。 hash表：存放记录的数组称为散列表。用HT表示。 槽（slot）：散列表中的一个位置称为一个槽。 设计hash表的目标是：使得对于任何关键码值K和某个散列函数h，i=h(K)是表中满足0&lt;=h(K)&lt;M（M为HT中槽的数目）的一个槽，并且记录在HT[i]存储的关键码值与K相等。 冲突解决在实际情况中，我们根据散列方法组织的数据库必须把存储的记录存放在不大的散列表中，以避免浪费过多的空间。这样的话，有可能有多个关键码值计算出来的h(K)是一样的，但又不能同时放在同一个槽中，此时就要使用冲突解决策略。 冲突解决策略冲突解决策略一般分为两类： 开散列方法（open hashing；也称为单链方法） 闭散列方法（closed hashing；也称为开地址方法） 开散列方法开散列方法的最简单形式把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放在这个槽的链表内。 闭散列方法闭散列方法把所有记录直接存储到散列表中。每条关键码值标记为kR，记录R有一个基槽，就是h(kR)，即由散列函数计算出来的槽。如果要插入一条记录R，而另一条记录已经占据了R的基槽，那么就把R存储在表的其他槽内。 桶式散列 一种实现闭散列的方法是把散列表中的槽分成多个桶(bucket)。把散列表中的M个槽分成B个桶，每个桶中包含M/B个槽。 散列函数把每一条记录分配到某个桶的第一个槽中。 如果这个槽已经被占用，那么就顺序地沿着桶查找，直到找到一个空槽。 如果一个桶全部被占满了，那么就把这条记录存储在表后具有无限容量的溢出桶（overflow bucket）中。 线性探查最常用的散列方法。当发生冲突时，从当前基槽开始往后查找，有空位则将记录放进去。例如，2037原本应放在7的槽中，但是7已经被占用，所以往后查找空位，8是空的，于是将2037放进去。 但是这种方法会导致基本聚集。例如在上例中，下一条记录放到第2个槽的概率就是6/10了，因为取模后值为7,8,9,0,1,2都会放到第2个槽中。在理想情况下，表中的每个空槽都应该有相同的机会接受到下一个要插入的记录。 改进的冲突解决方法如何避免基本聚集呢？ 一种可能的改进方式是仍然使用线性探查，但是跳过一些槽，而且每次跳过常数c个而不是1个槽。这会生成探查函数：P(K,i)=ci。 例如，如果常数c是2的话：如果基槽被占用的话，第一次会找基槽+2的位置，看是否被占用，如果被占用了，第二次会找基槽+4的位置，如果还是被占用，则找基槽+6的位置，以此类推。即从基槽开始的偏移量将会为2,4,6。 另一种方法是使用二次探查函数（对于某些常数c1,c2,c3）：p(K,i)=c1i&lt;sup&gt;2&lt;/sup&gt;+c2i+c3。一个最简单的变体就是p(K,i)=i&lt;sup&gt;2&lt;/sup&gt;。 例如，对于一个长度M=101的散列表，假定对于关键码k1和k2，h(k1)=30，h(k2)=29。k1的探查序列为30,31,34,39；k2的探查序列为29,30,33,38。这样，尽管k2会在第二步探查k1的基槽，这两个关键码的探查序列此后就立即分开了。 双散列方法即由两个散列函数，一个散列函数用于计算基槽，另一个散列函数用于确定线性探查中的常数。即线性探查此时的形式为：p(K,i)=i*h2(K)。 例如，假定散列表的长度是M=101，有3个关键码k1，k2，k3，h(k1)=30，h(k2)=28，h(k3)=30，h2(k1)=2，h2(k2)=5，h2(k3)=5。那么k1的探查序列为：30,32,34,36等；k2的探查序列为：28,33,38,43等；k3的探查序列为：30,35,40,45等。这样关键码之间就不会共享同一段探查序列了。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"事件绑定 事件监听 事件委托","slug":"事件绑定-事件监听-事件委托","date":"2020-01-18T08:58:07.000Z","updated":"2020-02-05T12:49:30.054Z","comments":true,"path":"2020/01/18/事件绑定-事件监听-事件委托/","link":"","permalink":"http://delaprada.com/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件绑定为了让JavaScript对用户的操作作出响应，首先要对DOM元素绑定事件处理函数。 三种常用的绑定事件的方法： 在DOM元素中直接绑定 在JavaScript代码中绑定 绑定事件监听函数 在DOM元素中直接绑定我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。 123456&lt;input type=\"button\" value=\"click me\" onclick=\"hello()\"&gt;&lt;script&gt;function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 在JavaScript代码中绑定事件在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 123456&lt;input type=\"button\" value=\"click me\" id=\"btn\"&gt;&lt;script&gt;document.getElementById(\"btn\").onclick = function()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 使用事件监听绑定事件绑定事件的另一种方法是用 addEventListener() 或 attachEvent()来绑定事件监听函数。 事件监听的优点： 可以绑定多个事件 常规的事件绑定（例如onclick）只执行最后绑定的事件，会产生事件覆盖。 12345678910&lt;input type=\"button\" value=\"click me\" id=\"btn3\"&gt;&lt;script&gt;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function()&#123; alert(\"hello 1\"); //不执行&#125;btn3.onclick = function()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 使用addEventListener的话两个事件都会执行： 123456789101112&lt;input type=\"button\" value=\"click me\" id=\"btn4\"&gt;&lt;script&gt;var btn4 = document.getElementById(\"btn4\");btn4.addEventListener(\"click\",hello1);btn4.addEventListener(\"click\",hello2);function hello1()&#123; alert(\"hello 1\"); //执行&#125;function hello2()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 关于事件监听，有3个事件阶段（事件流包括三个状态）：捕获阶段，目标阶段，冒泡阶段。这三个阶段也叫作事件流。 事件捕获当一个事件触发后，从window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点，都会触发对应事件。 事件冒泡当事件到达目标节点后，会沿着捕获阶段路线原路返回。同样，所有经过的节点，都会触发对应的事件。 通过栗子来理解两个事件机制： 假设有body和body节点下的div1均有绑定了一个点击事件。 效果： 当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件 当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件（默认是false，在事件冒泡阶段执行） useCapture：用于指定事件是否在捕获或冒泡阶段执行 12345678910111213141516171819//当useCapture为默认false时,为事件冒泡&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印div1 打印body 1234567891011121314151617//当useCapture为true时,为事件捕获&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;,true) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印body 打印div1 事件委托利用冒泡原理，把事件加到父元素或祖先元素上，触发执行效果。 12345678910111213141516171819202122&lt;script&gt; window.onload = function()&#123; let div = document.getElementById('div'); div.addEventListener('click',function(e)&#123; console.log(e.target) &#125;) let div3 = document.createElement('div'); div3.setAttribute('class','div3') div3.innerHTML = 'div3'; div.appendChild(div3) &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=\"div\"&gt; &lt;div class=\"div1\"&gt;div1&lt;/div&gt; &lt;div class=\"div2\"&gt;div2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 虽然没有给div1和div2添加点击事件，但是无论是点击div1还是div2都会打印当前节点（console.log(e.target)）。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。 举个栗子： 分别点击div1、div2、div3： 无论后代新增了多少个节点，一样具有点击事件的功能。但是如果是传统的事件绑定的话无法对动态添加的元素而动态地添加事件。 事件委托的优点 提高性能：每一个函数都会占用内存空间。只需要添加一个事件处理程序代理所有事件，所占用的内存空间更少。 动态监听：使用事件委托可以自动绑定动态添加的元素。即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。 参考：https://www.cnblogs.com/soyxiaobi/p/9498357.html ​ http://blog.xieliqun.com/2016/08/12/event-delegate/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"分析parseInt()","slug":"分析parseInt","date":"2020-01-18T03:56:24.000Z","updated":"2020-01-18T07:05:51.564Z","comments":true,"path":"2020/01/18/分析parseInt/","link":"","permalink":"http://delaprada.com/2020/01/18/%E5%88%86%E6%9E%90parseInt/","excerpt":"","text":"parseInt()公式1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 parseInt(071)和parseInt(&quot;071&quot;)的区别parseInt(&quot;071&quot;)就是简单将字符串转换为数字： 如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。 以0开头也是转换为十进制。也有说转换为十六进制或者八进制，但是在chrome中实践是十进制。 parseInt(071)就是将071用八进制进行转换： 判断[‘1’,’2’,’3’].map(parseInt)的输出你可能觉得会是[1,2,3]，但实际上是[1,NaN,NaN]。我们来仔细分析一下： map的函数格式 1map((item, index, thisArr) &#x3D;&gt; ( newArr )) 参数解析： item: callback 的第一个参数，数组中正在处理的当前元素 index: callback 的第二个参数，数组中正在处理的当前元素的索引 thisArr: callback 的第三个参数，map 方法被调用的数组 parseInt的格式 上面讲到： 1parseInt(string, radix) 通过上述对 map 和 parseInt 函数的分析可以知道，执行方法时，map给parseInt传递了三个参数: 1parseInt(item, index, thisArr) 因此，索引index会传入parseInt函数当做基数radix。 其中第三个参数会被 parseInt 忽略，因此会依次执行： 123456parseInt('1', 0)// radix 为 0，默认以十进制解析字符串，返回 1parseInt('2', 1)// radix 为 1，不在 2 ~ 36 之间，返回 NaNparseInt('3', 2)// radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN 参考：https://www.cnblogs.com/wx1993/p/8417817.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2020-01-17T02:31:56.000Z","updated":"2020-01-17T02:35:23.204Z","comments":true,"path":"2020/01/17/防抖与节流/","link":"","permalink":"http://delaprada.com/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖和节流如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖（debounce）和节流（throttle）的方式来减少调用频率，同时又不影响实际效果。 防抖含义：当持续触发事件时，一定时间段内没有在触发事件，事件处理函数才会执行一次；如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 代码实现： 123456789101112131415function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 防抖是通过闭包实现的，所以timeout是会被缓存的。如果在频繁触发事件之后的一段时间内，又再次触发了事件，那就会使用clearTimeout清除setTimout设置的timout，重新计时。 具体完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125; &#125; // 处理函数 function handle() &#123; console.log(Math.random()); &#125; // 滚动事件 window.addEventListener('scroll', debounce(handle, 1000)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;防抖演示1&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示2&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示3&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示4&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示5&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示6&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示7&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示8&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示9&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示10&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示11&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示12&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示13&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示14&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示15&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示16&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在网页运行的时候我们会看到，当在滚动页面操作停止后1s，控制台会有输出。这就是防抖。 节流当持续触发事件时，保证每隔一定时间段内只调用一次事件处理函数。 用定时器实现节流： 1234567891011121314151617var throttle=function(func,delay)&#123; var timer=null; return function()&#123; var context=this; var args=arguments; if(!timer)&#123; timer=setTimeout(function()&#123; func.apply(context,args); timer=null; &#125;,delay); &#125; &#125;&#125;function handle()&#123; console.log(Math.random());&#125;window.addEventListener('scroll',throttle(handle,1000)); 节流也是通过闭包实现的。所以会把timer缓存起来，但是由于每次执行setTimeout函数时都设置timer为null，所以每次调用都可以执行if语句当中的内容。同时，下一次滚动事件不会影响上一次的事件处理函数，所以不会重新计时。 将节流代码放入上个例子的具体实现中会发现，执行滚动页面操作后，都会以同一频率在控制台中输出值。 参考：https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"https SSL/TLS握手过程","slug":"https-SSL-TLS握手过程","date":"2020-01-16T13:00:04.000Z","updated":"2020-01-16T13:05:07.058Z","comments":true,"path":"2020/01/16/https-SSL-TLS握手过程/","link":"","permalink":"http://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/","excerpt":"","text":"SSL/TLS 握手过程详解http协议是明文传输，不确认通信方，不保证传输数据完整的协议。它带来了三大风险： （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。 （2） 篡改风险（tampering）：第三方可以修改通信内容。 （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 http协议是明文传输，在安全性方面比较差。https协议使用了SSL/TLS协议来进行加密。SSL/TLS握手是为了安全地协商出一份对称加密的秘钥。 SSL/TLS握手过程 Client Hello 握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。 Server Hello 第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。 注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Hello Done Server Hello Done通知客户端Server Hello过程结束。 Certificate Verify 客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。 https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的 Client Key Exchange 上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。 至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。 为什么要使用三个随机数？ 这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。 最重要理解前六步 Change Cipher Spec（Client） 这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。 Encrypted Handshake Message(Client) 这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。 Change Cipher Spec(Server) 这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server) 这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data 到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html ​ https://juejin.im/post/584b76d3a22b9d0058d5036f","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CSS 圣杯布局和双飞翼布局","slug":"CSS-圣杯布局和双飞翼布局","date":"2020-01-15T08:49:17.000Z","updated":"2020-01-15T12:46:08.385Z","comments":true,"path":"2020/01/15/CSS-圣杯布局和双飞翼布局/","link":"","permalink":"http://delaprada.com/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"CSS 圣杯布局和双飞翼布局两个常见的前端布局。圣杯布局和双飞翼布局作为经典的三栏式布局是面试中的常客。两种布局达到效果上基本相同，都是两边两栏宽度固定，中间栏宽度自适应。在HTML结构上中间栏在最前面保证了最先渲染中间提升性能（因为这两种布局都比较老，我认为在现代浏览器中这点儿性能优化效果并不是很大），并且兼容性良好。两种布局的实现方法前半部分相同，后半部分的实现各有利弊，下面会简单介绍两者的区别。 圣杯布局代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; background-color: skyblue; height:60px; line-height:60px; /*文字水平垂直居中*/ &#125; .container&#123; overflow:hidden; /*因为内部都是浮动元素，所以要设置overflow来撑起父元素*/ padding:0 100px; /*左右内边距为100px*/ &#125; .main&#123; width:100%; background-color: peachpuff; height:100px; line-height: 100px; float:left; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; float:left; margin-left:-100%; /*让left前移一行*/ position:relative; left:-100px; &#125; .right&#123; background-color: pink; width:100px; height:100px; line-height:100px; float:left; margin-left:-100px; /*right只需要前移right的宽度即可*/ position:relative; /*container设置了padding,所以要相对定位移动才能将left和right移动到对应的位置*/ right:-100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 设置父元素container为overflow:hidden，撑起父元素，子元素main、left、right均设为float:left，浮动起来。效果如下： 为了让main模块自适应，将其设为100% 为了让left和right模块跑上去，设置left模块的margin:-100%，可以理解为：负的话就是向上前进，正值的话就是直接的间隔；right模块就设置为margin:-100px，大小为right模块的宽度 为了使main模块往里收，设置.container{ padding: 0 100px}，即设置左右内边距。 利用相对定位移动left和right 双飞翼布局代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; height:60px; background-color: skyblue; line-height:60px; &#125; .container&#123; overflow:hidden; &#125; .main&#123; width:100%; height:100px; line-height:100px; float:left; background-color: peachpuff; &#125; .inner-main&#123; margin-left:100px; /*通过在main内部再设置一个div来进行左右模块的间隔布局*/ margin-right:100px; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; margin-left:-100%; float:left; &#125; .right&#123; background-color: yellow; width:100px; height:100px; line-height:100px; margin-left:-100px; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"inner-main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算。 圣杯布局和双飞翼布局的主要区别： 圣杯布局是设置container的padding属性以及left和right模块的position:relative，left:-100px或right:-100px 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算 参考：https://segmentfault.com/a/1190000004579886","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"JavaScript模块化编程","slug":"JavaScript模块化编程","date":"2020-01-14T15:10:50.000Z","updated":"2020-01-14T15:11:30.414Z","comments":true,"path":"2020/01/14/JavaScript模块化编程/","link":"","permalink":"http://delaprada.com/2020/01/14/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/","excerpt":"","text":"模块化编程目录： AMD CMD commom.js ES6 Module AMDAMD是依赖前置，提前执行。AMD一开始是CommonJS规范中的一个草案，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。 AMD的基本语法通过define来定义一个模块，使用require可以导入定义的模块。 用define定义无依赖的模块： 12345//a.js//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数define(function()&#123; return 1;&#125;) 用define定义有依赖的模块： 1234567define([\"alpha\"], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 用require进行模块加载： 123require(['math'], function(math) &#123; math.add(2, 3);&#125;); AMD的特点对于依赖的模块，AMD推崇依赖前置，提前执行。也就是定义模块和加载模块都要在一开始就把依赖写好。例如define函数当中的[&quot;alpha&quot;]，就是定义模块当中的依赖；require函数当中的[&quot;math&quot;]是加载模块当中的依赖。 CMDCMD是依赖就近，延迟执行。 1234567891011121314151617181920212223//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;); //CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); CMD是在用到了某个模块的时候再去require，类似按需加载。 CMD的特点对于依赖的模块，CMD推崇依赖就近，延迟执行。也就是说，只有到require时依赖模块才执行。 摘自：https://segmentfault.com/a/1190000004873947 CommonJS基本用法 通过module.exports或者exports来输出模块 通过require来导入模块 1234567891011121314151617181920//a.jsmodule.exports = function () &#123; console.log(\"hello world\")&#125;//b.jsvar a = require('./a');a();//\"hello world\"//或者//a2.jsexports.num = 1;exports.obj = &#123;xx: 2&#125;;//b2.jsvar a2 = require('./a2');console.log(a2);//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125; CommonJS的特点 所有代码都运行在模块作用域，不会污染全局作用域 模块都是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果。如果想要再次执行，可清楚缓存 require返回的值是被输出的值的拷贝，模块内部的变化不会影响这个值 ES6 Module基本用法： export或export default来输出模块 import来导入模块 （export default就是能够为导入的模块自定义名称，这样就不用知道模块在原本的js文件当中的名字，按名字导入了） 1234567891011//a.jsvar name = 'lin';var age = 13;var job = 'ninja';export &#123; name, age, job&#125;;//b.jsimport &#123; name, age, job&#125; from './a.js';console.log(name, age, job);// lin 13 ninja 12345678//a2.jsexport default function () &#123; console.log('default ');&#125;//b2.jsimport customName from './a2.js';customName(); // 'default' ES6 Module的特点（对比CommonJS） CommonJS模块是运行时加载，ES6 Module是编译时输出接口； CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口（对应名字单独加载，加载这个模块想=需要的）； CommonJS输出是值的拷贝，ES6 Module输出的是值的引用，被输出模块的内部的改变会影响引用的改变； CommonJS this指向当前模块，ES6 Module this指向undefined; 参考：https://juejin.im/post/5db95e3a6fb9a020704bcd8d","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Generator函数 async函数","slug":"Generator函数-async函数","date":"2020-01-14T12:43:59.000Z","updated":"2020-03-03T09:16:42.620Z","comments":true,"path":"2020/01/14/Generator函数-async函数/","link":"","permalink":"http://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/","excerpt":"","text":"Generator重要概念： Generator 函数是 ES6 提供的一种异步编程解决方案 执行Generator函数会返回一个遍历器对象 形式上Generator函数是一个普通函数，有两个特征：1）function关键字与函数名之间有个星号； 2）函数内部使用yield表达式，定义不同的内部状态 调用Generator函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象 必须调用遍历器对象的next方法，使得指针移向下一个状态，输出返回的结果 next方法返回的是一个对象。它的value属性就是当前yield表达式的值hello，done属性的值false则表示遍历还没有结束（即没有遇到return）。 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 另一个栗子： 1234function* gen(x)&#123; const y = yield x + 6; return y;&#125; 普通执行： 12345678const g = gen(1);//执行 Generator 会返回一个Object,而不是像普通函数返回return 后面的值g.next() // &#123; value: 7, done: false &#125;//调用指针的 next 方法,会从函数的头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式或return语句暂停,也就是执行yield 这一行// 执行完成会返回一个 Object,// value 就是执行 yield 后面的值,done 表示函数是否执行完毕g.next() // &#123; value: undefined, done: true &#125;// 因为最后一行 return y 被执行完成,所以done 为 true next方法传参数： 1234const g = gen(1);g.next() // &#123; value: 7, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; // next 的参数是作为上个阶段异步任务的返回结果 异步应用因为yield能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序。 例如有两个异步的函数 A 和 B, 并且 B 的参数是 A 的返回值，也就是说，如果 A 没有执行结束，我们不能执行 B。 那这时候我们写一段伪代码： 12345function* effect() &#123; const &#123; param &#125; = yield A(); const &#123; result &#125; = yield B(param); console.table(result);&#125; 这时候我们如果需要得到 result 那么我们就需要: 123const iterator = effect()iterator.next()iterator.next() co库可以用来每次执行A()/b()的请求结束之后，都会自动执行next()方法。 async和awaitasync函数就是Generator的语法糖。 形式上的不同： async函数将Generator函数的星号（*）替换成async 将yield替换成await async函数对Generator函数的改进体现在以下4点： 内置执行器 也就是说async函数的执行，和普通函数一样，只需要一行就可以。不用像Generator函数需要调用next方法才能真正执行。 例如对于一个async函数来说： 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 调用时只需要： 1asyncReadFile(); 更好的语义 async和await比起星号和yield，语义更加清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 返回值是Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 async函数基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 先执行了第一个await后的getStockSymbol(name)函数；得到了股票的名称symbol后，将symbol传给第二个await后面的getStockPrice(symbol)作为参数；最后返回股票价格stockPrice。 执行顺序问题1234567891011121314async function async1()&#123; console.log('async1 start'); await async2(); console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start');async1();console.log('script end')// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end 当async函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了async函数体。 1234567891011121314151617181920async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 执行顺序为： 执行async1的时候遇到await先去执行async2，然后跳出了函数体，去执行后续的代码，然后再回到当前async1函数当中执行await后续语句。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"函数柯里化","slug":"函数柯里化","date":"2020-01-14T06:27:55.000Z","updated":"2020-02-18T07:59:41.485Z","comments":true,"path":"2020/01/14/函数柯里化/","link":"","permalink":"http://delaprada.com/2020/01/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"函数柯里化柯里化的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 看一个栗子： 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 我们定义了一个add函数，它接受一个参数并返回一个新的函数。调用了add之后，返回的函数就通过闭包的方式记住了add的第一个参数。 因为一次性地调用它有点繁琐，所以使用一个特殊的curry帮助函数使得这类函数的定义和调用更加容易。 一些柯里函数实例： 12345var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;); 12345match(/\\s+/g, \"hello world\");// [ ' ' ]match(/\\s+/g)(\"hello world\");// [ ' ' ] 以上两种方法都可以执行。第二种方法是比较常见的柯里化方法。先传递一部分参数（题目中为正则表达式）来调用函数，然后返回一个函数（题目中为str.match()来处理剩下的函数）。（题目中是匹配空格） 以上的形式可以更加具体化： 12345var hasSpaces = match(/\\s+/g);// function(x) &#123; return x.match(/\\s+/g) &#125;hasSpaces(\"hello world\");// [ ' ' ] 这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 再举一个非常常见的例子： 如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入： 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下： 12check(/^1[34578]\\d&#123;9&#125;$/, '14900000088');check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, 'test@163.com'); 这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用： 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\\d&#123;9&#125;$/);var checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了： 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 再看一个前端面试中常考的题目： 1如何实现add(2)(3)(4) &#x3D; 9 函数柯里化解决这个问题： 12345678910111213141516171819let myAdd = (a, b, c) =&gt; a+b+c;function curry(fn, args)&#123; let len = fn.length; let _this = this; let _args = args || []; return function()&#123; let args = Array.prototype.slice.apply(arguments); args = Array.prototype.concat.call(_args, args); // 当接收到的参数小于fn所需参数个数时，继续接收参数 if(args.length &lt; len)&#123; return curry.call(_this, fn, args); &#125; return fn.apply(this, args); &#125;&#125;let add = curry(myAdd);console.log(add(2)(3)(4)); // 9console.loh(add(2,3)(4)); // 9console.log(add(2,3,4)); // 9 但是这个例子不具有普遍性。如果传入的参数不是3个的话不能这么用。 所以有了下面的进化之后的代码： 1234567891011121314151617181920212223function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() &#123; _args.push(...arguments); return _adder; &#125;; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder;&#125;add(1)(2)(3).toString() // 6add(1, 2, 3)(4).toString() // 10add(1)(2)(3)(4)(5).toString() // 15add(2, 6)(1).toString() // 9 参考的博客说隐式转换的原因是因为函数进行计算的时候会变为字符串，但理解了代码之后觉得并不是这么回事。每次调用函数的时候执行的是这个语句体： 1234var _adder = function() &#123; _args.push(...arguments); return _adder;&#125;; 这个语句体实际上是用于将所有传入的实参放进数组args中。最后执行toString方法的时候是将数组args的每个元素通过reduce函数求和，返回求和的值。单纯执行_adder函数和执行toString()函数做的事情是不一样的。 看到一个面试题目： 实现一个sum函数使得sum(1, 2, 3).valueOf()和sum(1)(2)(3).valueOf()执行输出的结果都等于6 。 解法和上面一致，只需要把toString()改为valueOf()就可以了。 1234567891011121314151617var sum=function()&#123; var args=[].slice.call(arguments); var _adder=function()&#123; args.push(...arguments); return _adder; &#125; _adder.valueOf=function()&#123; return args.reduce(function(a,b)&#123; return a+b; &#125;); &#125; return _adder;&#125;console.log(sum(1,2,3).valueOf());console.log(sum(1)(2)(3).valueOf()); 为什么要进行隐式转化？ 因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果： 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果： 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 参考博客： https://www.jianshu.com/p/5e1899fe7d6b https://www.cnblogs.com/hmchen/p/11564394.html https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript this解析","slug":"JavaScript-this全面解析","date":"2020-01-13T03:12:48.000Z","updated":"2020-03-03T09:02:19.664Z","comments":true,"path":"2020/01/13/JavaScript-this全面解析/","link":"","permalink":"http://delaprada.com/2020/01/13/JavaScript-this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","excerpt":"","text":"为什么要使用thisthis提供了一种更优雅的方式来隐式“传递”一个对象引用。 看下面的例子： 没有使用this的情况下： 1234567891011121314151617var me=&#123; name:\"Kyle\"&#125;var you=&#123; name:\"Reader\"&#125;function identify(context)&#123; return context.name.toUpperCase();&#125;function speak(context)&#123; var greeting=\"Hello, I'm \"+identify(context); console.log(greeting);&#125;identify(you); //READERspeak(me); //hello, I'm KYLE 使用了this的情况： 123456789101112function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greeting=\"Hello, I'm \"+identify.call(this); console.log(greeting);&#125;identify.call(me); //KYLEidentify.call(you); //READERspeak.call(me); //Hello, I'm KYLEspeak.call(you); //Hello, I'm READER 表达上更加的简洁。如果不使用this的话，就需要给identify()和speak()显式传入一个上下文对象。 this绑定对象的规则我们可以顺序应用下面四条规则来判断this的绑定对象： 如果是由new调用，绑定到新创建的对象。 如果是由call或者apply、bind调用，绑定到指定的对象上。 如果是由上下文对象调用（即this是对象中的方法里使用的），绑定到那个上下文对象上。 如果是默认情况下，严格模式绑定到undefined，否则绑定到全局对象上。 但是ES6中的箭头函数并不会使用者四条标准的绑定规则。箭头函数会继承外层函数调用的this绑定。 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar=new foo(2);console.log(bar.a); //2 我们使用new来调用foo(…)时，会构造一个新对象并把它绑定到foo(…)调用中的this上。 显式绑定call、apply、bind1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2;&#125;;foo.call(obj); //2 call用来将函数foo中的this绑定到obj上。 隐式绑定（上下文对象调用）如果this所在的函数是对象中的方法的话，this就会指向这个对象。 12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;obj.foo(); //2 foo此时是obj对象的一个方法，所以this就会指向obj。 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用： 123456789101112function foo()&#123; console.log(this.a);&#125;var obj2=&#123; a:42, foo:foo&#125;;var obj1=&#123; a:2, obj2:obj2&#125;;obj1.obj2.foo(); //42 隐式丢失也是this隐式绑定中常见的问题： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;var bar=obj.foo; //函数别名！var a=\"oops, global\"; //a是全局对象的属性bar(); //“oops, global” 此时bar是obj.foo的一个引用，但实际上它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 回调函数丢失this绑定是也是非常常见的问题： 123456789101112function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn(); //调用位置&#125;var obj=&#123; a:2, foo:foo&#125;;var a=\"oops global\"; //全局对象属性doFoo(obj.foo); //\"oops global\" 函数doFoo传入了函数作为参数，并在doFoo中调用。我们可以把它看做将函数copy到了doFoo函数体中，调用的时候this指向的是全局作用域。 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); //2 在这个例子中，函数调用应用了this的默认绑定，this指向全局对象。 如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，this会绑定到undefined。 123456function foo()&#123; \"use strict\"; console.log(this.a);&#125;var a=2;foo(); //TypeError: this is undefined 箭头函数中的this箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。 12345678910111213function foo()&#123; return (a)=&gt;&#123; console.log(this.a); &#125;&#125;var obj1=&#123; a:2&#125;;var obj2=&#123; a:3&#125;;var bar=foo.call(obj1);bar.call(obj2); //2,不是3！ foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，所以bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。 再看一个例子： 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 foo调用时传入的是什么对象，this就指向谁。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21（严格模式则输出undefined）。 如果foo函数内部是普通函数的话： 由此可以看出，foo函数的this是指向call传入的对象{id:42}，但是foo函数内部的setTimeout函数中的this是指向全局的。 参考书籍：《你不知道的JavaScript》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript基本知识","slug":"JavaScript基本知识","date":"2019-12-30T02:14:24.000Z","updated":"2019-12-30T02:30:31.762Z","comments":true,"path":"2019/12/30/JavaScript基本知识/","link":"","permalink":"http://delaprada.com/2019/12/30/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScriptES6和JavaScript的关系ES6的全称为ECMAScript 6.0，是JavaScript语言下一代的标准，是使得JavaScript可以用来编写复杂的大型应用程序，称为企业级开发语言。ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript前言JavaScript是世界上最流行的脚本语言，是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 JavaScript引入 用直接包含js代码 把js代码放到一个单独的.js文件，在html中通过引入这个文件，这么做更有利于代码维护 JavaScript基本语法 JavaScript的语法和Java类似，每个语句以；结束 JavaScript严格区分大小写 JavaScript的数据类型基本数据类型：Number, String, Boolean, null, undefined, Symbol（ES6中新添加的类型，一种实例是唯一且不可改变的数据类型） NumberJavaScript不区分整数和浮点数，统一用Number表示。可以表示 整数 浮点数 科学计数法 负数 NaN（表示Not a Number，当无法计算结果时用NaN表示） Infinity（表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity） String字符串是以单引号或双引号括起来的文本。 模板字符串要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!';alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串获取字符串长度： 12var s = 'Hello, world!';s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' 字符串常用方法：注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： toUpperCase： toUpperCase()把一个字符串全部变为大写： 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' toLowerCase： toLowerCase()把一个字符串全部变为小写： 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' substring: substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' Booleantrue或者false 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值，要特别注意比较运算符==和===： ==比较：它会自动转换数据类型再比较，很多时候会得到很奇怪的结果 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN===NaN //false 唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN) //true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true null和undefined null表示一个“空”的值、表示“无”的对象，转为数值是为0；undefined是一个表示“无”的原始值，转为数值是NaN，当声明的变量还未被初始化时，变量的默认值为undefined。 Null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 Undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义，典型用法是： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值属性，该属性的值为undefined 函数没有返回值时，默认返回undefined null表示”没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象 作为对象原型链的终点 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： 1[1, 2, 3.14, &#39;Hello&#39;, null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过Array()函数实现： 1new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即truearr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined 要取得Array的长度，直接访问length属性： 12var arr = [1, 2, 3.14, 'Hello', null, true];arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： 123var arr = ['A', 'B', 'C'];arr[1] = 99;arr; // arr现在变为['A', 99, 'C'] (注意此处与String的不同，String是不可变的) 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串&#39;30&#39;是不同的元素。 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 对象JavaScript的对象是一组由键-值组成的无序集合，用一个{...}表示一个对象，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为&#39;Bob&#39;，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用&#39;&#39;括起来： 1234var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School'&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用&#39;&#39;括起来。访问这个属性也无法使用.操作符，必须用[&#39;xxx&#39;]来访问： 123xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红' 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： 1234567891011var xiaoming = &#123; name: '小明'&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符： 12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： 1'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefinedvar $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值truevar t &#x3D; null; &#x2F;&#x2F; t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如： 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言（例如int） 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 循环for…infor循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 12345678910var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // 'name', 'age', 'city' &#125;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for ... in对Array的循环得到的是String而不是Number。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for...in和for...of的区别： for in 循环的是对象的属性（普通数组的属性就是index） for of 循环的是迭代器中的每一个元素 用for ... of循环遍历集合，用法如下： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 你可能会有疑问，for ... of循环和for ... in循环有何区别？ 当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125; for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 12345678'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身： 1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： 1234var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; console.log(element);&#125;); 参考基本数据类型和引用数据类型的区别：https://www.cnblogs.com/c2016c/articles/9328725.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"hexo常用指令及美化博客页面","slug":"hexo常用指令及美化博客页面","date":"2019-12-26T09:54:44.000Z","updated":"2020-01-15T12:46:56.095Z","comments":true,"path":"2019/12/26/hexo常用指令及美化博客页面/","link":"","permalink":"http://delaprada.com/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"hexo常用命令Hexo的命令总体来说比较简单，安装成功之后只需要记住常用的四种即可。在当前blog文件夹根目录下右键点击git bash： hexo s：server启动服务器 hexo clean：clean清除缓存文件（db.json）和已生成的静态文件（public） hexo generate或hexo g：generate生成静态文件 hexo deploy或hexo d：deploy部署网站，部署网站前需预先生成静态文件 一般更改完后执行三条指令：hexo clean，hexo generate，hexo deploy即可（按顺序） 如果要进行文件压缩，在hexo generate指令后，执行gulp指令。 参考https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/ hexo各种美化新建page1hexo new &quot;文章名称&quot; 会在source文件夹下_post中新建文件夹和.md文件 侧栏增加标签和分类页面创建标签页面 创建标签页面 1hexo new page tags 基本设置 123title: tagsdate: 2017-12-02 21:01:24type: &quot;tags&quot; 创建分类页面 创建分类页面 1hexo new page categories 基本设置 123title: categoriesdate: 2017-12-02 21:01:24type: &quot;categories&quot; 文章中插入图片 将图片放置在页面对应的文件夹中 在文章中引入： 1&#123;% asset_img 图片名称 %&#125; 设置站点图标 先在images文件夹下放入你的图标 在主题配置页面_config.yml中搜索favicon，找到以下位置，并将路径修改为你的图标： 部署之后就可以看到效果了，查看效果：http://delaprada.com 设置头像 在images文件夹中放入你的头像图片 在主题配置页面中修改avatar为你的图片地址： 首页文章不显示全文只显示摘要修改/themes/next/_config.yml主题配置文件中： 1234567scroll_to_more: true #如果文章有摘要,会自动滚动到摘要下面save_scroll: true #通过cookies来缓存阅读进度excerpt_description: true #自动摘录描述作为序言auto_excerpt: #设置阅读全文 enable: true length: 150 #摘要次数read_more_btn: true #阅读全文按钮 修改文章底部的带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;（如果想换成其他图标可到font-awesome中文网查看） 在每篇文章末尾统一添加“本文结束”标记在\\themes\\next\\layout\\_macro中新建passage-end-tag.swig，并加入以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=\"text-align:center;color: #ccc;font-size:15px;\"&gt;-------本&amp;nbsp;文&amp;nbsp; 结&amp;nbsp;束&amp;nbsp;&amp;nbsp;&lt;i class=\"fa fa-heart\" aria-hidden=\"true\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;感 &amp;nbsp;谢&amp;nbsp;您&amp;nbsp;的&amp;nbsp;阅&amp;nbsp;读-------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body标签之后，post-footer标签之前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &#39;passage-end-tag.swig&#39; %&#125; &#123;% endif %&#125;&lt;&#x2F;div&gt; 修改网页背景颜色和侧栏上方brand的颜色打开themes/next/layout/source/css/_custom/custom.styl，加入以下代码： 12345678910111213141516171819202122&#x2F;&#x2F;修改网页背景颜色body &#123; background-color: #F0F8FF&#125;#footer a &#123; color:#eee;&#125;&#x2F;&#x2F; 修改网站头部颜色.headband &#123; height: 3px; background: #ADD8E6;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #ADD8E6;&#125;.site-title &#123; color: #fff;&#125; 侧边栏社交设置和友情链接修改主题配置页面：themes/next/_config.yml： 12345678910111213141516171819202122232425262728293031site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: CSDN: https://blog.csdn.net/weixin_41973410 || copyright GitHub: https://github.com/delaprada || githubsocial_icons: #这里是上面社交链接的对应图标 enable: true CSDN: copyright Github: github icons_only: false transition: true# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.#github_banner: https://github.com/Fitz1318 || Follow me on GitHub# Blog rolls #这里时设置一些相关链接 我这里设置了一些推荐阅读的网站#links_icon: linklinks_title: 实用网站#links_layout: blocklinks_layout: inlinelinks: W3Cschool: http://www.w3school.com.cn/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"hexo categories和tags页面不显示解决办法","slug":"hexo-categories和tags页面不显示解决办法","date":"2019-12-25T02:53:13.000Z","updated":"2019-12-26T09:55:44.357Z","comments":true,"path":"2019/12/25/hexo-categories和tags页面不显示解决办法/","link":"","permalink":"http://delaprada.com/2019/12/25/hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"官网也有给出具体步骤，但是有坑Hexo官网教程 第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ：12cd hexo //根目录hexo new page categories //tags和这个操作一致 第二步 找到新建的页面，添加type新建的页面一般在source/categories/index.md中，添加以下内容： 1234title: categoriesdate: 2019-12-25 09:15:45type: \"categories\"layout: \"categories\" 第三步 给你的页面添加分类找到你的页面，在页面上方添加如下内容 123456title: 利用gitpages+hexo搭建自己的博客date: 2019-12-25 09:12:55categories:- Hexotags:- 前端 但此时部署到github上后，打开网页点击分类和标签页面还是出现404！ 第四步 解决方案实属官方坑人系列！！主题配置文件_config.yml中的menu：把 / 后面的空格全部去掉（刚开始的时候默认后面是加了空格导致点击页面出现404）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"利用gitpages+hexo搭建自己的博客","slug":"利用gitpages+hexo搭建自己的博客","date":"2019-12-25T01:12:55.000Z","updated":"2020-01-15T12:50:57.057Z","comments":true,"path":"2019/12/25/利用gitpages+hexo搭建自己的博客/","link":"","permalink":"http://delaprada.com/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言从开始开始着手搭建到完成大概花了一个下午的时间，采坑不少，在此记录一下 第一步 准备工作node.js下载好，github有已注册的账号在github中新建一个repository，命名为：你的github名称.github.io（下面是我的仓库名称）： （有些博客直接让我们fork它们的项目，个人感觉这么做不太好，很多东西自己动手做一遍更好） 第二步 安装HexoHexo就是一个博客框架，官网上也有安装教程Hexo官网 step1：windows系统鼠标右键git bash，输入两个安装指令： 12npm install hexo-cli -g &#x2F;&#x2F;用于安装hexonpm install hexo-deployer-git --save &#x2F;&#x2F;用于安装hexo部署到git page的deployer step2：创建hexo文件夹hexo安装完成之后，在电脑中新建一个hexo文件夹： 右键点击git bash，输入两个命令： 12hexo initnpm install &#x2F;&#x2F;安装所有package.json里的包 执行完成后，hexo文件夹中会多出一些文件： 如果想看本地效果的话，执行以下指令： 12hexo generate &#x2F;&#x2F;自动将md文件生成静态html，css文件hexo server &#x2F;&#x2F;启动本地hexo服务器（localhost:4000） 打开 localhost:4000就可以看到页面啦： （页面会不太一样，我的配了一下主题） 第三步 了解hexo文件夹中的_config.ymlhexo文件夹中比较重要的文件是：_config.yml： 它是一个全局配置文件，包括和github上传链接都在这里配置，例如title之类的： 第四步 本地上传到githubstep1：执行命令，安装deploy.git插件 1npm install hexo-deployer-git --save step2：在主题配置文件_config.yml中修改仓库地址，在_config.yml最下面一行（注意每个冒号后面都有一个空格） step3：配置提交github认证方式执行指令： 1hexo d 直接提交到github仓库中，如果没有认证github和本地的关系，会提示输入用户名和密码 此时打开github的项目会发现原本是空的项目现在有了刚刚上传的文件 第五步 添加域名在阿里云中购买了一个.com的域名（加优惠一年23块，虽然比其他贵一些但是觉得.com好听一些(#^ . ^#)） step1：cmd ping一下github.io获得真实ip地址 step2：然后再域名操作栏点击解析，添加记录 注意要两个都要添加（之前一开始只添加了www不知道为啥就显示不出来） step3：去hexo文件夹的source目录下新建名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www step4：然后部署 1231. hexo clean2. hexo generate3. hexo deploy （每次做出更改建议都部署一遍） step5：点击设置，拉到下面，在custom domain中输入你的域名。如果上面的信息不是显示Your site is published at https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证 输入域名，成功：","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]}]}