{"meta":{"title":"Alice's  wonderland","subtitle":"","description":"Goals determine what you going to be!","author":"Alice","url":"http://delaprada.com","root":"/"},"pages":[{"title":"","date":"2021-01-07T12:46:27.000Z","updated":"2021-01-08T06:14:51.069Z","comments":false,"path":"about/index.html","permalink":"http://delaprada.com/about/index.html","excerpt":"","text":"关于我Major Software Engineering SCUT🏡 Interest 读书 弹琴 coffee &amp; bread"},{"title":"categories","date":"2019-12-25T01:15:45.000Z","updated":"2019-12-26T12:39:38.305Z","comments":false,"path":"categories/index.html","permalink":"http://delaprada.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-25T01:50:31.000Z","updated":"2019-12-26T12:39:54.263Z","comments":false,"path":"tags/index.html","permalink":"http://delaprada.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序录音功能实现","slug":"小程序录音功能实现","date":"2021-03-07T02:01:15.000Z","updated":"2021-03-07T02:02:28.852Z","comments":true,"path":"2021/03/07/小程序录音功能实现/","link":"","permalink":"http://delaprada.com/2021/03/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BD%95%E9%9F%B3%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"前言在开发小程序过程中，有一个实现录音功能并播放录音，将录音上传至服务器的需求。开发过程中使用了Taro框架，录音功能通过Taro.getRecorderManager()接口实现，上传录音至服务器通过Taro.uploadFile接口实现，播放录音使用Taro.createInnerAudioContext()接口实现。下面就详细介绍整个流程是如何实现的。 小程序录音首先获取录音管理器模块： 1const recorderManager = Taro.getRecorderManager(); 在组件挂载完毕时注册录音监听事件： 1234567891011121314151617181920212223242526272829303132333435useEffect(() =&gt; &#123; // 监听录音开始 recorderManager.onStart(() =&gt; &#123; console.log('开始录音'); &#125;); // 监听录音暂停 recorderManager.onPause(() =&gt; &#123; console.log('暂停录音'); &#125;); // 监听录音继续 recorderManager.onResume(() =&gt; &#123; console.log('继续录音'); &#125;); // 监听录音停止 recorderManager.onStop((res) =&gt; &#123; if (res.duration &lt; 1000) &#123; Taro.showToast(&#123; title: '录音时间太短', duration: 1000, icon: 'none', &#125;); &#125; else &#123; console.log('停止录音'); fileUpload(res.tempFilePath); &#125; &#125;); recorderManager.onError(() =&gt; &#123; Taro.showToast(&#123; title: '录音失败！', duration: 1000, icon: 'none', &#125;); &#125;); &#125;, []); 在录音onStop的回调函数中，我们可以获取到录音的临时地址res.tempFilePath，但这个地址是有有效期限的，所以我们需要将这个录音上传至服务器后台，进行保存，后续才能正常使用。 onStop回调函数中我们调用了fileUpload函数实现文件上传，fileUpload函数的实现如下： 1234567891011121314151617181920212223242526const fileUpload = (tempFilePath) =&gt; &#123; Taro.uploadFile(&#123; url: 'http://127.0.0.1:7001/record', // 服务器地址 filePath: tempFilePath, name: 'file', // 这个随便填 header: &#123; 'content-type': 'multipart/form-data', // 格式必须是这个 Authorization: Taro.getStorageSync('token'), &#125;, // formData用于传输除文件以外的一些信息 formData: &#123; record_name: '朗诵作品', poem_id: poemInfo.id, category: poemInfo.category, &#125;, success: (res) =&gt; &#123; console.log(res); const url = res.data; playAudio(url); // 播放录音 &#125;, fail: (error) =&gt; &#123; console.log('failed!'); console.error(error); &#125;, &#125;); &#125;; 需要注意的点是：header中的content-type必须是multipart/form-data。 录音事件的处理第一次点击handleClick就会触发开始录音，之后会通过当前状态判断是暂停录音还是继续录音。handleComplete用于停止录音。 12345678910111213141516171819202122232425262728293031323334const handleClick = () =&gt; &#123; const curPause = pause; setPause(!curPause); if (firstRecord) &#123; setfirstRecord(false); recorderManager.start(&#123; duration: 60000, sampleRate: 44100, numberOfChannels: 1, encodeBitRate: 192000, format: 'mp3', frameSize: 50, &#125;); Taro.showToast(&#123; title: '开始录音', duration: 1000, icon: 'none', &#125;); &#125; else &#123; if (curPause) &#123; recorderManager.pause(); // 暂停录音 &#125; else &#123; recorderManager.resume(); // 继续录音 &#125; &#125; &#125;; const handleComplete = () =&gt; &#123; recorderManager.stop(); // 停止录音 &#125;; 后台实现录音存储并返回录音地址网上大多数博客都没有涉及这块内容，下面就介绍一下如何实现，后台框架我用的是阿里的egg.js。 文件上传需要配置的东西可见官方文档：egg.js文件上传。我们这里使用它的第一种File模式来实现。 因为egg.js框架内置了Multipart插件，可以解析上传的multipart/form-data类型的数据。 首先，现在配置文件config.default.js中写入multipart配置： 12345678910111213141516module.exports = (app) =&gt; &#123; const config = (exports = &#123;&#125;); ... config.multipart = &#123; mode: 'file', fileSize: '50mb', &#125; ... return &#123; ...config, ...userConfig, &#125;;&#125;; 然后，在router.js中定义路由： 12// 提交录音router.post('/record', auth, controller.record.postRecord); 在controller目录下定义record.js文件写入如下内容： 123456789101112131415const Controller = require('egg').Controller;class RecordController extends Controller &#123; async postRecord() &#123; const &#123; ctx &#125; = this; const file = ctx.request.files[0]; const &#123; record_name, poem_id, category &#125; = ctx.request.body; const res = await ctx.service.record.postRecord(file, record_name, poem_id, category); ctx.body = res; &#125;&#125;module.exports = RecordController; 在service目录下定义record.js写入具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const Service = require('egg').Service;let OSS = require('ali-oss');let aliInfo = &#123; // https://help.aliyun.com/document_detail/31837.html region: 'oss-cn-guangzhou', bucket: 'poem-mini-program', accessKeyId: 'xxx', // 填入阿里云的accessKeyId accessKeySecret: 'xxx', // 填入阿里云的accessKeySecret&#125;;let client = new OSS(aliInfo);class RecordService extends Service &#123; async postRecord(file, record_name, poem_id, category) &#123; const url = await this.uploadOSS(file); await this.updateRecord(url, record_name, poem_id, category); return url; &#125; async uploadOSS(file) &#123; const &#123; ctx &#125; = this; let result; try &#123; // 处理文件，比如上传到云端 result = await client.put(file.filename, file.filepath); &#125; finally &#123; // 需要删除临时文件 await ctx.cleanupRequestFiles(); &#125; return result.url; &#125; async updateRecord(url, record_name, poem_id, category) &#123; const &#123; ctx &#125; = this; console.log('从ctx.locals中取openid'); console.log(ctx.locals.openid); const openid = ctx.locals.openid; // 将用户信息记录到数据库中 const res = await ctx.model.Record.create(&#123; record_name: record_name, record_url: url, poem_id: poem_id, category: category, openid: openid, &#125;); &#125;&#125;module.exports = RecordService; 这里需要注意的是： 需要注册阿里云账号，并在对象存储那里新建一个存储桶用于存放音频，也就是云存储的实现。 需要安装ali-ossnpm包，用于连接阿里云对象存储。在后台接收到前端上传的临时文件后，就会将音频上传至阿里云对象存储中（client.put）。 播放录音细心的小伙伴可以注意到在使用Taro.uploadFile接口上传录音后，在success回调中调用了playAudio函数用于播放音频，接下来讲一下播放音频是如何实现的。 首先，使用Taro.createInnerAudioContext获取audio的上下文对象： 1const innerAudioText = Taro.createInnerAudioContext(); 和录音一样，在组件挂载完成时，注册监听事件： 12345678910useEffect(() =&gt; &#123; innerAudioText.onPlay(() =&gt; &#123; console.log('开始播放'); &#125;); innerAudioText.onError((e) =&gt; &#123; console.log('播放异常'); console.log(e); &#125;); &#125;, []); 在录音文件上传成功后，调用playAudio方法用于播放录音： 1234const playAudio = (url) =&gt; &#123; innerAudioText.autoplay = true; innerAudioText.src = url;&#125;; 在src被赋予值的时候，录音就会开始播放。 总结以上就是整个录音功能和录音播放功能实现的整个流程，如有疑问欢迎大家一起交流。","categories":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"云服务器部署node.js egg项目","slug":"云服务器部署node-js-egg项目","date":"2021-02-21T12:43:07.000Z","updated":"2021-02-21T12:47:15.837Z","comments":true,"path":"2021/02/21/云服务器部署node-js-egg项目/","link":"","permalink":"http://delaprada.com/2021/02/21/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2node-js-egg%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"最近在做毕业设计，用egg+mysql+sequelize+taro写一个小程序，因为没有用到微信的云开发，是自己搭建的后台，所以需要将后台项目部署到云服务器上。整个过程踩了不少坑，于是想写个流程以防忘记。 云服务器准备购买云服务器可在腾讯云购买轻量应用服务器，学生的话可以购买校园云服务器，规格是cpu1核，内存2GB，系统盘40GB，对于我的项目来说应该够用了：腾讯云校园云服务器 注册域名微信小程序官方文档中表明，服务器域名只支持https，且不能使用ip地址，所以我们需要注册域名。 域名购买完成后，需要实名认证，实名认证完成后才能进行下一步解析。 不和ip配套使用的域名是没有任何意义的，所以我们需要将域名绑定到我们需要对外提供服务的服务器ip上。因此我们点击域名的解析操作，添加解析到你之前购买的服务器的ip上： 可以到轻量云服务器控制台查看之前购买的云服务器的公网ip： 申请SSL证书上面提到，微信小程序官方规定域名必须是https，所以我们需要申请ssl证书，腾讯云可以免费申请ssl证书，证书也要添加到域名解析记录中：证书申请成功后先下载下来，以备后续使用：证书下载下来后会有多种，我们后续会使用到nginx的证书。 以上就完成好云服务器的准备工作了。 云服务器环境部署根据项目需求，我们要在云服务器上安装node、MySQL、nginx。 连接远程服务器 连接远程服务器的意义在于，我们能够在本地对远程服务器进行操作，比如文件上传、安装包。这里我们需要安装两个应用：XShell和Xftp，XShell一般用于对远程服务器进行操作，Xftp一般用于文件上传。 XShell和Xftp安装配置参考博客：新手搭建云服务器详细过程 安装好以上两个应用后就可以开始环境部署了。 环境部署以下步骤均在XShell中执行。 node安装12345678910111、下载node二进制安装包 wget https://nodejs.org/dist/v10.13.0/node-v10.13.0-linux-x64.tar.xz2、解压 tar xvf node-v10.13.0-linux-x64.tar.xz3、创建软链接，使node和npm全局有效 ln -s /root/node-v10.13.0-linux-x64/bin/node /usr/local/bin/node ln -s /root/node-v10.13.0-linux-x64/bin/npm /usr/local/bin/npm4、查看node和npm版本，如果显示版本号，说明安装成功 node -v npm -v5、软件默认安装在/root/node-v10.13.0-linux-x64/目录下 按照这个步骤node可以成功，但npm会出现问题，因此后续我改用nvm安装node。 安装nvm： 123curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash或者wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash 安装node，注意：如果你已经安装了node，不用卸载旧的，直接安装就好，nvm会替你管理版本的： 1nvm install node 此时再输入node -v和npm -v都显示对应版本，表明安装成功。 MySQL安装安装yum repo由于CentOS的yum源中没有MySQL，需要到MySQL的官网下载yum repo配置文件。执行以下命令： 1wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 然后进行repo的安装： 1rpm -ivh mysql57-community-release-el7-9.noarch.rpm 执行完成后会在/etc/yum.repos.d/目录下生成两个repo文件mysql-community.repo mysql-community-source.repo。 使用yum命令完成MySQL安装必须进入/etc/yum.repos.d/目录后再执行以下脚本。 安装命令：yum install mysql-server 启动MySQL：systemctl start mysqld 获取安装时的临时密码（在第一次登陆时就是用这个密码）：grep &#39;temporary password&#39; /var/log/mysqld.log 登陆执行mysql -u root -p指令，然后输入密码（刚刚获取的临时密码）。 登陆成功后修改密码修改密码时，MySQL会进行密码强度校验，不满足校验时会报异常： 1ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 但我们通常想设置更为简单的密码，这里需要执行以下步骤： 123set global validate_password_policy=0; set global validate_password_length=4; ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; 这样我们就将MySQL的密码改为简单的123456了。 以上就完成好MySQL的安装。 数据导入因为之前是在本地进行前后端联调，数据都存储在本地的数据库中，所以需要将本地的数据导入云服务器的数据库中。 step1：将本地数据库信息导出为.sql文件。cmd进入终端，执行以下指令： 1mysqldump -u root -p miniprogram &gt; C:\\Users\\alice\\miniprogram.sql 我的数据库名称为miniprogram，导出的.sql文件的名称也要叫miniprogram，导出到一个你可以找到的位置。 step2：在云服务器中也创建一个名字相同的数据库。在XShell中输入mysql -u root -p输入密码登录进去。新建一个和文件相同名称的数据库（输入sql语句时不要漏了分号）： 1create database miniprogram; 进入数据库： 1use miniprogram; 设置数据库编码： 1set names utf8; step3：将miniprogram.sql文件通过Xftp上传到云服务器上。我是现在root文件夹下新建user文件夹，并将.sql文件传输过去： step4：第二步已经登录数据库，此处只需执行： 1source /root/user/miniprogram.sql; 即可导入成功。 可以后续进入数据库查看是否有对应的表判断是否导入成功（指令：show databases;、use miniprogram;）。 nginx安装执行命令： 1yum -y install nginx 安装完后输入nginx -v，若显示nginx版本号则表示安装成功。 上传SSL证书在服务器新建目录: /data/release/nginx（/data文件本身存在，只需在里面新建release文件夹和nginx文件夹即可） 使用xftp将证书上传到该文件夹下： 上传后在服务器上查询： 上传完证书后就可以开始配置nginx。进入服务器的/etc/nginx/conf.d目录，新建一个weapp.conf文件，将文件拷贝到本地，打开编辑，写入如下配置： 1234567891011121314151617181920212223242526272829303132333435upstream app_weapp &#123; server localhost:7001; // 你的项目服务端启动的地址 keepalive 8;&#125; server &#123; listen 80; server_name www.miniprogram.ltd; // 你的域名 rewrite ^(.*)$ https://$server_name$1 permanent;&#125; server &#123; listen 443; server_name www.miniprogram.ltd; // 你的域名 ssl on; ssl_certificate /data/release/nginx/1_miniprogram.ltd_bundle.crt; //你的证书 ssl_certificate_key /data/release/nginx/2_miniprogram.ltd.key; // 你的证书 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA; ssl_session_cache shared:SSL:50m; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://app_weapp; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &#125;&#125; nginx配置的upstream主要是实现负载均衡的效果。简单来说就是：upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。所以实际上你向域名发起请求，是会被转发到云服务器的后端服务器上的。详情可参考博客：nginx使用upstream实现负载均衡。 修改好后将该文件上传至/etc/nginx/conf.d目录下，然后再XShell中输入nginx -t，如显示以下信息，则配置成功： 配置成功后，输入nginx回车，即可启动nginx。此时通过配置的域名访问服务器（http://www.miniprogram.ltd），会显示Nginx详情页。 如果访问 http://你的域名/weapp/a 会自动跳转到 HTTPS 上，并显示 502 Bad Gateway，则表示配置成功： 如果上传的weapp.conf文件发生了修改，需要重启nginx：nginx -s reload。 如果出现nginx: [emerg] bind() to [::]:80 failed (98: Address already in use)的报错，可以执行netstat -ntpl指令查看进程，将占用80端口的进程kill掉，或执行fuser -n tcp 80直接查看占用80端口的进程有哪些，依次kill掉即可。 至此云服务器的环境已经完全搭建好了。 将服务端项目上传至云服务器在服务器端创建目录/data/release/weapp（和上面存放nginx证书同目录），将服务端代码通过xftp传输到云服务器上（记得不要传node_modules）： 注意服务端数据库项目的配置部分，项目中用到sequelize构建数据库，需将配置的用户名和密码改为云服务器端MySQL的用户名和密码： 上传完后，执行以下指令将npm源切换到淘宝镜像： 1npm config set registry https://registry.npm.taobao.org 安装全局依赖： 1npm install --production 启动服务端： 1npm start 服务端项目启动成功。 云服务器防火墙开放7001端口此步骤很关键，否则无法访问服务端接口。在腾讯云轻量云服务器防火墙处添加规则，开放7001端口： 因为目前域名还未备案成功，所以不能通过域名进行访问。此时只需启动mysql和服务端项目，不需要启动nginx来测试服务端接口：到此为止完成整个后端的服务器部署，后续域名备案成功后会再更新文章。","categories":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"数据库学习及探索之旅","slug":"数据库学习及探索之旅","date":"2021-02-02T11:51:48.000Z","updated":"2021-02-03T06:42:00.860Z","comments":true,"path":"2021/02/02/数据库学习及探索之旅/","link":"","permalink":"http://delaprada.com/2021/02/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/","excerpt":"","text":"前言作为一名开发人员，不可避免会接触到数据库。虽然大二的时候有学过数据库这门课，但终究是“纸上得来终觉浅”，没有在实际项目中运用，一切都只是“空中楼阁”。趁这次做毕设，有机会比较系统地梳理数据库相关的知识，为自己的项目设计数据库，也是一次收获颇丰的经历。 什么是数据库系统数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的 大量数据的集合。 数据库系统的主要目标，是给用户提供一种便捷高效的方式去存储和获取信息。 关系型数据库和非关系型数据库关系型数据库和非关系型数据库在使用场景上差别比较大，所以并不存在孰强孰弱，只有结合自身的业务特点才能发挥出这两类数据库的优势。 数据存储结构 关系型数据库一般有固定的表结构，并且需要通过DDL（Data Definition Language）语句来修改表结构，不容易进行扩展，而非关系型数据库的存储机制就有很多，比如基于文档，K-V键值对，还有基于图等，对于数据的格式十分灵活没有固定的表结构，方便扩展。因此，如果业务的数据结构并不是固定的或者经常变动比较大的，那么非关系型数据库是个好的选择。 可扩展性 传统的关系型数据库给人一种横向扩展难，不好对数据进行分片等印象，而一些非关系型数据库则原生就支持数据的水平扩展（比如mongodb的sharding机制）。 需要注意的是，非关系型数据库不是指没有关系的数据库，非关系型数据库的英文为Not Only SQL，译为不仅仅是SQL或许更为恰当。NoSQL相对SQL来说，关联性相对更自由，限制更少，阉割了SQL的特性，所以它的性能会更好，速度也更快一些。但在一些对数据安全稳定要求更高的场景下，SQL更为适用。 对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 但是近年来这两种数据库都在向着另外一个方向进化。例如：NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能的雏形，比如Couchbase的index以及MONGO的复杂查询。对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国。SQL数据库也开始慢慢进化，比如HandlerSocker技术的实现，可以在MYSQL上实现对于SQL层的穿透，用NOSQL的方式访问数据库，性能可以上可以达到甚至超越NOSQL数据库。可扩展性上例如Percona Server，可以实现无中心化的集群。 SQLSQL Data Definition (DDL)最通用的创建表的指令为： 1234567891011create table r ( A1 D1, A2 D2, ..., An Dn, &lt;integrity-contraint1&gt; &lt;integrity-constraint2&gt; ... &lt;integrity-constraintn&gt; ) r：表的名称 Ai：属性名称 Di：属性Ai的数据类型 例如： 1234567create table instructor ( ID char(5), name varchar(20) not null, dept_name varchar(20), salary numberic(8, 2))insert into instructor values ('10211', 'Smith', 'Biology', 66000) 创建表时的integrity constraints： not null primary key (A1, …, An) foreign key (Am, …, An) references r 删除或修改表结构（drop，alter）： drop table r （删除表及其内容） delete from student （删除表中的所有内容，但保留表） alter table alter table r add A D （增加，A为属性，D为属性域） alter table r drop A （删除） SQL查询语句的基本结构SQL DML（Data manipulation language）为我们提供查询、插入、删除、更新条目的能力。 经典的查询语句格式123select A1, A2, ..., Anfrom r1, r2, ..., rmwhere P Ai：代表属性 ri：代表关系 P：条件语句 在select时加上distinct表示去重选择： 12select distinct dept_namefrom instructor select语句select语句后可接算术表达式：+、-、*、/。 12select ID, name, salary/12from instructor rename重命名操作1old-name as new-name 例如： 12select ID、name、salary/12 as monthly_salaryfrom instructor 字符串操作 percent(%)：%可以匹配任何子串 underscore(_)：_可以匹配任何字符 以上两种字符串操作可以应用于数据库表的模糊查询中。 例如：寻找所有导师中名字带有dar的人 123select namefrom instructorwhere name like '%dar%' tuple的排序默认是升序asc： 123select distinct namefrom instructororder by name 如果要降序需显式声明： 1order by name desc 可以根据多个属性进行排序： 1order by dept_name, name Set Operation Question: Find courses that ran in Fall 2009 or in Spring 2010 123(select course_id from section where sem='Fall' and year='2009')union(select course_id from section where sem='Spring' and year='2010') Find courses that ran in Fall 2009 and in Spring 2010 123(select course_id from section where sem='Fall' and year=2009)intersect(select course_id from section where sem='Spring' and year=2009) Find courses that ran in Fall 2009 but not in Spring 2010 123(select course_id from section where sem='Fall' and year=2009)except(select course_id from section where sem='Spring' and year=2009) 以上所有的Set Operation都是自动去重的。 聚集函数Aggregate Functions聚集函数是对一组数据进行计算，并返回单一结果的函数。除了count(*)以外，聚集函数会忽略null值。聚集函数通常在select语句中会使用group by从句。 只能在以下情况中将聚集函数作为表达式： the select list of a SELECT statement (either a subquery or an outer query). a having clause 常用的聚集函数： Count() Sum() Avg() Min() Max() Count()和Sum()的区别在于：Count()是用于计算元组数量，Sum()是用于计算元组的内容总和。 joinSQL join语句是基于两个或两个以上表的共同属性来合并表的数据或者行。 Join Types Join Conditions inner join natural left outer join on right outer join using (A1, A2, …, An) full outer join Join Conditions：用于定义哪些属性在多个关系中是要匹配的 Join Types：用于定义哪一个关系中的turple在没有匹配到任何其他关系中的turple时仍然保留 natural join默认是inner join，它也可以是left outer join或者right outer join。表达的时候，使用natural join表示inner join内连接，natural left outer join或left outer join表示左外连接，natural right outer join或right outer join表示右外连接。 例如： course表： course_id title dept_name credits BI0-301 Genetics Bioloty 4 CS-190 GameDesign Comp_Sci 4 CS-315 Robotics Comp_Sci 3 prereq表： course_id prereq_id BI0_301 BI0_101 CS_190 CS_101 course natural(inner) join prereq： course_id title dept_name credits prereq_id BI0_301 Genetics Biology 4 BI0_101 CS_190 Game Design Comp_Sci 4 CS_101 自然连接是基于两个表中具有相同名称的属性来进行连接，在这个例子中就是course_id。 course (inner) join prereq using course_id： course_id title dept_name credits prereq_id BI0_301 Genetics Biology 4 BI0_101 CS_190 Game Design Comp_Sci 4 CS_101 因为两个表的共同属性为course_id，所以以上两种表达方式是等价的。 左外连接和右外连接： 左外连接：保留左表的所有行，无法匹配的属性则设置为null 右外连接：保留右表的所有行，无法匹配的属性则设置为null Built-in Data Types in SQL date: date’2005-7-27’ time: time’09:00:30’ timestamp: date加上时间 ‘2005-7-27 09:00:30.75’ interval: subtracting a date/time/timestamp value from another gives an interval value index索引索引是存储的表中一个特定列的值（比如Employee_Name）的数据结构（最常见的是B-Tree）。索引是在表的列上创建的。所以要记住的点是，索引包含一个表中列的值，并且这些值存储在一个数据结构中。 12345Create table student( ID varchar(5))Create index studentID_index on student(ID) 我们为什么需要数据库索引？ 假设我们有一个数据库表 Employee， 这个表有三个字段（列）分别是 Employee_Name、Employee_Age 和Employee_Address。假设表Employee 有上千行数据。 我们要从这个表中查找出所有名字是‘Jesus’的雇员信息，使用到下面这个语句： 123SELECT * FROM Employee WHERE Employee_Name = 'Jesus' 如果表中没有索引会发生什么？ 如果没有索引的话，直接在数据库中进行查询，数据库需要扫描Employee表的每一行确定雇员的名字（Employee_Name）是否为’Jesus’。由于我们想要得到每个名字为Jesus的雇员信息，在查询到第一个符合条件的行后，不能停止查询，因为可能还有其他符合条件的行。所以，在这种情况下，数据库要一行一行地查找直到最后一行。这就是所谓的全表扫描。 数据库索引是怎样提升性能的？ 使用索引的全部意义就是通过缩小一张表中需要查询的记录/行的数目来加快搜索的速度。 什么样的数据结构可以作为索引？ B-Tree是最常用的用于索引的数据结构。因为它们时间复杂度低，查找、删除、插入操作都可以在对数时间内完成。另外一个重要原因是，存储在B-Tree中的数据是有序的。数据库管理系统（DBMS）通常决定索引应该用哪些数据结构。但在某些情况下，你在创建索引时可以指定索引要用的数据结构。 哈希表索引是怎样工作的？ 在寻找值时，哈希表效率极高。所以，如果使用哈希索引，对于比较字符串是否相等的查询能够极快地检索出其值。 比如在刚刚的查询（SELECT * FROM Employee WHERE Employee_Name = ‘Jesus’）就可以创建在Employee_Name列上的哈希索引。哈希索引一般的工作方式是，将列的值作为索引的键值（key），和键值对应实际的值（value）是指向该表（Employee）中相应行的指针。 但哈希表是无顺序的数据结构，对于很多类型的查询语句哈希索引都无能为力，比如查找所有小于40岁的员工。哈希表只适合查询键值对，也就是说查询相等的查询。 索引是怎样提升性能的？ 索引是用来存储列值的数据结构。如果索引使用最常用的数据结构B-Tree，那么其中的数据是有序的。有序的列值可以极大地提升性能。 假设我们在Employee_Name这一列上创建一个B-Tree索引。这意味着我们用之前的SQL查找姓名是Jesus的雇员时，不需要再扫描全表。而是用索引查找名字为Jesus的雇员，因为索引已经是按照字母顺序排序。索引已经排序意味着查询一个名字会快很多，因为名字中首字母为J的员工都是排列在一起的。另外重要的一点是，索引同时存储了表中相应行的指针以获取其他列的数据。 数据库索引里存了什么？ 数据库索引是创建在表的某列上的，并存储了这一列的所有值，并且，数据库索引不存储这个表中其他列的值。如果我们在Employee_Name列创建索引，那么列Employee_Age和Employee_Address上的值并不会存储在这个索引当中。如果我们把其他所有字段都存储在这个索引中，那就相当于拷贝了一整张表作为索引，这样会占用太大的空间而且会十分低效。 索引存储了指向表中某一行的指针 数据库索引除了存储表中某列的值外，同时还存储了指向表中相应行的指针。指针是指一块内存区域，该内存区域记录的是对硬盘上记录的相应行的数据的引用。也就是说，索引中的Employee_Name这列的某个值（或者节点）可以描述为（Jesus, 0x82829），0x82829就是包含Jesus那行数据在硬盘上的地址。如果没有这个引用，你就只能访问到一个单独的值Jesus，而这样没有意义。 数据库怎么知道什么时候使用索引？ 当这个SQL（SELECT * FROM Employee WHERE Employee_Name = Jesus）运行时，数据库会检查在查询列上是否有索引。假设Employee_Name列上缺失创建了索引，数据库会接着检查使用这个索引做查询是否合理，因为有些场景下，使用索引比起全表扫描会更加低效。 使用数据库索引会有什么代价？ 索引会占用空间，表越大，索引占用的空间越大。 性能损失（主要是值更新操作）。当你在表中添加、删除或者更新行数据时，索引中也会有相同的操作。 基本原则是：如果表中某列在查询过程中使用非常频繁，那就在该列上创建索引。 Large-Object TypesLarge objects (photos, videos, CAD files, etc.) are stored as a large object： Blob：binary large object Clob: character large object 例如： 12345Book_review clob(10KB)Image blob(10MB)Movie blob(2GB) When a query returns a large object, a pointer is returned rather than the large object itself. 数据库设计以及E-R模型一个数据库可以被建模为： 实体（entity）集合 实体之间的关系（relationship） 实体一个存在的对象，并能与其他对象区别开来。 关系多个实体之间的联系。关系集的维度可以是二维，也可以是多维。两个实体集之间的关系就是二维关系，大多数数据库系统中的关系都是二维的。多于两个实体集之间的关系就是多维关系。 多维关系的例子： 12Student work on research projects under the guidance of an instructor.Relationship proj_guide is a ternary relationship relationship between instructor, student, and project. 属性的域和类型 属性的域（domain）：表示的是属性的取值范围 属性的类型（types）： 简单和复合属性（simple/composite） 单值属性和多值属性（single-values/multivalued） 衍生属性（Derives） 映射基数 one to one one to many many to one many to many Participation Constraint total participation（完全参与）：一个实体集在一个关系中是完全参与的话，该实体集中的每个实体都会参与到至少一个关系中。 比如，在古诗词小程序中，用户和用户的朗诵作品之间存在着关系，那朗诵作品是完全参与到这个关系中的，不存在哪个朗诵作品没有对应的用户。又比如，在学生管理系统中，导师和学生之间存在着关系，但导师和学生这两个实体都不是完全参与到该关系中的，因为有些导师可能没有招收学生，有些学生也没有选择导师，这个就是部分参与（partial participation） partial participation：一个实体集中的有些实体没有参与到关系中，则实体集的参与度就是部分参与。 Keys super key：是属性组合的集合，该集合中的每个属性组合都能够唯一地识别表中的turple candidate key：是super key的最小子集的集合 primary key： 其中一个candidate key会被选择为primary key 关系集的key关系集可以没有属性，如果关系集有属性，那各个实体集的primary key组合起来可以形成关系集的super key。 E-R图 矩形代表实体集 菱形代表关系集 属性列举在矩形中 用下划线标识出primary key 带有复合，多值，衍生属性的实体： 关系集有自身的属性： 基数限制的表达实体集和关系集之间，用→表示“one”，用—表示“many”。 one to one relationship： instructor至多有一个student，student至多有一个instructor one to many relationship： instructor可以有多个student（包括0），student至多有一个instructor many to one relationship： many to many relationship： total participation： 使用cardinality limit： 属性继承 top-down design process: specialization bottom-up design process: generalization overlapping：可重叠 disjoint：不可重叠，只能是两者之一 E-R标识总结 设计关键点 属性间不产生联系，当属性与其他实体有联系时，该属性应作为实体 当一个对象被表达为实体时，在其他实体中不能以属性出现，只能用联系表达 MySQL实践在大致了解了数据库的基础知识后，我便开始设计，搭建自己的数据库。 首先是画E-R图，对数据库进行简单建模： 在古诗词小程序中，我建立了11个实体集和5个关系集，有些实体集之间是有继承关系的，比如composition与poems，poetry，lunyu，shijing。 在创建表时，选择MySQL的默认存储引擎InnoDB： 1234567891011121314create table user ( openid varchar(100) not null comment openid, nickname varchar(100) default null comment '昵称', avatar_url varchar(1000) default null comment '头像地址', gender int(1) default 0 comment '性别', province varchar(30) default null comment '省份', city varchar(30) default null comment '城市', country varchar(30) default null comment '国家', primary key openid)ENGINE=InnoDBDEFAULT CHARSET=utf8mb4COLLATE=utf8mb4_general_ciCOMMENT='古诗词小程序'; auto_increment当我们在MySQL中建表时，有些属性经常会添加auto_increment这个属性定义，它可以用于为一个表中的记录自动生成ID。auto_increment是用于主键自动增长的，从1开始增长，当你把第一条记录删除时，再插入第二条数据，主键值是2，不是1。 在使用auto_increment时，应注意以下几点： auto_increment数据列必须是主键或者是主键的一部分，且必须具备NOT NULL属性 当进行全表删除时，MySQL auto_increment会从1重新开始编号 InnoDB存储引擎MySQL 从第一个版本发布到现在已经有了 20 多年的历史，在这么多年的发展和演变中，整个应用的体系结构变得越来越复杂： 最上层：用于连接、线程处理的部分并不是 MySQL 『发明』的，很多服务都有类似的组成部分 第二层：包含了大多数 MySQL 的核心服务，包括了对 SQL 的解析、分析、优化和缓存等功能，存储过程、触发器和视图都是在这里实现的 第三层：MySQL中真正负责数据的存储和提取的存储引擎，例如：InnoDB、MyISAM 数据的存储在整个数据库体系结构中，我们可以使用不同的存储引擎来存储数据，而绝大多数存储引擎都以二进制的形式存储数据。 在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）： 同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 innodb_page_size 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同： 从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。 如何存储记录与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-200 行的记录。 行溢出数据当 InnoDB 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。 但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。 数据页结构页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面。 首先，一个 InnoDB 页有以下七个部分： User Records就是整个页面中真正用于存放行记录的部分，而Free Space就是空余空间。 B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、next_record 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。 索引索引在上文中也提到，是数据库非常重要的概念，它是存储引擎能够快速定位记录的秘密武器，是对查询性能优化最有效的手段。 索引的数据结构InnoDB存储引擎在绝大多数情况下使用B+树建立索引，这是关系型数据库中最为常用和有效的索引。但是 B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页，然后正如上一节所提到的，数据库把整个页读入到内存中，并在内存中查找具体的数据行。 B+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度。 聚集索引和辅助索引数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），它们之间的最大区别就是，聚集索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』。 聚集索引InnoDB存储引擎中的表都是使用索引组织的，也就是按照键的顺序存放。聚集索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录数据。聚集索引构成的B+树是数据实际存储的形式。 123456789CREATE TABLE users( id INT NOT NULL, first_name VARCHAR(20) NOT NULL, last_name VARCHAR(20) NOT NULL, age INT NOT NULL, PRIMARY KEY(id), KEY(last_name, first_name, age) KEY(first_name)); 如果使用上面的 SQL 在数据库中创建一张表，B+ 树就会使用 id 作为索引的键，并在叶子节点中存储一条记录中的所有信息。 聚集索引与表的物理存储方式有着非常密切的关系，所有正常的表应该有且仅有一个聚集索引（绝大多数情况下都是主键），表中的所有行记录数据都是按照聚集索引的顺序存放的。 辅助索引辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 InnoDB 中这个书签就是当前记录的主键。 如果在表 users 中存在一个辅助索引 (first_name, age)，那么它构成的 B+ 树大致就是上图这样，按照 (first_name, age) 的字母顺序对表中的数据进行排序，当查找到主键时，再通过聚集索引获取到整条行记录： 上图展示了一个使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。 Reference『浅入浅出』MySQL 和 InnoDB How do database indexes work? And, how do indexes help? Provide a tutorial on database indexes.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"微信小程序登录鉴权与获取用户信息","slug":"微信小程序登录鉴权与获取用户信息","date":"2021-01-26T00:29:21.000Z","updated":"2021-01-27T02:04:43.240Z","comments":true,"path":"2021/01/26/微信小程序登录鉴权与获取用户信息/","link":"","permalink":"http://delaprada.com/2021/01/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83%E4%B8%8E%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/","excerpt":"","text":"前言在小程序中，与云开发相比，传统的前后端开发在登录鉴权的实现方面相对来说更加复杂，不仅需要前端和后端的交互，后端还需要与微信接口服务进行交互，以完成整个鉴权流程： 整个流程简单来说分为以下7步： 前端调用wx.login()获取临时登录凭证code，并回传到开发者服务器。 服务器调用auth.code2Session换取用户唯一标识OpenID和会话密钥session_key。 服务器端根据OpenID或session_key生成自定义登录态（可以理解为是token），将token响应给前端。 前端将token存入Storage中。 当前端之后向后端发起请求时，就会带上token。 后台通过token（或者其他类型密钥），解密获取OpenID，判断是哪个用户的行为，做出响应的逻辑处理（比如操作数据库等）。 后台响应数据给前端。 这个是小程序登录的流程，但是小程序登录和小程序获取用户信息并不是一回事。小程序登录的API是wx.login，可以获取用户的openID，openID是用户的唯一标识，是比较隐私的数据，一般不会返回给前端。小程序获取用户信息的API是wx.getUserInfo，它可以获取用户的一些基本信息，比如nickName、avatarUrl等。两者不要弄混。 其实微信登录一开始并不是这样的，以往微信小程序在用户没有任何操作的情况下就会直接弹出授权的登录方式，如果用户点击拒绝授权，则无法使用小程序。按照微信官方对这个功能更新的解释是： 因此，微信对开发的建议是： 当用户打开小程序时访问第一个页面时，先通过wx.login，获取用户 openID 。这时无需弹框授权，开发者拿到 openID 可以建立自身的帐号ID。 在第一步中，拿到 openID 后，判断是新用户还是老用户。如果是老用户，可以直接登录；如果是新用户，可先在小程序首页展示你的信息服务，让用户对这个小程序有大概的了解，再引导用户进行下一步的操作。 当需要获取用户头像昵称的时候，对用户展示一个登录页面，这个页面只有一个最重要的操作，引导用户进行登录。 小程序登录在上一节中有提到，小程序登录可以分为7个步骤，下面就详细讲一下7个步骤具体是如何实现。 step1: 前端调用wx.login()获取临时登录凭证code在项目中，我使用了Taro框架，所以调用的API对应为Taro.login()： 123456789101112131415161718192021222324252627Taro.login(&#123;&#125;) .then((res) =&gt; &#123; if (res.code) &#123; // 将code发送到后台，以获取token getToken(res.code) .then((res: any) =&gt; &#123; const &#123; token, userExist &#125; = res; // 将token存储到Storage中 Taro.setStorageSync('token', token); // 如果是老用户，获取用户信息 if(userExist) &#123; const &#123; userInfo &#125; = res; Taro.setStorageSync('userInfo', userInfo); &#125; &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125; else &#123; console.log('登录失败! ' + res.errMsg); &#125; &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); step2: 服务端调用auth.code2Session换取openid和session_key服务端调用外部接口需要使用egg.js中的一个api：this.ctx.curl，因为是异步请求，所以需要加上await： 123456789101112131415// app/controller/home.js// login接口async login() &#123; const &#123; ctx &#125; = this; const &#123; code &#125; = ctx.request.body; // 服务器根据客户端传来的code向微信接口服务获取session_key和openid const res = await ctx.curl( `https://api.weixin.qq.com/sns/jscode2session? appid=wx6936c18b38186cf3&amp;secret=d11f77fb7d5a959b6ba46c30dbd4da95&amp;js_code=$&#123;code&#125;&amp;grant_type=authorization_code`, &#123; dataType: 'json', &#125; ); const &#123; openid &#125; = res.data; // 获取到openid&#125; step3: 根据openid生成自定义登录态token，响应给前端因为openid是用户的唯一标识，根据它生成token，响应给前端后，前端每次发请求带上token，后台解密请求中的token，获取到openid，便能识别这是哪个用户的请求行为。 这里我们使用jwt来生成自定义登录态token，使用jwt-simple库来生成jwt： 1234567891011121314151617const jwt = require('jwt-simple');const SECRET = 'zhuoran'; // 自定义async login() &#123; ... const &#123; openid &#125; = res.data; // 获取到openid // 根据用户的openid生成token const token = jwt.encode(openid, SECRET); // 将token返回 ctx.body = &#123; token: token, ... &#125;; ...&#125; step4: 前端将token存入storage12// 将token存储到Storage中Taro.setStorageSync('token', token); 并在每次请求时带上token，将token放在请求头的Authorization字段里面： 12345678910const option = &#123; url: BASE_URL + url, data: data, method: method, header: &#123; 'content-type': contentType, Authorization: Taro.getStorageSync('token'), &#125;,&#125;;Taro.request(option); 这样前端之后向后端发起请求，都会带上token。 step5: 后台解密token获取openid在后台解密token获取openid之后，便能知道这是哪个用户的请求，执行响应的操作： 12345678910111213141516171819async request() &#123; const &#123; ctx &#125; = this; // 从请求头的authorization字段获取token const token = ctx.get('authorization'); // 对token进行解密获取其中的openid const openid = jwt.decode(token, SECRET); // 根据openid查找用户信息 const res = await ctx.model.User.findAll(&#123; where: &#123; openid: openid, &#125;, &#125;); // 之后注意要将openid属性去掉，私密属性不传回给客户端 ctx.body = res;&#125; 额外需要注意的点保存用户登录态，一直以来都有两种解决方案：前端保存和后端保存。 后端保存：在后端设定并存储当前token的过期时间，定期通知小程序前端重新登录 前端保存：因为session_key存在时效性（因为通过session_key我们可以查看敏感信息，所以必定会有一定的时效性），而小程序前端可以通过wx.checkSession()来检查session_key是否过期。我们可以自定义登录态，并考虑以session_key有效期作为自身登录态有效期（也就是以session_key的到期时间作为自定义登录态的到期时间，两者实际上并没有实质联系）。这个也是小程序文档中推荐的方法。 因此，在项目中token是会过期的，一段时间没有使用就会导致它过期。那怎么去检验token是否过期，然后去更新它呢？ 这里就需要用到前端拦截器和后端中间件。前端拦截器用来判断token是否过期，后端中间件用于判断请求是否携带token以及token是否有效。 前端拦截器这里会使用到Taro拦截器API：Taro.addInterceptor(callback)。拦截器允许我们在请求发出前或发出后做一些额外操作。 例如： 123456789101112131415const interceptor = function (chain) &#123; // 拦截请求发出前做一些额外操作 const requestParams = chain.requestParams const &#123; method, data, url &#125; = requestParams console.log(`http $&#123;method || 'GET'&#125; --&gt; $&#123;url&#125; data: `, data) return chain.proceed(requestParams) .then(res =&gt; &#123; // 拦截请求发出后做一些额外操作 console.log(`http &lt;-- $&#123;url&#125; result:`, res) return res &#125;) &#125;Taro.addInterceptor(interceptor) 所以，我们可以将checkSession步骤写在前端拦截器里，在请求每次发出之前判断session_key是否有过期，如果过期了，则重新调用login方法，更新token，如果没有过期，则正常发起请求： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// login方法const login = () =&gt; &#123; Taro.login(&#123;&#125;) .then((res) =&gt; &#123; if (res.code) &#123; console.log('code为' + res.code); // 将code和userInfo发送到后台，以获取token getToken(res.code) .then((token) =&gt; &#123; console.log('获取token'); console.log(token); // 将token存储到Storage中 Taro.setStorageSync('token', token); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125; else &#123; console.log('登录失败! ' + res.errMsg); &#125; &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;);&#125;;// 自定义拦截器const customInterceptor = (chain) =&gt; &#123; const requestParams = chain.requestParams; // 获取token const loginFlag = Taro.getStorageSync('token'); // 检查session是否过期 Taro.checkSession(&#123;&#125;) .then((res) =&gt; &#123; console.log(res); console.log('session没过期，不用重新登录'); console.log('token为' + loginFlag); &#125;) .catch((err) =&gt; &#123; console.log(err); console.log('session已过期，要重新登录'); // 重新登录 login(); &#125;); return chain.proceed(requestParams).then((res) =&gt; &#123; // 只要请求成功，不管返回什么状态码，都走这个回调 switch (res.statusCode) &#123; case HTTP_STATUS.NOT_FOUND: return Promise.reject('请求资源不存在'); case HTTP_STATUS.BAD_GATEWAY: return Promise.reject('服务端出现了问题'); case HTTP_STATUS.FORBIDDEN: &#123; Taro.setStorageSync('Authorization', ''); // pageToLogin(); // TODO 根据自身业务修改 return Promise.reject('没有权限访问'); &#125; case HTTP_STATUS.AUTHENTICATE: &#123; Taro.setStorageSync('Authorization', ''); // pageToLogin(); return Promise.reject('需要鉴权'); &#125; case HTTP_STATUS.SUCCESS: return res.data; &#125; &#125;);&#125;;// Taro 提供了两个内置拦截器// logInterceptor - 用于打印请求的相关信息// timeoutInterceptor - 在请求超时时抛出错误。const interceptors = [ customInterceptor, Taro.interceptors.logInterceptor,];export default interceptors; 后端中间件正如之前所述，后端中间件的作用是用户判断请求是否携带token以及token是否有效的。我们在egg Node.js后端项目中定义校验token的中间件： 1234567891011121314151617181920212223242526272829// app/middleware/auth.jslet jwt = require('jwt-simple');const SECRET = 'zhuoran';module.exports = (options) =&gt; &#123; return async function auth(ctx, next) &#123; const token = ctx.get('authorization'); if (token) &#123; console.log('请求带有token'); try &#123; const openid = jwt.decode(token, SECRET); await next(); &#125; catch (err) &#123; ctx.body = &#123; code: 401, msg: 'token有误', &#125;; &#125; &#125; else &#123; console.log('请求没有带token'); ctx.body = &#123; code: 401, msg: '您没有登录', &#125;; &#125; &#125;;&#125;; 因为小程序中，有些功能不强制要求用户登录之后才能使用，所以有些请求操作不需要后台校验是否有token，那么这个auth.js中间件就不能够全局配置，而是放在需要校验token的路由下： 123456789module.exports = (app) =&gt; &#123; const &#123; router, controller, middleware &#125; = app; const auth = middleware.auth(); router.get('/', controller.home.index); router.get('/request', auth, controller.home.request); // 将middleware放在中间 router.post('/login', controller.home.login); router.post('/userInfo', controller.home.userInfo);&#125;; 登录鉴权及获得用户信息流程梳理登录： 获取用户信息： 总结相对于云开发来说，传统的前后端开发在登录鉴权方面复杂许多，涉及多端交互，以上总结也有许多要改进的地方。总而言之，将逻辑理顺之后，写代码就比较简单了。 在登录鉴权过程中比较重要的点： 知道什么是用户的唯一标识，并根据它生成token 对token进行校验，判断其是否过期，是否准确 通过画流程图等方式理清各个过程的逻辑 参考使用Nodejs实现jwt原理 手把手教会你小程序登录鉴权 小程序登录那些事 小程序：授权、登录、session_key、unionId 微信小程序wx.getUserInfo授权获取用户信息（头像、昵称） 前后端分离项目，token过期，重新登录和刷新token的问题 egg中间件匹配路由 Taro微信小程序登录 Button组件onGetUserInfo未执行","categories":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"egg.js+react SSR实践","slug":"egg-js-react-SSR实践","date":"2021-01-19T13:06:48.000Z","updated":"2021-01-20T02:10:03.382Z","comments":true,"path":"2021/01/19/egg-js-react-SSR实践/","link":"","permalink":"http://delaprada.com/2021/01/19/egg-js-react-SSR%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"前言最近在做毕设的调研，想学一下如何用node进行后台开发，选择的后台框架是阿里的egg.js，结合mysql数据库、DBeaver数据库管理工具和Sequelize实现CRUD操作。 基础功能首先介绍一下egg初始化生成的项目各个部分的功能。 一个egg项目目录组成大致如下： 12345678910111213141516171819202122232425262728293031323334353637egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app| ├── router.js│ ├── controller│ | └── home.js│ ├── service (可选)│ | └── user.js│ ├── middleware (可选)│ | └── response_time.js│ ├── schedule (可选)│ | └── my_task.js│ ├── public (可选)│ | └── reset.css│ ├── view (可选)│ | └── home.tpl│ └── extend (可选)│ ├── helper.js (可选)│ ├── request.js (可选)│ ├── response.js (可选)│ ├── context.js (可选)│ ├── application.js (可选)│ └── agent.js (可选)├── config| ├── plugin.js| ├── config.default.js│ ├── config.prod.js| ├── config.test.js (可选)| ├── config.local.js (可选)| └── config.unittest.js (可选)└── test ├── middleware | └── response_time.test.js └── controller └── home.test.js app/router.js用于配置URL路由规则。即描述请求URL和具体承担执行动作的Controller的对应关系。 app/router.js里面定义URL路由规则： 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/user/:id', controller.user.info);&#125;; app/controller目录下面实现Controller： 123456789// app/controller/user.jsclass UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; ctx.body = &#123; name: `hello $&#123;ctx.params.id&#125;`, &#125;; &#125;&#125; 当用户执行GET /user/123，user.js这个里面的info方法就会执行。 一些路由定义方式： 123456789// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/home', controller.home); router.get('/user/:id', controller.user.page); router.post('/admin', isAdmin, controller.admin); router.post('/user', isLoginUser, hasAdminPermission, controller.user.create); router.post('/api/v1/comments', controller.v1.comments.create); // app/controller/v1/comments.js&#125;; RESTful风格的URL定义如果想通过RESTful的方式来定义路由，egg提供了app.router.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller)快速在一个路径上生成CRUD路由结构。 123456// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.resources('posts', '/api/posts', controller.posts); router.resources('users', '/api/v1/users', controller.v1.users); // app/controller/v1/users.js&#125;; 上面代码就在 /posts 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 app/controller/posts.js 接下来， 你只需要在 posts.js 里面实现对应的函数就可以了。 Method Path Route Name Controller.Action GET /posts posts app.controllers.posts.index GET /posts/new new_post app.controllers.posts.new GET /posts/:id post app.controllers.posts.show GET /posts/:id/edit edit_post app.controllers.posts.edit POST /posts posts app.controllers.posts.create PUT /posts/:id post app.controllers.posts.update DELETE /posts/:id post app.controllers.posts.destroy 1234567891011121314// app/controller/posts.jsexports.index = async () =&gt; &#123;&#125;;exports.new = async () =&gt; &#123;&#125;;exports.create = async () =&gt; &#123;&#125;;exports.show = async () =&gt; &#123;&#125;;exports.edit = async () =&gt; &#123;&#125;;exports.update = async () =&gt; &#123;&#125;;exports.destroy = async () =&gt; &#123;&#125;; 如果我们不需要其中的某几个方法，可以不用在 posts.js 里面实现，这样对应 URL 路径也不会注册到 Router。 app/controller/**Controller负责解析用户的输入，处理后返回相应的结果。egg推荐Controller层主要对用户的请求参数进行处理（校验、转换），然后调用对应的service方法处理业务，得到业务结果后封装并返回。简单来说，Controller是接口，而具体涉及到操作表的事情交给service来做。 如何编写Controller所有的Controller文件都必须放在app/controller目录下，可以支持多级目录，访问的时候可以通过目录名级联访问。 推荐使用controller类的方式： 12345678910111213141516171819202122// app/controller/post.jsconst Controller = require('egg').Controller;class PostController extends Controller &#123; async create() &#123; const &#123; ctx, service &#125; = this; const createRule = &#123; title: &#123; type: 'string' &#125;, content: &#123; type: 'string' &#125;, &#125;; // 校验参数 ctx.validate(createRule); // 组装参数 const author = ctx.session.userId; const req = Object.assign(ctx.request.body, &#123; author &#125;); // 调用 Service 进行业务处理 const res = await service.post.create(req); // 设置响应内容和响应状态码 ctx.body = &#123; id: res.id &#125;; ctx.status = 201; &#125;&#125;module.exports = PostController; 上面的代码定义了一个PostController的类，类里面的每一个方法都可以作为一个Controller在Router中引用到，我们可以从app.controller根据文件名和方法名定位到它： 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.post('createPost', '/api/posts', controller.post.create);&#125; Controller 支持多级目录，例如如果我们将上面的 Controller 代码放到 app/controller/sub/post.js 中，则可以在 router 中这样使用： 1234// app/router.jsmodule.exports = app =&gt; &#123; app.router.post('createPost', '/api/posts', app.controller.sub.post.create);&#125; 项目中的Controller类继承于egg.Controller，会有几个属性挂在this上： this.ctx：当前请求的上下文Context对象的实例，通过它我们可以拿到框架封装好的处理当前请求的各种便捷属性和方法。 this.app：当前应用Application对象的实例，通过它我们可以拿到框架提供的全局对象和方法。 this.service：应用定义的 Service，通过它我们可以访问到抽象出的业务层，等价于 this.ctx.service 。 this.config：应用运行时的配置项。 this.logger：logger 对象。 app/service/**用于编写业务逻辑层，可选，建议使用。Service就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，提供这个抽象有以下几个好处： 保持Controller中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的Service可以被多个Controller重复调用。 下面就通过一个完整的例子，看看怎么使用 Service。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// app/router.jsmodule.exports = app =&gt; &#123; app.router.get('/user/:id', app.controller.user.info);&#125;;// app/controller/user.jsconst Controller = require('egg').Controller;class UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; const userId = ctx.params.id; const userInfo = await ctx.service.user.find(userId); ctx.body = userInfo; &#125;&#125;module.exports = UserController;// app/service/user.jsconst Service = require('egg').Service;class UserService extends Service &#123; // 默认不需要提供构造函数。 // constructor(ctx) &#123; // super(ctx); 如果需要在构造函数做一些处理，一定要有这句话，才能保证后面 `this.ctx`的使用。 // // 就可以直接通过 this.ctx 获取 ctx 了 // // 还可以直接通过 this.app 获取 app 了 // &#125; async find(uid) &#123; // 假如 我们拿到用户 id 从数据库获取用户详细信息 const user = await this.ctx.db.query('select * from user where uid = ?', uid); // 假定这里还有一些复杂的计算，然后返回需要的信息。 const picture = await this.getPicture(uid); return &#123; name: user.user_name, age: user.age, picture, &#125;; &#125; async getPicture(uid) &#123; const result = await this.ctx.curl(`http://photoserver/uid=$&#123;uid&#125;`, &#123; dataType: 'json' &#125;); return result.data; &#125;&#125;module.exports = UserService;// curl http://127.0.0.1:7001/user/1234 config/config.default.js用于编写配置文件。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const path = require('path');module.exports = (app) =&gt; &#123; /** * built-in config * @type &#123;Egg.EggAppConfig&#125; **/ const config = (exports = &#123;&#125;); // use for cookie sign key, should change to your own and keep security config.keys = app.name + '_1610862343048_2407'; // add your middleware config here config.middleware = []; // add your user config here const userConfig = &#123; // myAppName: 'egg', &#125;; config.static = &#123; prefix: '/public/', dir: path.join(app.baseDir, 'public'), &#125;; // 配置和ssr相关项 config.reactssr = &#123; layout: path.join(app.baseDir, 'app/view/layout.html'), &#125;; // 配置sequelize，与mysql数据源连接 config.sequelize = &#123; dialect: 'mysql', host: 'localhost', port: 3306, database: 'eggtest', username: 'root', password: '*****', &#125;; // 不进行csrf攻击检测，使用postman时需要配置 config.security = &#123; csrf: &#123; enable: false, &#125;, &#125;; return &#123; ...config, ...userConfig, &#125;;&#125;; config/plugin.js用于配置需要加载的插件。 123456789101112// plugin.jsexports.static = true;exports.reactssr = &#123; enable: true, package: 'egg-view-react-ssr',&#125;;exports.sequelize = &#123; enable: true, package: 'egg-sequelize',&#125;; 12345678910// plugin.local.jsexports.webpack = &#123; enable: true, package: 'egg-webpack',&#125;;exports.webpackreact = &#123; enable: true, package: 'egg-webpack-react',&#125;; app/model/**用于放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize。 其余配置见egg官网介绍：目录结构。 简单的CRUD功能的实现通过下面这个例子，我们简单地实现一个前端通过事件向后台发起请求，后台进行处理，操作数据库，然后响应结果的过程。 MySQL下载在编码之前，首先要在本机上安装好MySQL，下载地址：MySQL。要下载大的MSI版本，不要下载zip，下载zip一直没成功。 下载好MySQL之后，配置环境变量，使得直接在cmd的根目录下输入mysql指令可以被识别，否则每次都得进入MySQL安装包的bin文件夹下cmd。 DBeaver下载下载DBeaver客户端，对MySQL数据库进行管理。 在DBeaver中可以通过指令创建表，查看表目前的情况： 关于DBeaver连接MySQL数据库可参考文章：DBeaver连接MySQL。 在连接过程中会遇到这样的错误： 1DBeaver连接mysql失败：Unable to load authentication plugin &#39;caching_sha2_password&#39;. 这个是因为，mysql8之前的版本使用的密码加密规则是mysql_native_password，但是在mysql8则是caching_sha2_password，所以需要修改密码加密规则。 所以接下来要做的事情就是修改MySQL使用的密码加密规则。 打开cmd对话框，输入mysql -u root -p后回车，然后会提示输入密码，输入密码后就会进入MySQL的操作管理界面。 使用 use mysql打开数据库 和 select user,host,plugin from user; 查看用户，主机，插件。 接下来开始修改默认插件alter user &#39;root&#39; @&#39;localhost&#39; identified with mysql_native_password by &#39;root&#39;; by后面输入密码，可以通过该语句修改密码，若不需要修改密码则输入原来的密码。 再次输入 select user,host,plugin from user; 查看用户，主机，插件。 到这里就可以正常连接MySQL了。 Sequelize安装及配置安装并配置egg-sequelize插件（它会辅助我们将定义好的 Model 对象加载到 app 和 ctx 上）和 mysql2模块： 1npm install --save egg-sequelize mysql2 在 config/plugin.js 中引入 egg-sequelize 插件： 1234exports.sequelize = &#123; enable: true, package: 'egg-sequelize',&#125;; 在 config/config.default.js 中编写 sequelize 配置： 12345678config.sequelize = &#123; dialect: 'mysql', host: 'localhost', port: 3306, database: 'eggtest', // 数据库名称 username: 'root', password: '******',&#125;; 初始化数据库我们可以在MySQL应用内或者通过mysql指令在本地创建一个数据库eggtest： 12// mysql指令mysql -u root -e 'CREATE DATABASE IF NOT EXISTS `eggtest`;' 因为DBeaver连接MySQL时需要连接已经存在的数据库，所以要在MySQL中事先创建一个数据库。 然后再DBeaver中通过指令创建user表： 12345678910CREATE TABLE eggTest.`user` (`id` int(11) NOT NULL AUTO_INCREMENT,`username` varchar(100) DEFAULT NULL COMMENT '姓名',`age` INT(11) DEFAULT 0 COMMENT '年龄', PRIMARY KEY (`id`))ENGINE=InnoDBDEFAULT CHARSET=utf8mb4COLLATE=utf8mb4_0900_ai_ciCOMMENT='eggTest用户信息'; 然后我们就可以在MySQL和DBeaver中都看到这个新建的表了。 完成CRUD功能项目目录： config/plugin.js： 1234exports.sequelize = &#123; enable: true, package: 'egg-sequelize',&#125;; config/default.js： 123456789// 添加数据库配置config.sequelize = &#123; dialect: 'mysql', host: 'localhost', port: 3306, database: 'eggtest', username: 'root', password: '*******',&#125;; model/user.js： 123456789101112131415161718192021module.exports = (app) =&gt; &#123; const &#123; STRING, INTEGER &#125; = app.Sequelize; const user = app.model.define( 'user', &#123; id: &#123; type: INTEGER(11), primaryKey: true, &#125;, username: STRING(100), age: INTEGER(11), &#125;, &#123; freezeTableName: true, tableName: 'user', timestamps: false, underscored: true, &#125; ); return user;&#125;; controller/users.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const controller = require('egg').Controller;const toInt = function (str) &#123; if (typeof str === 'number') return str; if (!str) return str; return parseInt(str, 10) || 0;&#125;;class UserController extends controller &#123; /** * 接口描述 * 用户登录 * 请求方式：post * 参数：&#123; * username：string * age: int * &#125; */ // 展示所有用户 async index() &#123; const &#123; ctx &#125; = this; const query = &#123; limit: toInt(ctx.query.limit), offset: toInt(ctx.query.offset) &#125;; ctx.body = await ctx.model.User.findAll(query); &#125; // 展示用户 async show() &#123; const &#123; ctx &#125; = this; ctx.body = await ctx.model.User.findByPk(toInt(ctx.params.id)); &#125; // 创建用户 async create() &#123; console.log('创建用户'); const &#123; ctx &#125; = this; const &#123; username, age &#125; = ctx.request.body; const user = await ctx.model.User.create(&#123; username, age &#125;); ctx.status = 201; ctx.body = user; &#125; // 更新用户 async update() &#123; const &#123; ctx &#125; = this; const id = toInt(ctx.params.id); const user = await ctx.model.User.findByPk(id); if(!user) &#123; ctx.status = 404; return; &#125; const &#123; age &#125; = ctx.request.body; await user.update(&#123; age &#125;); ctx.body = user; &#125; // 删除用户 async destroy() &#123; const &#123; ctx &#125; = this; const id = toInt(ctx.params.id); const user = await ctx.model.User.findByPk(id); if(!user) &#123; ctx.status = 404; return; &#125; await user.destroy(); ctx.status = 200; &#125;&#125;module.exports = UserController; router.js： 1234567module.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/', controller.home.server); router.get('/client', controller.home.client); router.resources('users', '/users', controller.users);&#125;; 使用postman进行测试使用postman进行测试时注意要把egg的csrf检测关掉： 123456// config/config.default.jsconfig.security = &#123; csrf: &#123; enable: false, &#125;,&#125;; 查询所有用户： 根据id查找： 新增用户（注意请求体格式选择x-www-form-urlencoded）： 更新用户信息： 删除用户： 参考：egg+sequelize+mysql实现CRUD操作 与前端对接首先安装axios和qs： 1cnpm install axios qs 在web目录下新建api文件夹，在config.js文件中添加axios基础配置，在request.js中添加请求方法： 123456789101112131415161718192021222324// api/config.jsimport axios from 'axios';export const baseUrl = '/';const axiosInstance = axios.create(&#123; baseUrl: baseUrl, headers: &#123; post: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125; &#125;&#125;);axiosInstance.interceptors.response.use( res =&gt; res.data, err =&gt; &#123; console.log(err, '网络错误'); &#125;);export &#123; axiosInstance,&#125;; 12345678910111213141516171819202122232425262728293031323334// api/request.jsimport &#123; axiosInstance &#125; from './config';import qs from 'qs';export const getAllUserRequest = () =&gt; &#123; return axiosInstance.get('/users');&#125;;export const searchUserRequest = (id) =&gt; &#123; return axiosInstance.get(`/users/$&#123;id&#125;`);&#125;;export const createUserRequest = (&#123; username, age &#125;) =&gt; &#123; return axiosInstance.post( '/users', qs.stringify(&#123; username, age, &#125;) );&#125;;export const updateUserRequest = (id, age) =&gt; &#123; return axiosInstance.put( `/users/$&#123;id&#125;`, qs.stringify(&#123; age, &#125;) );&#125;;export const deleteUserRequest = (id) =&gt; &#123; return axiosInstance.delete(`/users/$&#123;id&#125;`);&#125;; 在组件中引入请求方法，并放在对应的事件处理函数中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, &#123; useEffect &#125; from 'react';// $&#123;root&#125;/app/web/component/layout.jsx 通过 webpack alias 配置 componentimport Layout from '@component/layout.jsx';import &#123; getAllUserRequest, searchUserRequest, createUserRequest, updateUserRequest, deleteUserRequest,&#125; from '../../api/request';function HomeIndex(props) &#123; useEffect(() =&gt; &#123; console.log('----componentDidMount-----'); &#125;, []); const showAllUser = () =&gt; &#123; getAllUserRequest() .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125;; const searchUser = (id) =&gt; &#123; searchUserRequest(id) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125;; const createUser = () =&gt; &#123; createUserRequest(&#123; username: 'bella', age: 18, &#125;) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125;; const updateUser = (id, age) =&gt; &#123; updateUserRequest(id, age) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125;; const deleteUser = (id) =&gt; &#123; deleteUserRequest(id) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;); &#125;; return ( &lt;div&gt; &lt;Layout title=\"egg-react-ssr\" keywords=\"alice\" description=\"easy task\"&gt; &lt;div className=\"main\"&gt; &lt;div className=\"page-container page-component\"&gt;&#123;props.message&#125;&lt;/div&gt; &lt;/div&gt; &lt;button onClick=&#123;showAllUser&#125;&gt;展示所有用户&lt;/button&gt; &lt;button onClick=&#123;() =&gt; searchUser(1)&#125;&gt;根据id搜索用户&lt;/button&gt; &lt;button onClick=&#123;createUser&#125;&gt;创建用户&lt;/button&gt; &lt;button onClick=&#123;() =&gt; updateUser(1, 19)&#125;&gt;更新用户信息&lt;/button&gt; &lt;button onClick=&#123;() =&gt; deleteUser(1)&#125;&gt;删除用户&lt;/button&gt; &lt;/Layout&gt; &lt;/div&gt; );&#125;export default HomeIndex; 在前端页面触发点击事件时，可以得到相应的结果： 在这里，另一个很关键的点是webpack.config.js的配置： 123456789101112131415161718const path = require('path');const fs = require('fs');const rootPath = fs.realpathSync(process.cwd());const resolve = (relativePath) =&gt; path.resolve(rootPath, relativePath);const projectPath = resolve('app/web');module.exports = &#123; devtool: 'source-map', entry: &#123; index: 'app/web/page/home/index.jsx', // 必须是jsx，否则客户端渲染有问题 &#125;, resolve: &#123; alias: &#123; '@': projectPath, // 子项目根目录 '@component': path.resolve(projectPath, 'component'), &#125;, &#125;,&#125;; entry的配置必须是jsx结尾的文件，js结尾的文件会导致客户端渲染有问题，服务端的console.log也无法正常展示。 详情见egg官网对webpack的entry配置解释：Webpack。 项目仓库地址：egg-react-ssr-example。 参考Egg React SSR/CSR 工程化 Egg.js开发指南 Egg.js+vue 实战项目","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"},{"name":"Node.js","slug":"React/Node-js","permalink":"http://delaprada.com/categories/React/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"},{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"Taro微信小程序云开发实践","slug":"Taro微信小程序云开发实践","date":"2021-01-16T06:32:08.000Z","updated":"2021-01-17T02:48:46.580Z","comments":true,"path":"2021/01/16/Taro微信小程序云开发实践/","link":"","permalink":"http://delaprada.com/2021/01/16/Taro%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"前言云开发简而言之就是：开发者无需搭建服务器，可免鉴权直接使用平台提供的API进行业务开发。 云开发提供云函数，云数据库和云存储，服务端的部署和托管都交由腾讯云来管理，开发者就无需在运维和管理上投入过多的精力。 小程序传统开发模式： 小程序云开发： 云函数：node.js 云数据库：MongoDB 传统开发 vs 云开发： （serverless指的是：我们无需考虑硬件等基础设施，是无服务的应用，我们依赖的是像腾讯云这样的云服务商提供的服务） 云开发想要在小程序中实现云开发，首先在导入项目时要填入注册的APPID，必须填写，否则无法使用云开发功能。 无论是使用微信创建一个云开发项目还是使用taro cli初始化一个云开发项目，根目录下都会有一个project.config.json文件，文件中的cloudbaseRoot用于指定存放云函数&amp;云托管的目录。 需要注意的是，云开发能力从基础库2.2.4开始支持。 云开发在默认配额下可以创建两个环境，各个环境相互隔离，每个环境都包含独立的数据库实例、存储空间、云函数配置等资源： 如上图所示，我创建了两个环境，一个叫dev， 一个叫test-taro。 在项目中，需要为项目配置开发的环境，否则默认都是指定第一个创建的环境。 比如在taro云开发项目中，需在app.js中配置项目环境： 1234567componentDidMount () &#123; if (process.env.TARO_ENV === 'weapp') &#123; Taro.cloud.init(&#123; env: 'test-taro-1gs4sohn82c1ff34' // 环境id &#125;) &#125;&#125; 微信原生的云开发项目中，则在onLaunch方法中配置： 12345678910111213141516onLaunch: function () &#123; if (!wx.cloud) &#123; console.error('请使用 2.2.3 或以上的基础库以使用云能力') &#125; else &#123; wx.cloud.init(&#123; // env 参数说明： // env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源 // 此处请填入环境 ID, 环境 ID 可打开云控制台查看 // 如不填则使用默认环境（第一个创建的环境） // env: 'my-env-id', traceUser: true, &#125;) &#125; this.globalData = &#123;&#125;&#125; 云函数处可通过右键切换云函数的当前环境： 注意：在小程序端配置init时的env只会决定小程序端API调用的云环境，并不会决定云函数中API调用的环境，云函数中需要通过wx-server-sdk的init方法重新设置环境（或者使用上面的方面）。 123wx.cloud.init(&#123; env: 'test-x1dzi'&#125;) 云数据库云数据库是一个JSON数据库，数据库中的每条记录都是一个JSON格式的对象。 一个数据库可以有多个集合（相当于关系型数据库中的表），集合可以看作一个JSON数组，数组中的每个对象就是一条记录，记录的格式是JSON对象。 通过在云开发界面点击+创建新的集合： 数据库的API分为小程序端和服务端两个部分： 小程序端API：拥有严格的调用权限控制，开发者可在小程序内直接调用API进行非敏感数据的操作。 服务端：对于有更高安全要求的数据，可在云函数内通过服务端API进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全地操作数据库。 在微信原生项目中： 12345678910111213141516// 小程序端操作数据库// 云数据库const db = wx.cloud.database();// 向user集合添加数据db.collection('user').add(&#123; data: &#123; name: \"jerry\", age: \"22\" &#125; &#125;).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 1234567// 服务端操作数据库const cloud = require('wx-server-sdk');const db = cloud.database();// 然后再进行数据库操作// ... taro项目中： 1234567891011121314151617// 小程序端操作数据库const db = Taro.cloud.database();// 向user集合添加数据db.collection('user') .add(&#123; data: &#123; name: 'alice', age: '26', &#125;, &#125;) .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.error(err); &#125;); 12345678// 在云函数内// 云函数入口文件const cloud = require(\"wx-server-sdk\");const db = cloud.database();// 然后再进行数据库操作// ... 云函数云函数是一段运行在云端的代码，相当于服务端的代码，我们可以在云函数中操作数据库、管理云文件、调用其他云函数等操作。 云函数必须要进行部署才能生效，部署方式： 右键点击函数文件夹，选择上传并部署（云端安装依赖，不上传node_modules）。 如果遇到以下问题： 1cloudTest.weapp.jsx:86 Error: errCode: -404011 cloud function execution error | errMsg: cloud.callFunction:fail requestID 7ac9328a-579d-11eb-9459-5254006d699d, cloud function service error code -504002, error message Error: errCode: -1 unknown error | err 尝试重新上传并部署，过一会便生效了。 比如我们定义了一个add云函数： 1234567891011121314// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了可以通过 getWXContext 方法获取的用户登录态 `openId` 和小程序 `appId` 信息const cloud = require('wx-server-sdk')exports.main = async (event, context) =&gt; &#123; let &#123; userInfo, a, b&#125; = event let &#123; OPENID, APPID &#125; = cloud.getWXContext() // 这里获取到的 openId 和 appId 是可信的 let sum = a + b return &#123; OPENID, APPID, sum &#125;&#125; 在开发者工具中上传并部署云函数后，我们在小程序中可以使用callFunction方法调用： 12345678910111213141516171819wx.cloud.callFunction(&#123; // 需调用的云函数名 name: 'add', // 传给云函数的参数 data: &#123; a: 12, b: 19, &#125;, // 成功回调 complete: console.log&#125;)// 当然 promise 方式也是支持的wx.cloud.callFunction(&#123; name: 'add', data: &#123; a: 12, b: 19 &#125;&#125;).then(console.log) 本地调试云开发提供了云函数本地调试的功能，开发者可以在本地对云函数进行断点调试。 不使用本地调试和使用本地调试在调试流程上的区别： 不使用本地调试：本地修改代码 —&gt; 上传部署云函数 —&gt; 调用。 使用本地调试：本地修改 —&gt; 调用。无需上传等待的步骤。 如何进行本地调试？ 进行本地调试的云函数首先要执行cloud.init步骤，在其中指定云函数的环境： 123cloud.init(&#123; env: 'test-taro-1gs4sohn82c1ff34'&#125;); 如果云函数中有使用到npm模块，需在云函数本地目录安装相应依赖才可正常使用云函数本地调用功能。所以如果在开启本地调试的过程中，有相关的警告，则检查一下是否有安装依赖。 云函数中一般都会用到wx-server-sdk这个npm包，所以应该都要在本地调试之前安装依赖，否则会报错。 首先选中想要进行本地调试的云函数，右键选择开启云函数本地调试。 source目录下可以看到云函数对应的源代码，可以在代码里添加断点。 比如当前我测试的函数是batch，当我在小程序页面点击批量删除按钮时，调试便开启。我们可以控制怎么执行下一步来看整个函数执行的过程。也可以在console页看到相应的输出结果 云端测试除了本地调试以外，还能够执行云端测试，在云开发平台对云函数进行测试： 在其中输入参数，运行测试，可以在开发者工具的调试器中看到执行结果。 云存储简单来说： 云存储：提供存储能力，更多面对的场景是非结构化数据，如文件、图片、视频等。 云数据库：提供基础的数据库和数据对象管理能力，包括oracle、mysql、sql、server等关系型数据库，也可以包括类似mongodb、hbase等半结构化数据库。 所以，如果我们要上传一些图片的话，我们需要将其存储到云存储中，并在数据库中记录图片在云存储中的路径。之后想要展示这些图片时，便可以从数据库中找到记录，将图片展示出来。 云存储的API包括： uploadFile downloadFile deleteFile getTempFileURL 总结实践代码仓库地址：wechat-miniprogram-cloud","categories":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Taro入门及踩坑之旅","slug":"Taro入门及踩坑之旅","date":"2021-01-12T13:33:41.000Z","updated":"2021-01-13T10:51:22.478Z","comments":true,"path":"2021/01/12/Taro入门及踩坑之旅/","link":"","permalink":"http://delaprada.com/2021/01/12/Taro%E5%85%A5%E9%97%A8%E5%8F%8A%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/","excerpt":"","text":"前言因最近开始准备毕设，我的毕设是要做一个小程序，便开始了学习如何开发小程序之旅。 Taro是一个开放式跨端跨框架的解决方案，支持使用React/Vue/Nerv等框架来开发微信、京东、百度、支付宝、字节跳动、QQ小程序 / H5等应用。 所以，使用Taro的话，只需编写一套代码就能够拥有适配到多端的能力。Taro目前在github上 有27.9k个star，这也是我选择学习它的一个原因。（虽然整个做下来之后发现它的教程坑实在是多……） 那就开始吧。 官方文档：Taro官方文档 入门因为有一定前端开发经验，所以我直接从渐进式入门教程着手，通过实操一步步上手。 渐进式入门教程 渐进式入门教程源码 渐进式入门教程是使用Taro开发一个简单的V2EX论坛客户端，整个教程分为4个部分： 环境准备 基础教程 项目进阶与优化 多端开发 这里就展开一些教程中没有提到的点和总结其中比较关键的点。 环境准备使用Taro开发需要安装： Taro CLI Node.js Taro CLI安装指令： 1npm i -g @tarojs&#x2F;cli 安装完毕后在终端输入taro，如果出现类似内容说明安装成功： 123456789101112131415161718👽 Taro v3.0.0-beta.6Usage: taro &lt;command&gt; [options]Options: -V, --version output the version number -h, --help output usage informationCommands: init [projectName] Init a project with default templete config &lt;cmd&gt; Taro config create Create page for project build Build a project with options update Update packages of taro convert Convert weapp to taro info Diagnostics Taro env info doctor Diagnose taro project help [cmd] display help for [cmd] 基础教程组件在小程序中，组件分为页面组件和基础组件。页面组件就是那些可以通过路由跳转到指定页面的组件，具有生命周期，基础组件就是一些普通组件，不构成页面，是页面或者组件的一部分。 页面组件页面组件一般在pages文件夹下定义： 以thread_detail组件举例，该文件夹下有三个文件： index.css：样式文件 thread_detail.tsx：组件 thread_detail.config.ts：页面组件配置文件 配置文件主要是配置一些基础样式和文字，页面配置，比如： 1234backgroundTextStyle: &#39;light&#39;,navigationBarBackgroundColor: &#39;#fff&#39;,navigationBarTitleText: &#39;WeChat&#39;,navigationBarTextStyle: &#39;black&#39; 在thread_detail.config.ts中是这样： 123export default &#123; navigationBarTitleText: &#39;话题&#39;&#125; 这个配置文件是必须要写的，否则在项目打包编译就会报如下错误： 1Module not found: Can‘t resolve ‘.&#x2F;pages&#x2F;xxx&#x2F;xxx.config‘ in ‘xxxx‘ 这里要注意一下。 类组件： 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react'import &#123; View &#125; from '@tarojs/components'class Index extends Component &#123; // 可以使用所有的 React 组件方法 componentDidMount () &#123;&#125; // onLoad onLoad () &#123;&#125; // onReady onReady () &#123;&#125; // 对应 onShow componentDidShow () &#123;&#125; // 对应 onHide componentDidHide () &#123;&#125; // 对应 onPullDownRefresh，除了 componentDidShow/componentDidHide 之外， // 所有页面生命周期函数名都与小程序相对应 onPullDownRefresh () &#123;&#125; render () &#123; return ( &lt;View className='index' /&gt; ) &#125;&#125;export default Index 函数组件： 1234567891011121314151617181920212223242526272829303132import React, &#123; useEffect &#125; from 'react'import &#123; View &#125; from '@tarojs/components'import &#123; useReady, useDidShow, useDidHide, usePullDownRefresh&#125; from '@tarojs/taro'function Index () &#123; // 可以使用所有的 React Hooks useEffect(() =&gt; &#123;&#125;) // 对应 onReady useReady(() =&gt; &#123;&#125;) // 对应 onShow useDidShow(() =&gt; &#123;&#125;) // 对应 onHide useDidHide(() =&gt; &#123;&#125;) // Taro 对所有小程序页面生命周期都实现了对应的自定义 React Hooks 进行支持 // 详情可查阅：【Taro 文档】-&gt; 【进阶指南】-&gt;【Hooks】 usePullDownRefresh(() =&gt; &#123;&#125;) return ( &lt;View className='index' /&gt; )&#125;export default Index 基础组件基础组件一般在components文件夹下定义： 这里就不需要为每个组件设置配置文件。 入口配置app.config.ts就是入口配置文件，我们可以在其中配置页面路径列表、全局的默认窗口表现等属性。Taro的配置规范是基于微信小程序的全局配置进行规定的：微信小程序全局配置。 在V2EX项目中，全局配置为： 1234567891011121314151617181920212223242526272829303132333435363738// app.config.tsexport default &#123; pages: [ 'pages/index/index', 'pages/nodes/nodes', 'pages/hot/hot', 'pages/node_detail/node_detail', 'pages/thread_detail/thread_detail', ], tabBar: &#123; list: [&#123; 'iconPath': 'resource/latest.png', 'selectedIconPath': 'resource/lastest_on.png', pagePath: 'pages/index/index', text: '最新' &#125;, &#123; 'iconPath': 'resource/hotest.png', 'selectedIconPath': 'resource/hotest_on.png', pagePath: 'pages/hot/hot', text: '热门' &#125;, &#123; 'iconPath': 'resource/node.png', 'selectedIconPath': 'resource/node_on.png', pagePath: 'pages/nodes/nodes', text: '节点' &#125;], 'color': '#000', 'selectedColor': '#56abe4', 'backgroundColor': '#fff', 'borderStyle': 'white' &#125;, window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125;&#125; 路由路由跳转在Taro中，可以使用Taro的navigateTo方法进行路由跳转： 1Taro.navigateTo(&#123; url: '/pages/thread_detail/thread_detail' &#125;) 这个用法类似React中的props.history.push(&#39;/xxx&#39;)。 路由参数在页面组件中，可以通过 getCurrentInstance().router 或者Current.router?.params获取当前页面的路由参数： 1234import Taro, &#123; Current &#125; from '@tarojs/taro';// 在组件内const &#123; full_name &#125; = Current.router?.params; 生命周期React组件的生命周期方法和小程序的生命周期方法在Taro中均支持，但需要注意它们的触发时机和顺序。见官方文档：生命周期触发机制。 内置组件Taro中使用小程序规范的内置组件进行开发，如&lt;View /&gt;、&lt;Text /&gt;、&lt;Button /&gt;等，这些是跨平台组件。 在React中使用这些内置组件前，必须从@tarojs/components进行引入，组件的props遵从大驼峰式命名规范： 12// 小程序写法&lt;view hover-class='test' /&gt; 1234// Taro写法import &#123; View &#125; from '@tarojs/components'&lt;View hoverClass='test' /&gt; 事件在 Taro 中事件遵从小驼峰式（camelCase）命名规范，所有内置事件名以 on 开头。 在事件回调函数中，第一个参数是事件本身，回调中调用 stopPropagation 可以阻止冒泡。 1234567891011function Comp () &#123; function clickHandler (e) &#123; e.stopPropagation() // 阻止冒泡 &#125; function scrollHandler () &#123;&#125; // 只有小程序的 bindtap 对应 Taro 的 onClick // 其余小程序事件名把 bind 换成 on 即是 Taro 事件名（支付宝小程序除外，它的事件就是以 on 开头） return &lt;ScrollView onClick=&#123;clickHandler&#125; onScroll=&#123;scrollHandler&#125; /&gt;&#125; 项目进阶与优化项目在开发完毕之后，我们想要看项目的效果是怎么样的，要怎么做呢？当时我很疑惑，于是找了Taro官方的一个5分钟上手小程序的视频来看，便找到了答案。 首先，先打包编译。使用Taro CLI生成的项目，在package.json中已经配置好了各种小程序的打包编译指令： 比如，我想打包微信小程序，则在终端输入： 1npm run dev:weapp 调试的话就执行npm run dev，打包构建到生产环境则执行npm run build。 如果想要多端编译，在config文件夹下的index.js里修改outputRoot属性： 1outputRoot: `dist/$&#123;process.env.TARO_ENV&#125;` 这样的话，各个端打包好的文件就可以同时存放在dist文件夹内，比如微信小程序的路径是dist/weapp，h5的路径是dist/h5。 然后，打开微信开发者工具，导入打包编译好的项目，就有效果啦： 但此时，我的项目遇到了一个bug，在微信开发者工具中报错了： 当时没有仔细看报错信息，其实第二行Thread.render中点击进去有提示报错位置。心想：这没法调试。。。也没办法console.log。（实际上是可以的）。 于是便想，那是不是可以打包成h5，在浏览器里调试，这样不就和平时的前端开发一样了么！于是便转向了另一个方向。但是在浏览器端，会有跨域问题，localhost向https://www.v2ex.com/api/发起请求是违反了浏览器的同源策略。小程序开发工具并没有同源策略的限制，于是不会有这个问题。 Taro h5 跨域问题解决首先，要在config/dev.js中添加h5配置： 12345678910111213h5: &#123; devServer: &#123; proxy: &#123; '/api/': &#123; target: \"https://www.v2ex.com\", changeOrigin: true // pathRewrite: &#123; // '^/api/': '/' // &#125;, &#125; &#125; &#125;&#125; 其中的配置就是webpack的devServer的配置，详情可参考博客：devServer之proxy跨域 第二步，修改api.ts里的HOST： 1234const HOST_URI = 'https://www.v2ex.com/api/'// 修改为const HOST_URI = '/api/' 为什么要这么改呢？因为在proxy中，我们会检查请求的开头是否为/api/，如果是以http开头，则检查不匹配，不走代理，跨域失效。所以去掉前面的http部分，相当于遇到/api/才做代理，则会把默认域名http://localhost:xxxx改成target，也就是https://www.v2ex.com地址。不过在浏览器F12下，Network-&gt;Headers中看到的还是http://localhost:xxxx/api/xxx，但是真正的请求地址为：https://www.v2ex.com/api/xxx。 需要添加pathRewrite属性的场景是：相当于遇见/api/才做代理，但真实的请求中没有/api/，所以在pathRewrite中把/api/去掉, 这样既有了标识, 又能在请求接口中把/api/去掉。 运行npm run dev:h5，可以在浏览器端查看到效果： 最后问题是由于将生命周期函数componentWillMount写成componentWillUnmount导致的，找了好久，以至于想锤死自己。 不过React已经不建议使用componentWillMount这个生命周期函数了，所以我们应该将数据获取放在componentDidMount中： 12345async componentDidMount() &#123; this.setState(&#123; thread: this.props.thread &#125;)&#125; 渲染时加一层判断： 12345678910111213// 组件内// 在加载到thread的数据后再渲染，防止出现property of undefined的报错const attrLen = Object.keys(thread).length;&#123;attrLen ? &lt;Thread node=&#123;thread.node&#125; title=&#123;thread.title&#125; last_modified=&#123;thread.last_modified&#125; replies=&#123;thread.replies&#125; tid=&#123;thread.id&#125; member=&#123;thread.member&#125; not_navi=&#123;true&#125;/&gt; : null&#125; 其实微信开发者工具也有完善的调试器，能够看到console.log等的结果，所以我们直接在vscode中修改代码，ctrl s之后，就能够在微信开发者工具中看到相应的渲染结果，也可以通过看console来调试。不过微信开发者工具似乎不能够使用Redux的调试工具，这个之后再研究研究。 后续用hooks对这个demo进行重构，代码仓库：taro-mini-program。 学习资料Taro学习优秀资源：awesome-taro","categories":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Redux源码解析","slug":"Redux源码解析","date":"2021-01-09T08:39:54.000Z","updated":"2021-01-09T08:44:52.348Z","comments":true,"path":"2021/01/09/Redux源码解析/","link":"","permalink":"http://delaprada.com/2021/01/09/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Redux源码解析在使用Redux的时候，我们会觉得很方便，因为很多事情Redux会帮我们完成，在内部运作，不需要我们手动去做，比如我们调用dispatch方法的时候，Redux自动就会帮我们执行reduce方法，更新state。所以本文就来拆解一些Redux在背后为我们做的事情，主要分为以下几部分： createStore发生了什么? dispatch执行后在内部怎么运行的？ compose函数做了什么事情？ combineReducers是如何合并不同的reducer的？ applyMiddleware是如何组织中间件的？ createStorecreateStore是要见一个store仓库，是redux的核心所在，它最后要返回四个非常重要的属性，分别是： getState subscribe dispatch replaceReducer 123456789export default function createStore (reducer, preloadedState, enhancer) &#123;//...return &#123; getState,// 获取到 state subscribe,// 采用发布订阅模式，这个方法进行观察者的订阅 dispatch,// 派发 action replaceReducer// 用新的 reducer 替换现在的 &#125;&#125; 首先第一步是检查参数，一共可以接受3个参数，分别是reducer（改变store的纯函数），preloadedState（初始状态），enhancer（中间件相关）。 12345678910111213141516export default function createStore (reducer, preloadedState, enhancer) &#123; //reducer 必须是函数 // 当前 reducer let currentReducer = reducer //state 数据，redux 的根本 let currentState = preloadedState // 订阅者集合 let currentListeners = [] // 虽然不起眼，但是是一个关键的设计 let nextListeners = currentListeners // 是否正在有 dispatch 在运行 let isDispatching = false //... //return 代码&#125; createStore的getState方法： 12345function getState () &#123; // 如果有 dispatch 正在执行则报错 if (isDispatching) throw new Error (\"xxxx 具体信息省略\") return currentState&#125; createStore的subscribe方法： 为了避免发生问题，我们会缓存最开始的数组currentListeners，在调用订阅者的时候，一切关于currentListeners的改变都不允许，但是可以拷贝一份同样的数组，让它来承担订阅者对数组的改变，这个数组就是nextListeners。 123456789101112131415161718192021222324252627282930function ensureCanMutateNextListeners () &#123; // 如果 next 和 current 数组是一个引用，那这种情况是危险的，原因上面已经谈到，我们需要 next 和 current 保持各自独立 if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice () &#125;&#125;function subscribe (listener) &#123; if (typeof listener !== 'function') &#123; throw new Error ('Expected the listener to be a function.') &#125; // 如果正在有 dispatch 执行则报错 if (isDispatching) &#123; throw new Error (\"xxx\") &#125; let isSubscribed = true ensureCanMutateNextListeners () nextListeners.push (listener) // 返回的是一个退订的方法，将特定的 listener 从订阅者集合中删除 return function unsubscribe () &#123; // 已经退订了就不管了 if (!isSubscribed) return; if (isDispatching) throw new Error (\"xxx 具体信息省略\") isSubscribed = false ensureCanMutateNextListeners () const index = nextListeners.indexOf (listener) nextListeners.splice (index, 1) &#125;&#125; subscribe方法用于添加订阅者Listener，返回的函数unsubscirbe方法用于退订某个订阅者。 每次调用这个subscribe函数时，都会产生一个闭包，里面存储着isSubscribed的值，调用n次就会产生n个这样的闭包，用来存储n个不同的订阅情况。 createStore的dispatch函数： 12345678910111213141516171819202122232425function dispatch (action) &#123;//action 必须是一个对象//action.type 不能为 undefinedif (isDispatching) &#123; throw new Error ('Reducers may not dispatch actions.')&#125;try &#123; isDispatching = true // 看到没有？执行 reducer 后返回的状态直接成为 currentState 了 currentState = currentReducer (currentState, action) &#125; finally &#123; isDispatching = false &#125;// 将nextListeners赋值给currentListenersconst listeners = (currentListeners = nextListeners)for (let i = 0; i &lt; listeners.length; i++) &#123; // store发生变化则调用每个订阅者 const listener = listeners [i] listener ()&#125;return action&#125; createStore的replaceReducer函数： 12345678910function replaceReducer (nextReducer) &#123; if (typeof nextReducer !&#x3D;&#x3D; &#39;function&#39;) &#123; throw new Error (&#39;Expected the nextReducer to be a function.&#39;) &#125; currentReducer &#x3D; nextReducer &#x2F;&#x2F; 此时无法匹配任何的 action，但是返回的状态可以将 currentState 给更新 &#x2F;&#x2F; 也就是更新当前的 state，因为 reducer 更新了，老的 state 该换了！ dispatch (&#123; type: ActionTypes.REPLACE &#125;)&#125; combineReducer在之前的Redux及其中间件解析文章中也有提到，combineReducers方法的作用将所有子reducer合并为一个大reducer，根据action的不同返回新的state： 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123;return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 其源码如下： 12345678910111213141516171819202122232425262728293031323334export default function combineReducers (reducers) &#123; // 以项目中的例子来讲，reducerKeys 就是 ['recommend', 'singers'] const reducerKeys = Object.keys (reducers) //finalReducers 是 reducers 过滤后的结果 // 确保 finalReducers 里面每一个键对应的值都是函数 const finalReducers = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys [i] if (typeof reducers [key] === 'function') &#123; finalReducers [key] = reducers [key] &#125; &#125; const finalReducerKeys = Object.keys (finalReducers) // 最后依然返回一个纯函数 return function combination (state = &#123;&#125;, action) &#123; // 这个标志位记录初始的 state 是否和经过 reducer 后是一个引用，如果不是则 state 被改变了 let hasChanged = false const nextState = &#123;&#125; for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys [i] const reducer = finalReducers [key] // 原来的状态树中 key 对应的值 const previousStateForKey = state [key] // 调用 reducer 函数，获得该 key 值对应的新状态 const nextStateForKey = reducer (previousStateForKey, action) nextState [key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; // 这个很简单理解吧？如果没改变直接把原始的 state 返回即可 return hasChanged ? nextState : state &#125;&#125; compose函数compose是一个工具，充分体现高阶函数的技巧。源码如下： 12345678910export default function compose (...funcs) &#123;if (funcs.length === 0) &#123; return arg =&gt; arg&#125;if (funcs.length === 1) &#123; return funcs [0]&#125; return funcs.reduce ((a, b) =&gt; (...args) =&gt; a (b (...args)))&#125; 比如： 12345const f0 = (x) =&gt; &#123; console.log (x) &#125;const f1 = () =&gt; &#123; console.log (1) &#125;const f2 = () =&gt; &#123; console.log (2) &#125;let fArr = [f2, f1, f0];console.log (compose (...fArr)(100)) // 执行 f2 (f1 (f0 (100))) 输出 100 1 2 compose函数一般用于组合所有的enhancer，作为第三个参数传入createStore方法。createStore方法的结构如下： 1createStore(reducer, [preloadedState], [enhancer]) 第三个可选参数enhancer指的是store enhancer，也就是store的增强器，用于增强store的功能。一个store enhancer，实际上是一个高阶函数（compose也是一个高阶函数），它的参数是创建store的函数（store creator），返回值是一个可以创建功能更强大的store的函数（enhanced store creator），这和React中的高阶组件的概念很相似。 store enhancer函数的结构一般如下： 123456function enhancerCreator() &#123; return createStore =&gt; (...args) =&gt; &#123; // do something based on old store // return a new enhanced store &#125;&#125; 需要注意的是，enhancerCreator是用于创建store enhancer的函数，也就是说，enhancerCreator的调用结果才是一个store enhancer。(…args)参数代表穿件store所需要的参数，也就是createStore接收的参数，实际上就是(reducer, [preloadedState], [enhancer])。 可以这么理解，因为要创建一个功能更加强大的store，所以需要传入创建store所需要的参数。 比如，现在我们想创建一个store enhancer，用于输出发送的action的信息和state的变化： 123456789101112131415// autoLogger.js// store enhancerexport default function autoLogger() &#123; return createStore =&gt; (reducer, initialState, enhancer) =&gt; &#123; const store = createStore(reducer, initialState, enhancer) function dispatch(action) &#123; console.log(`dispatch an action: $&#123;JSON.stringify(action)&#125;`); const res = store.dispatch(action); const newState = store.getState(); console.log(`current state: $&#123;JSON.stringify(newState)&#125;`); return res; &#125; return &#123;...store, dispatch&#125; &#125;&#125; autoLogger声明了一个新的dispatch方法，在原本的store.dispatch方法基础上添加了两个输出日志，然后返回一个新的store（{…store, dispatch}）。当我们调用dispatch方法时，实际是调用了autoLogger方法中新声明的dispatch，因为上面对象最后一个dispatch覆盖了store中的dispatch。 其中createStore的部分源码如下： 12345678910111213141516export default function createStore (reducer, preloadedState, enhancer) &#123; // 第二个参数为函数，但是第三个参数没传 if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState// 将第二个参数当做 enhancer preloadedState = undefined &#125; // 确保 enhancer 为函数 if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error ('Expected the enhancer to be a function.') &#125; return enhancer (createStore)(reducer, preloadedState) &#125; //...&#125; 如何使用这个store enhancer？ 123456789// configureStore.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import rootReducer from 'path/to/reducers';import autLogger from 'path/to/autoLogger';const store = createStore( reducer， autoLogger()); applyMiddlewareapplyMiddleware本身就是一个store enhancer，结构和上面的autoLogger很像，applyMiddleware的源码如下： 1234567891011121314151617181920212223242526export default function applyMiddleware (...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore (...args) let dispatch = () =&gt; &#123; throw new Error ( 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.' ) &#125; //middlewareAPI 其实就是拿到 store 的信息 const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch (...args) &#125; // 参考上面的 thunk，其实就是传入 store 参数，剩下的部分为 next =&gt; action =&gt; &#123; ... &#125;; // 传入这个参数是必须的，因为需要拿到 store 的相关属性，如 thunk 拿了 getState // 这里的意思就是每个中间件都能拿到 store 的数据 const chain = middlewares.map (middleware =&gt; middleware (middlewareAPI)) dispatch = compose (...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 比如我们在调用applyMiddleware(thunk, logger)，走到compose逻辑的时候，相当于调用thunk(logger(store.dispatch))。 无论是applyMiddleware中使用compose组合所有中间件还是使用compose来组合所有的enhancer，在经过compose组合之后，所有的middleware或store enhancer都会形成一个洋葱模型。compose中的第一个enhancer（或middleware）处于洋葱模型的最外层，最后一个enhancer处于洋葱模型的最里层，经过层层调用形成一个更强大的store： applyMiddleware(…middlewares)将middleware限制为只可以增强store dispatch的功能，但这只是它自身的规范限制，对于其他store enhancer，你可以增强store中包含的任意方法的功能，如dispatch、subscribe、getState、replaceReducer等。毕竟，store只是一个包含一些函数的普通JavaScript对象，可以很容易的复制其中的方法，并增加新的功能。 参考Redux及中间件原理解析 浅析Redux的store enhancer","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"React-Redux及中间件解析","slug":"React-Redux及中间件解析","date":"2021-01-07T07:55:48.000Z","updated":"2021-01-07T10:17:18.302Z","comments":true,"path":"2021/01/07/React-Redux及中间件解析/","link":"","permalink":"http://delaprada.com/2021/01/07/React-Redux%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90/","excerpt":"","text":"为什么需要ReduxReact知识DOM的一个抽象层，并不是Web应用的完整解决方案。有两个方面它没有涉及： 代码结构 组件之间的通信 对于大型的复杂应用来说，这两方面是很关键的，因此只有React没有办法写大型应用。 但Redux并不是非用不可。如果你的UI层非常简单，没有很多互动，Redux就是不必要的，用了反而会增加复杂性。 以下这些情况都不需要使用Redux： 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用WebSocket 视图层（view）只从单一来源获取数据 Redux适用的场景是：多交互、多数据源 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 从组件的角度看，如果你的应用有以下场景，可以考虑使用Redux： 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 Redux的设计思想 Web应用是一个状态机，视图和状态是一一对应的。 所有的状态，都保存在一个对象（Store）里。 基本概念StoreStore是保存数据的地方，可看作一个容器。整个应用只能有一个store，一般用createStore这个方法来生成Store。 123import &#123; createStore &#125; from 'redux';const store = createStore(reducer, preloadedState, enhancer); store三个参数的含义： reducer：改变store数据的纯函数 preloadedState：初始状态 enhancer：中间件相关 StateStore对象包含所有数据。如果想得到某个时间节点的数据，就要对Store生成快照。这种时间节点的数据集合，就叫做State。 当前时刻的State，可以通过store.getState()拿到： 1const state = store.getState(); 一个State对应一个View。只要State相同，View就相同。 ActionState变化 =&gt;(导致) View变化。但是，用户接触不到State，只能接触到View。所以State的变化也是由View导致的。Action就是用户通过View发出的通知，表示State应该要发生变化了。 Action是一个对象，其中type属性是必须的： 1234const action =&#123; type: 'ADD_TODO', // Action的名称 payload: 'Learn Redux' // 携带的字符串信息&#125;; payload属性名可以是任意其他名称，比如data等。之后reducer就根据action.属性名来获取数据，比如action.payload，action.data。 Action CreatorView要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦。可以定义一个函数来生成Action，这个函数就叫Action Creator。 12345678910const ADD_TODO = '添加 TODO';functionaddTodo(text)&#123; return &#123; type: ADD_TODO, text &#125;&#125;const action = addTodo('Learn Redux'); addTodo函数就是一个Action Creator。 store.dispatch()store.dispatch()是View发出Action的唯一方法。 store.dispatch可接受一个Action对象作为参数，将它发送出去： 1234store.dispatch(&#123; type:'ADD_TODO', payload:'Learn Redux'&#125;); 也可以结合Action Creator（调用函数返回一个Action对象）： 1store.dispatch(addTodo('Learn Redux')); ReducerStore收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。 Reducer是一个函数，它接受当前State和Action作为参数，返回一个新的State。整个应用的初始状态，可以作为State的默认值： 123456789101112131415const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123;switch (action.type) &#123;case 'ADD':return state + action.payload;default: return state; &#125;&#125;;const state = reducer(1, &#123;type: 'ADD',payload: 2&#125;); reducer函数收到名为ADD的Action以后，就返回一个新的State，作为加法的计算结果。 实际应用中，Reducer函数不用像上面这样手动调用，store.dispatch方法会触发Reducer的自动执行。为此，Store需要知道Reducer函数，做法就是在生成store的时候，将Reducer传入createStore。以后每当store.dispatch发送过来一个新的Action，就会自动调用Reducer，得到新的State。 为什么这个函数要叫Reducer？因为它可以作为数组的reduce方法的参数： 123456789101112131415161718export default (state = defaultState, action) =&gt; &#123; switch(action.type) &#123; case actionTypes.CHANGE_CURRENT_ALBUM: return state.set('currentAlbum', action.data); case actionTypes.CHANGE_ENTER_LOADING: return state.set('enterLoading', action.data); default: return state; &#125;&#125;;const actions = [ &#123; type: 'ADD', payload: 0 &#125;, &#123; type: 'ADD', payload: 1 &#125;, &#123; type: 'ADD', payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 js数组api reduce方法解析： JS中 reduce() 的用法 reduce mdn官方文档 一些需要熟记的点： reduce的第一个参数为reducer函数，可传入4个参数，分别是prev、cur、index、arr，根据英文大致能猜出它的意思。prev表示上一次调用的返回值或者初始值，cur表示当前正在处理的数组元素，index表示当前正在处理的数组元素的索引（若提供init值，则索引为0，否则索引为1，因为init值不算作数组元素），arr表示原数组 reduce的第二个参数为初始值 123arr.reduce(function(prev,cur,index,arr)&#123;...&#125;, init); 因为redux中的reducer函数与reduce方法的第一个参数reducer函数的结构和用途类似，所以称之为reducer（把state看作prev，action看作cur，返回的也是一个新的状态，下一次dispatch action的时候，会根据上一次的状态来更新或者说累加）。 纯函数Reducer函数最重要的特征是：它是一个纯函数，即只要是同样的输入，必定得到同样的输出。 并且它需要遵守以下一些约束： 不得改写参数 不能调用系统I/O的API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 因此，Reducer函数里面不能改变State，必须返回一个全新的对象： 1234567891011// State 是一个对象function reducer(state, action) &#123;return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;);// 或者return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123;return [...state, newItem];&#125; store.subscribe()Store允许使用store.subscribe方法设置监听函数，一旦State发生变化，就自动执行这个函数。 1store.subscribe(listener); store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 1234let unsubscribe = store.subscribe(()=&gt; console.log(store.getState()));unsubscribe(); Store的实现Store提供了三个方法： store.getState() store.dispatch() store.subscribe() 下面是createStore方法的一个简单实现： 12345678910111213141516171819202122const createStore = (reducer) =&gt; &#123;let state;let listeners = []; const getState = () =&gt; state; // getState方法 const dispatch = (action) =&gt; &#123; // dispatch方法 state = reducer(state, action);\b listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; // subscribe方法 listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; Reducer的拆分Reducer函数如果不进行拆分的话，会变得十分庞大。Reducer需要根据所有组件的action进行处理，代码的可读性也会变得很糟糕。 Redux提供了一个combineReducers方法，用于Reducer的拆分。你只要定义各个子Reducer函数，然后用这个方法，将它们合成一个大的Reducer。 12345678910import &#123; combineReducers &#125; from 'redux';import &#123; reducer as chatLogReducer &#125; from '../application/ChatLog/store/index';import &#123; reducer as statusMessageReducer &#125; from '../application/StatusMessage/store/index';import &#123; reducer as userNameReducer &#125; from '../application/userName/store/index';const chatReducer = combineReducers(&#123; chatLog: chatLogReducer, statusMessage: statusMessageReducer, userName: userNameReducer,&#125;)； combineReducers方法的用法： 12345678910const reducer = combineReducers(&#123; state属性名: 对应的Reducer,&#125;)// 等同于const reducer = (state = &#123;&#125;, action) =&gt; &#123; return &#123; state属性名: 调用对应的Reducer, &#125;&#125; 返回的是合并后的reducer，之后直接将这个合并后的reducer作为参数传入createStore方法中。 例如（注意其中的区别，原生实现中是要调用函数，返回对象）： 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123;return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 工作流程 （注意Action Creators到Reducers之间是虚线，因为是Store自动调用reducer来改变state，所以是虚线，这里的画法体现了这一思路。） 首先，用户发出Action。 1store.dispatch(action); Store自动调用Reducer，并传入两个参数：当前State和收到的Action。Reducer会返回新的State。 State一旦有变化，Store就会调用监听函数 12// 设置监听函数store.subscribe(listener); Redux中间件与异步操作我们已经了解到Redux的基本做法：用户发出Action，Reducer函数算出新的State，View重新渲染。 但如果涉及到异步操作，则需要用到新的工具：中间件。 同步与异步的区别是什么？Action发出以后，Reducer立即算出State，这叫同步。Action发出后，过一段时间再执行Reducer，这就是异步。 中间件的概念中间件其实就是一个函数，对store.dispatch方法进行了改造，在发出Action和执行Reducer这两步之间，添加了其他功能。 比如我们要添加日志功能，把Action和State打印出来，可以对store.dispatch进行改造： 123456let next = store.dispatch;store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); next(action); console.log('next state', store.getState());&#125; 以上就是中间件的雏形。 为什么不在其他环节添加这种功能？ Reducer：纯函数，只承担计算State的功能，不适合承担其他功能，因为纯函数不能进行读写操作。 View：与State一一对应，可看作是State的视觉层，也不适合承担其他功能。 Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。 中间件的用法常用的中间件都有现成的，只要引用别人写好的模块即可。比如上面的日志中间件，就有现成的redux-logger模块。 12345678import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger(); // 生成日志中间件loggerconst store = createStore( reducer, applyMiddleware(logger)); 两点需要注意： createStore方法可接受整个应用的初始状态作为参数，在这种情况下applyMiddleware就是第三个参数： 12345const store = createStore( reducer, initial_state, applyMiddleware(logger)); 中间件的次序有讲究 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); applyMiddlewares()applyMiddlewares是Redux的原生方法，作用是将所有中间件组成一个数组，依次执行。其源码为： 1234567891011121314151617export default function applyMiddleware(...middlewares) &#123;return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125;; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123;...store, dispatch&#125; &#125;&#125; 可以看到其中的middlewareAPI，里面有getState和dispatch方法，这也是为什么异步的action creator返回的函数的参数就是dispatch和getState。 异步操作的基本思路同步操作只要发出一种Action即可，异步操作的差别是它要发出三种Action（可能但不是必须）： 操作发起时的Action 操作成功时的Action 操作失败时的Action 所以整个异步思路就是： 操作开始时，dispatch一个action，触发State更新为“正在操作”状态，View重新渲染 操作结束时，再送出一个action，触发State更新为“操作结束”状态，View再一次重新渲染 结合实际开发，比如组件中有个Loading组件，一般是在开始渲染页面时展示这个Loading组件，在数据加载完成之后，Loading组件消失。 所以在开始渲染页面时，先dispatch一个action，将与展示Loading组件相关的数据（比如show）设为true，在异步数据获取完成后，再dispatch一个action，将show设置为false。 redux-thunk中间件实现异步操作结束后系统自动送出第二个Action的关键，在Action Creator之中。 来看一个获取专辑列表的异步请求操作： 1234567891011121314151617export const getAlbumList = (id) =&gt; &#123; return (dispatch, getState) =&gt; &#123; getAlbumDetailRequest(id).then(res =&gt; &#123; let data = res.playlist; // 操作结束 dispatch(changeCurrentAlbum(data)); dispatch(changeEnterLoading(false)); &#125;).catch(() =&gt; &#123; console.log(\"获取album数据失败！\"); &#125;); &#125;&#125;// 使用方法// 操作开始dispatch(changeEnterLoading(true));dispatch(getAlbumList(id)); 上面的代码，有几个地方需要注意： getAlbumList是一个Action Creator，返回一个函数（和普通的Action Creator不同，普通的Action Creator返回一个对象）。 getAlbumList函数所返回的函数的参数是dispatch和getState这两个Redux方法，而普通的Action Creator的参数是Action的内容。 因为正常情况下，store.dispatch方法的参数只能是对象，不能是函数，所以就要使用redux-thunk（是因为需要满足这样的Action Creator，以内容作为参数，和普通的Action Creator一样，但是返回一个函数，以dispatch和getState作为参数，这样在异步请求完成之后才能再dispatch action，更新State，表示操作结束，所以才有redux-thunk）。 123456789import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); 上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。 因此，异步操作的第一种解决方案就是： 写出一个返回函数的Action Creator 使用redux-thunk中间件改造store.dispatch React-Redux的用法UI组件React-Redux将所有组件分成两大类：UI组件和容器组件。 UI组件有以下几个特征： 只负责UI的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何Redux的API 例如： 1const Title = value =&gt;&lt;h1&gt;&#123;value&#125;&lt;/h1&gt;; 因为不含有状态，UI组件又称为“纯组件”，即它像纯函数一样，纯粹由参数决定它的值。 容器组件容器组件的特征则相反： 负责管理数据和业务逻辑，不负责UI的呈现 带有内部状态 使用Redux的API 也就是：UI组件负责UI的呈现，容器组件负责管理数据和逻辑。 如果 一个组件既有UI又有业务逻辑怎么办？在这种情况下需要将它进行拆分，外面是一个容器组件，里面包含一个UI组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。 React-Redux规定，所有的UI组件都由用户提供，容器组件则是React-Redux自动生成（通过connect）。 connectReact-Redux提供connect方法，用于从UI组件生成容器组件。 容器组件需要有业务逻辑才是有意义的，所以为了定义业务逻辑，需要给出下面两方面的信息： 输入逻辑（mapStateToProps）：外部的数据（即state对象）如何转换为UI组件的参数。 输出逻辑（mapDispatchToProps）：用户发出的动作如何变为Action对象，从UI组件传出去。 connect方法的完整API为： 1234567import &#123; connect &#125; from 'react-redux'// TodoList为UI组件const VisibleTodoList = connect(mapStateToProps,mapDispatchToProps)(TodoList) mapStateToProps()mapStateToProps是一个函数，接受state作为参数，返回一个对象： 12345const mapStateToProps = (state) =&gt; (&#123; currentAlbum: state.getIn([\"album\", \"currentAlbum\"]), enterLoading: state.getIn([\"album\", \"enterLoading\"]), songsCount: state.getIn([\"player\", \"playList\"]).size,&#125;); mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。 mapDispatchToProps()mapDispatchToProps是connect函数的第二个参数，用来建立UI组件的参数（props）到store.dispatch方法的映射。它定义了哪些用户的操作应该当做Action，传给Store。 12345678const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; getAlbumDataDispatch(id) &#123; dispatch(changeEnterLoading(true)); dispatch(getAlbumList(id)); &#125;, &#125;;&#125;; 组件内部就可以通过以下方式获取数据和方法： 123456const &#123; currentAlbum, enterLoading, songsCount, &#125; = props;const &#123; getAlbumDataDispatch &#125; = props; export组件的时候需要用connect包裹： 1export default connect(mapStateToProps, mapDispatchToProps)(React.memo(Album)); Provider组件connect方法生成组件以后，需要让容器组件拿到state对象（比如mapStateToProps的参数state），才能生成UI组件的参数。 React-Redux提供Provider组件，可以让容器组件拿到state。 123456789101112131415161718192021// App.jsimport React from 'react';import &#123; Provider &#125; from 'react-redux';import &#123; renderRoutes &#125; from 'react-router-config';import routes from './routes/index.js';import &#123; HashRouter &#125; from 'react-router-dom';import store from './store/index';function App() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;HashRouter&gt; &lt;div className=\"App\"&gt; &#123;renderRoutes(routes)&#125; &lt;/div&gt; &lt;/HashRouter&gt; &lt;/Provider&gt; );&#125;export default App; 123456789101112// store/index.jsimport &#123; createStore, compose, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';import reducer from './reducer';const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers(// 用于异步操作，使得dispatch能够接受函数作为参数，自动发出第二个actionapplyMiddleware(thunk)));export default store; Provider在根组件外包了一层，这样一来，App的所有子组件就默认都能拿到state。 它的原理是React组件的context属性，可以看context笔记。","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"pm2安装与使用","slug":"pm2安装与使用","date":"2021-01-03T02:14:37.000Z","updated":"2021-01-03T02:46:14.963Z","comments":true,"path":"2021/01/03/pm2安装与使用/","link":"","permalink":"http://delaprada.com/2021/01/03/pm2%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"我们在启动一个server.js时一般会使用指令： 1node server.js 但是在终端关闭之后，服务就会停止了。所以此时可以利用PM2管理工具，安装后执行执行： 1pm2 start ./server.js 此时关闭终端服务也不会停止。下面就介绍一下这个工具。 什么是PM2PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，例如性能监控、自动重启、负载均衡等，而且使用起来非常简单。 安装123npm install pm2@latest -goryarn global add pm2 启动一个app1pm2 start app.js 同时也可以轻松地启动其他应用： 123pm2 start bashscript.shpm2 start python-app.py --watchpm2 start binary-file -- --port 1520 一些可以传入cli的参数： 1234567891011121314151617181920212223242526272829# Specify an app name--name &lt;app_name&gt;# Watch and Restart app when files change--watch# Set memory threshold for app reload--max-memory-restart &lt;200MB&gt;# Specify log file--log &lt;log_path&gt;# Pass extra arguments to the script-- arg1 arg2 arg3# Delay between automatic restarts--restart-delay &lt;delay in ms&gt;# Prefix logs with time--time# Do not auto restart app--no-autorestart# Specify cron for forced restart--cron &lt;cron_pattern&gt;# Attach to application log--no-daemon 管理进程重启： 1pm2 restart app_name 0秒停机重载进程： 1pm2 reload app_name 停止进程： 1pm2 stop app_name 删除进程： 1pm2 stop app_name 除了app_name以外，我们还可以传入： all：对所有进程执行该操作 id：对id对应的进程执行该操作 查看进程状态： 1pm2 list 环境配置声明PM2可以让使用者管理工作流。它可以让你通过一个进程文件来调整你的行为、选择、环境变量、每个应用的日志文件。对于微服务应用来说是最有用的。 配置文件支持js、JSON、YAML格式。 生成配置文件生成一个进程文件模板： 1pm2 ecosystem 执行指令后会生成一个模板ecosystem.config.js： 123456789101112module.exports = &#123; apps : [&#123; name: \"app\", script: \"./app.js\", env: &#123; NODE_ENV: \"development\", &#125;, env_production: &#123; NODE_ENV: \"production\", &#125; &#125;]&#125; 当你编辑完这个文件之后可以通过cli重新执行该文件： 1pm2 [start|restart|stop|delete] ecosystem.config.js 在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。 对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过env_xx来声明不同环境的配置，然后在启动应用时，通过--env参数指定运行的环境。 在配置文件中，通过env选项声明多个环境配置： env为默认的环境配置（生产环境），env_dev、env_test则分别是开发环境和测试环境。可以看到，不同环境下的NODE_ENV、REMOTE_ADDR字段的值是不同的。 在应用中，可以通过process.env.REMOTE_ADDR等来读取配置中生命的变量。 1234567891011121314\"env\": &#123; \"NODE_ENV\": \"production\", \"REMOTE_ADDR\": \"http://www.example.com/\" &#125;, \"env_dev\": &#123; \"NODE_ENV\": \"development\", \"REMOTE_ADDR\": \"http://wdev.example.com/\" &#125;, \"env_test\": &#123; \"NODE_ENV\": \"test\", \"REMOTE_ADDR\": \"http://wtest.example.com/\" &#125; 启动时指明环境假设通过下面启动脚本（开发环境），那么，此时process.env.REMOTE_ADDR的值就是相应的 http://wdev.example.com/ ，可以自己试验下。 1pm2 start app.js --env dev 负载均衡命令如下，表示开启三个进程。如果传参为-i max，则会根据机器当前核数自动开启尽可能多的进程。 12pm2 start app.js -i 3pm2 start app.js -i max 日志查看除了可以打开日志文件查看日志外，还可以通过pm2 logs来查看实时日志。这点对于线上问题排查非常重要。 比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。 1pm2 logs","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"useRef vs useState: 我们是否需要重渲染","slug":"useRef-vs-useState-我们是否需要重渲染","date":"2020-12-28T01:40:47.000Z","updated":"2020-12-28T02:48:32.275Z","comments":true,"path":"2020/12/28/useRef-vs-useState-我们是否需要重渲染/","link":"","permalink":"http://delaprada.com/2020/12/28/useRef-vs-useState-%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%87%8D%E6%B8%B2%E6%9F%93/","excerpt":"","text":"TL;DR（Too Long, Don’t Read） useState会导致re-render；useRef不会 useState和useRef在重渲染后都会记住它们之前的值 开始学习React并不难，难点在于理解React的生命周期以及re-render。在hook这些新的api出现之后，我们脑海中会产生更多关于React的re-render（即虚拟DOM是在什么时候怎么样进行协调reconciliation的）的问题。 Reconciliation（协调）是指仅在DOM树的diff发生变化时进行重渲染。 我们为什么需要知道什么时候进行重渲染： re-render是基于最新的变化（latest changes）来更新UI层 re-render导致DOM树协调是影响性能（performance factor）的一大因素 什么导致re-renderReact的re-render给我们展示了，我们通过事件（events）、请求（requests）、定时器（timers）等方式对数据层做出的改变。但它们并不是真正的触发者（triggers）——state的改变才是真正的触发者（触发re-render）。这个是合理的，因为事件、请求最终都是通过更新state来触发re-render。 当组件是嵌套着的时候，我们便很难准确判断state改变是怎么触发UI层的变化的。这也是经常困惑新手的点。 123456789101112function App() &#123; const [value, setValue] = React.useState(\"\"); const handleInputChange = e =&gt; &#123; setValue(e.target.value); &#125;; return ( &lt;div className=\"App\"&gt; &lt;Input value=&#123;value&#125; onChange=&#123;handleInputChange&#125; /&gt; &lt;Button&gt;Button&lt;/Button&gt; &lt;/div&gt; );&#125; 在这个例子中，App组件由两个子组件Input和Button，你觉得当用户在input中输入内容时DOM树的哪一部分会发生重渲染呢？ 123const Input = (&#123; value, onChange &#125;) =&gt; ( &lt;input value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt;); 解释一下嵌套组件嵌套组件是最困扰新手们的点了。他们总是会想着props也会触发re-render，我时常会听到：“但Input没有state，它只有props。但它re-render了，为什么？” 为了证明Input真的re-render，我们通过React&#39;s dev tool来检测。点击settings/gear icon，点击Highlight Update键。 当我们在input中输入内容时，会发现App、Input、Button都提示在re-render，这种re-render的触发只是因为改变了其中一个子组件Input的内容。这种更新准确来说并不是input内容变化所导致的，而是因为App组件中的state value发生变化导致的。 因此我们可以得出结论：只要App的state发生变化，每个App的子组件都会re-render。也有例外，如果我们使用PureComponent或者shouldComponentUpdate显式地表明Input和Button不会re-render，则子组件Input和Button不会re-render。 除了使用PureComponent和shouldComponentUpdate以外，有两种办法能够控制re-render。第一种办法是将state逻辑从App挪到Input子组件中。 1234567const Input = () =&gt; &#123; const [value, setValue] = React.useState(\"\"); const handleInputChange = e =&gt; &#123; setValue(e.target.value); &#125;; return &lt;input value=&#123;value&#125; onChange=&#123;handleInputChange&#125; /&gt;;&#125;; 这么做的话，App就不会更新，因为state挪到了子组件Input中。App不会更新也意味着Button也不会更新。 这里关键的一点是——尽管协调（reconciliation）能够使得React变得更快，在一些复杂的DOM场景下也会导致性能瓶颈。所以，不要盲目地优化（do not blindly optimize）。 在不re-render的情况下保存数据在数据发生变化和UI更新时，state会保存着数据。在有些情况下，UI的更新是没有什么必要的。 非受控组件避免在state中保存数据，它们会选择在refs中保存数据。下面的例子使用ref来处理表格场景： 12345678910111213141516function App() &#123; const [value, setValue] = React.useState(\"\"); const valueRef = React.useRef(); const handleClick = e =&gt; &#123; setValue(valueRef.current.value); &#125;; return ( &lt;div className=\"App\"&gt; &lt;h4&gt;Value: &#123;value&#125;&lt;/h4&gt; &lt;input ref=&#123;valueRef&#125; /&gt; &lt;Button onClick=&#123;handleClick&#125;&gt;Button&lt;/Button&gt; &lt;/div&gt; );&#125; 因为我们没有在input中使用state来存储其value，所以当我们填写表格的时候是没有re-render。只有当我们点击button时，才将ref中的current.value赋值给state中的value。 所以ref不只可以用于访问DOM节点，还可以用来存储数据。 受控组件是非受控组件的反义词，它们是使用state作为数据存储的组件。受控组件并不差（bad），实际上，它们是最为推荐的。 参考： https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"stroke学习之stroke-dasharray和stroke-dashoffset","slug":"stroke学习之stroke-dasharray和stroke-dashoffset","date":"2020-12-26T01:01:00.000Z","updated":"2020-12-26T06:36:19.619Z","comments":true,"path":"2020/12/26/stroke学习之stroke-dasharray和stroke-dashoffset/","link":"","permalink":"http://delaprada.com/2020/12/26/stroke%E5%AD%A6%E4%B9%A0%E4%B9%8Bstroke-dasharray%E5%92%8Cstroke-dashoffset/","excerpt":"","text":"今天在做音乐APP的进度条功能的时候，使用到了svg的stroke-dasharray和stoke-dashoffset两个之前没有用到过的属性，借此机会总结一下。 概念解析 stroke：画短线于，在…上划线 stroke-dasharray：用于创建虚线。之所以是array是因为其值其实是数组 123stroke-dasharray &#x3D; &#39;10&#39; stroke-dasharray &#x3D; &#39;10, 5&#39; stroke-dasharray &#x3D; &#39;20, 10, 5&#39; stroke-dasharray为一个参数时： 其实是表示虚线长度和每段虚线之间的间距。如：stroke-dasharray = &#39;10&#39; 表示：虚线长10，间距10，然后重复 虚线长10，间距10。 两个参数或者多个参数时：一个表示长度，一个表示间距。如：stroke-dasharray = &#39;10, 5&#39;表示：虚线长10，间距5，然后重复 虚线长10，间距5。如：stroke-dasharray = &#39;20, 10, 5&#39;表示：虚线长20，间距10，虚线长5，接着是间距20，虚线10，间距5，之后开始如此循环。 stroke-dashoffset：offset是偏移的意思，因此这个属性是相对于起始点的偏移。偏移x值为正数时，表示向左移动了x个长度单位，偏移x值为负数时，表示向右移动了x个长度单位。 需要注意的是，不管偏移的方向是哪一边，dasharray是循环的，也就是：虚线-间隔-虚线-间隔。dashoffset属性需要搭配dasharray属性才能看得出效果，因为不是虚线的话是无法看出偏移的。 实例举一下MDN的例子，图中的红线段表示偏移的距离： 上图效果分别是： 没有虚线 stroke-dasharray=&quot;3 1&quot; ，虚线没有设置偏移，也就是stroke-dashoffset值为0 stroke-dashoffset=&quot;3&quot;，偏移正数，虚线整体左移了3个单位，图中3后面的红线段，就是起始线段，线段之后是1个单位的间隔，我们可见区域从这个间隔开始，然后循环 3-1,3-1的虚线-间隔-虚线-间隔 stroke-dashoffset=&quot;-3&quot;，偏移负数，虚线整体右移动了3个单位，由于dasharray是循环的，前面偏移的位置会有dasharray填充上 stroke-dashoffset=&quot;1&quot;，偏移正数，虚线整体左移了1个单位，最终呈现出来的效果跟线段4 一样 （红色部分是我们看不见的部分，是可视区域或者偏移导致的） 进度条效果线性进度条实现这样一个动画：线段从无到有，由短变长 实现思路是： 设置stroke-dasharray虚线长度等于当前svg的宽度，间隔大于或者等于svg宽度 123&lt;svg &gt; &lt;line id=\"line\" x1=\"30\" y1=\"30\" x2=\"300\" y2=\"30\" stroke-width=\"20\" stroke=\"red\" stroke-dasharray=\"300,320\"/&gt; &lt;/svg&gt; 这时候我们可以在可视区域内看到一条红色的实线（因为间隔不在可视区域内）： 设置stroke左移300（即stroke-dashoffset: 300），这样就刚好隐藏了虚线，可视区域看到的是320的间隔（其实应该是270的间隔，因为可视区域只有270）： 当鼠标移入的时候，使offset由300变为0，就实现图中的效果了： 123456svg:hover #line&#123; stroke-dashoffset: 0;&#125;#line&#123; transition: all 2s;&#125; 圆形进度条实现思路和上面是类似的，设置stroke-dasharray虚线长度等于当前圆的周长，间隔大于或等于圆的周长。 实现思路： 先画一个圆 123&lt;svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\"&gt; &lt;circle id=\"circle\" cx=\"100\" cy=\"80\" r=\"50\" fill=\"gray\" stroke-width=\"5\" stroke=\"green\" /&gt; &lt;/svg&gt; 设置stroke-dasharray和stroke-dashoffset 12345#circle&#123; transition: all 2s; stroke-dasharray:314,314; // 周长为2πr stroke-dashoffset:314; // 相当于左移了314，虚线部分则不在可视区域内&#125; hover时，设置stroke-dashoffset为0，将虚线部分又展示到可视区域内，注意圆的stroke起始位置为右侧中间 123svg:hover #circle&#123; stroke-dashoffset:0; &#125; 因此，如果我们想让圆从上方中点开始，需要将圆逆时针旋转90度（rotate(-90deg)）: 1234&amp;.progress-bar &#123; transform: scale (0.9) rotate (-90deg); stroke: $&#123;style [\"theme-color\"]&#125;; &#125; 适用场景用svg的stroke-dasharray和stroke-dashoffset实现进度条效果适用于：不会人为拖动进度条的场景，比如通过props传入百分比控制dashoffset的位置。 因为在人为拖动进度条的场景下，一般需要有拖动按钮，需要为拖动按钮绑定用户的touchStart，touchMove，touchEnd事件，这些在svg上是不可行的。 在人为拖动进度条的场景下，只能乖乖用div去画进度条，例如： 12345678910111213141516&lt;ProgressBarWrapper&gt; &lt;div className=\"bar-inner\" ref=&#123;progressBar&#125; onClick=&#123;progressClick&#125; &gt; &lt;div className=\"progress\" ref=&#123;progress&#125;&gt;&lt;/div&gt; &lt;div className=\"progress-btn-wrapper\" ref=&#123;progressBtn&#125; onTouchStart=&#123;progressTouchStart&#125; onTouchMove=&#123;progressTouchMove&#125; onTouchEnd=&#123;progressTouchEnd&#125; &gt; &lt;div className=\"progress-btn\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/ProgressBarWrapper&gt; ProgressBarWrapper为整个进度条的容器，bar-inner是进度条的背景（100%），progress是当前进度（可变），progress-btn-wrapper是拖动按钮容器，progress-btn是拖动按钮。 可以看到此时进度条有拖动事件（touch）和点击事件（click），这两个事件的处理是不同的。 touch事件处理函数： 1234567891011121314151617181920212223242526272829303132const _offset = (offsetWidth) =&gt; &#123; // 设置进度条长度为offsetWidth，按钮的x偏移量为offsetWidth progress.current.style.width = `$&#123;offsetWidth&#125;px`; progressBtn.current.style.transform = `translate3d($ &#123;offsetWidth&#125;px, 0, 0)`;&#125;;// 记录开始位置和当前进度条宽度const progressTouchStart = (e) =&gt; &#123; const startTouch = &#123;&#125;; // 表示滑动动作开始 startTouch.initiated = true; startTouch.startX = e.touches[0].pageX; startTouch.left = progress.current.clientWidth; setTouch(startTouch); // touch是一个state状态 &#125;;const progressTouchMove = (e) =&gt; &#123; if(!touch.initiated) &#123; return; &#125; // deltaX记录移动距离 const deltaX = e.touches[0].pageX - touch.startX; // 进度条净宽度 = 进度条宽度 - 按钮宽度 const barWidth = progressBar.current.clientWidth - progressBtnWidth; // 控制offsetWidth大小使得进度条长度和按钮位置在最小（0）和最大（barWidth）范围之内 const offsetWidth = Math.min(Math.max(0, touch.left + deltaX), barWidth); _offset(offsetWidth)；&#125;; click点击事件： 1234567// 点击事件（与前面的拖动事件效果不同）const progressClick = (e) =&gt; &#123; // 进度条当前长度，getBoundingClientRect可获取DOM元素到浏览器可视范围的距离 const rect = progressBar.current.getBoundingClientRect(); const offsetWidth = e.pageX - rect.left; _offset(offsetWidth);&#125; 效果：","categories":[],"tags":[]},{"title":"React hooks: useRef, useImperativeHandle","slug":"React-hooks-useRef-useImperativeHandle","date":"2020-12-14T03:07:00.000Z","updated":"2020-12-19T02:18:58.751Z","comments":true,"path":"2020/12/14/React-hooks-useRef-useImperativeHandle/","link":"","permalink":"http://delaprada.com/2020/12/14/React-hooks-useRef-useImperativeHandle/","excerpt":"","text":"RefsRefs提供了一种方式，允许我们访问DOM节点或在render方法中创建的React元素。 在典型的React数据流中，props是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的props来重新渲染它。 但是在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个React实例，也可能是一个DOM元素。 何时使用Refs 管理焦点（受控组件），文本选择或媒体播放 触发强制动画 集成第三方DOM库 ref值根据节点的类型而有所不同 当ref属性用于HTML元素时，React.createRef()创建的ref接收底层DOM元素作为其current属性（比如div）。 当ref属性用于自定义class组件时，ref对象接收组件的挂载实例作为其current属性。 不能在函数组件上使用ref属性，因为它们没有实例。如果想要在函数组件中使用ref，可以使用forwardRef（可与useImperativeHandle结合使用）。不管怎样，你可以在函数组件内部使用ref属性，只要它指向一个DOM元素或class组件。 useRefuseRef最为传统的用法就是存储一个DOM节点的引用。当这个DOM节点更新时，这个引用也会更新。我们可以通过current属性来访问DOM节点。 1234567891011const App = () =&gt; &#123; const domRef = useRef() useEffect(() =&gt; &#123; doSomething(domRef.current) // access the DOM node here &#125;, []); return ( &lt;div ref=&#123;domRef&#125;&gt; &lt;Components /&gt; &lt;/div&gt; );&#125; 还有一种常用的用法是在父子组件中使用，通过结合useRef和forwardRef方法，父组件能够访问子组件内部的DOM节点。 Refs允许某些组件接收ref，并向下传递给子组件。比如在下面这个实例中，FancyButton使用React.forwardRef来传递给它的ref，然后转发到它渲染的DOM button，此时在父组件中就可以使用ref.current来访问button的DOM节点： 12345678910111213141516const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;));const Parent = () =&gt; &#123; // 你可以直接获取 DOM button 的 ref const ref = React.createRef(); return ( &lt;FancyButton ref=&#123;ref&#125;&gt; Click me! &lt;/FancyButton&gt; );&#125; 上述代码的逐步解释： 通过调用React.createRef创建了一个React ref并将其赋值给ref变量 通过制定ref为JSX属性，将其向下传递给&lt;FancyButton ref={ref}&gt; React传递ref给forwardRef内函数(props, ref) =&gt; ...，作为其第二个参数 向下转发该ref参数到&lt;button ref={ref}&gt;，将其指定为JSX属性 当ref挂载完毕，ref.current将指向&lt;button&gt;DOM节点 注意： 第二个参数ref只在使用React.forwardRef定义组件时存在。常规函数和class组件不接收ref参数，且props中也不存在ref。所以用forwardRef定义组件是一个比较特殊的用法。 如果想要在高阶组件中使用ref，需要多一步透传，见官网例子 useImperativeHandleuseImperativeHandle方法可以让我们通过ref将一些变量和函数从子组件传递给父组件。父组件可以选择使用它或者将这个ref又传递给另一个子组件。 我们都知道，React是单向数据流的，数据是从父组件通过props传递到子组件的，所以useImperativeHandle和forwardRef相结合实现信息从子组件传递给父组件，这是一个比较新颖的用法。 12345678910111213141516171819202122232425262728293031import &#123; useState, useRef, forwardRef, useImperativeHandle &#125; from \"react\";const ChildOne = forwardRef((props, ref) =&gt; &#123; const [ count, setCount ] = useState(0); useImperativeHandle(ref, () =&gt; (&#123; count, &#125;)); const updateCount = () =&gt; &#123; setCount((c) =&gt; c + 1); console.log(count + 1); &#125;; return &lt;button onClick=&#123;updateCount&#125;&gt;Increment&lt;/button&gt;;&#125;);const ChildTwo = forwardRef((props, ref) =&gt; &#123; const checkCount = () =&gt; console.log(\"-&gt;\", ref.current.count); return &lt;button onClick=&#123;checkCount&#125;&gt;Count&lt;/button&gt;;&#125;);const Parent = () =&gt; &#123; const ref = useRef(); return ( &lt;div&gt; &lt;ChildOne ref=&#123;ref&#125; /&gt; &lt;ChildTwo ref=&#123;ref&#125; /&gt; &lt;/div&gt; )&#125; 在上面的代码中，我们在Parent中初始化ref，然后传递给两个子组件。 子组件1有自己的state，使用useState hook来控制，同时它有一个updateCount方法来增加count数量。 子组件1通过useImperativeHandle这个hook让父组件能够访问count，useImperativeHandle方法以ref作为第一个参数，以一个匿名函数作为第二个参数，这个匿名函数返回一个包含count变量的对象。 现在父组件能够访问count，并传递给子组件2。当点击子组件2时，输出ref.current.count。 这是一个信息流从子组件传递到父组件，再从父组件传递给子组件的例子。与此同时，我们可以注意到，因为我们使用了useRef，所以父组件是没有发生任何的重新渲染（re-render）。 对useRef和useImperativeHandle简单实践的代码地址：https://github.com/delaprada/Refs-practice 参考： https://react.docschina.org/docs/forwarding-refs.html https://medium.com/@binyamin/react-hooks-useref-useimperativehandle-uselayouteffect-ede6f40f393e","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"http知识汇总","slug":"http知识汇总","date":"2020-12-07T11:45:35.000Z","updated":"2020-12-08T02:26:52.016Z","comments":true,"path":"2020/12/07/http知识汇总/","link":"","permalink":"http://delaprada.com/2020/12/07/http%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"http协议 http协议是Web的应用层协议，定义了Web客户端向服务器请求页面的方式；以及服务器向客户端传送Web页面的方式。 它使用tcp作为它的运输层协议。 无状态协议，因为http服务器不保存关于客户的任何信息。 不安全，不会对传输的数据进行加密。 Q：http协议为无状态协议，如何记住用户的状态？ A：无状态协议的好处是快速，但是有时我想要记住用户的状态（比如：登录状态）。此时我们可以使用cookie或者session记录用户的浏览状态信息，用户身份信息。 http请求/响应报文请求报文 由4个部分组成：请求行、请求头、空行、请求体 请求行由3个字段组成：请求方法、URL字段、HTTP协议版本字段 请求方法有：GET、HEAD、POST、PUT、DELETE 空行：告诉服务器请求头部到此为止 请求体：如果请求方法是GET，则为空；如果请求方法是POST，此处放置要提交的数据 上面是POST方法，它的请求行URL段中一般是没有参数的，参数放在了报文体中。而GET方法的参数直接置于请求行URL中，报文体则为空。 响应报文 由3个部分组成：响应行、响应头、响应体 响应行：由协议版本、状态码、状态描述构成 http状态码1XX 通知 2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务端错误 100（”continue”）该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。 例如：客户端有一个较大的文件需要上传并保存，但是客户端不知道服务器是否愿意接受这个文件，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿。 实际操作为客户端发送一条特殊的请求报文，报文的头部应包含： 1Expect: 100-continue 如果服务器愿意接受，就会返回100 continue状态码。 200（”OK”）一切正常 204 （无内容）服务器成功处理了请求，但没有返回任何内容。 对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。 206（部分内容）这种响应是在客户端表明自己只需要目标url上的部分资源的时候返回的，这种情况经常发生在客户端继续请求一个未完成的下载时使用。 301（Move Permanently）永久性转移。将跳转到新的url地址，原本请求的资源已经不可以再访问了。 302（Move Temporarily）暂时性转移。将跳转到新的url地址，原本请求的资源仍然可以被访问。 304（”Not Modified”）和浏览器缓存相关。表明服务器端资源未发生改变，可以继续使用浏览器缓存中的资源。请求的时候一般结合last-modified/if-modified-since和Etag/if-none-match使用。 400（”Bad Request”）请求不能被服务器理解。 401（”unauthorized”）请求没有http认证的认证信息。 403（”Forbidden”）请求被服务器拒绝。 404（”Not Found”）请求的资源不在服务器端。 500（”Internet Server Error”）服务器方面的问题。 502（”Bad Gateway”）作为网关或者代理的服务器向上游服务器发起请求时，从上游服务器接收到无效响应。 504（”Gateway Timeout”）作为网关或者代理的服务器向上游服务器发起请求时，未能及时从上游服务器接收到响应。 301和302的区别共同点：301和302状态码都表示重定向，也就是说浏览器在拿到服务器返回的这个状态码之后会自动跳转到一个新的url地址。 区别：301表示旧地址已经被永久地移除了，这个资源不可以访问了。 ​ 302表示旧地址的资源还在，可以访问，这个重定向只是临时地从旧地址转到新地址。 302 303 307的区别302当客户端向服务器发出POST请求后，收到服务器的302状态码，那么是不能自动向新的URL发送请求，必须跟用户确认是否该重发，因为第二次POST请求时，环境可能已经发生变化（POST方法不是幂等的，POST操作会不符合用户预期）。 也就是说：如果客户端发出非GET, HEAD请求后(比如POST请求)，收到302状态码，是不能够自动地向新的URL发送重复请求，除非得到用户的确认。 303会直接将上述的POST请求重定向为GET请求 307不会将POST转为GET，而是会询问用户是否应该在新的URL上发起POST请求 http方法 请求方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。OPTIONS方法请求web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法 8 patch 对已知资源进行局部更新 如何理解patch局部更新资源假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？ 人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。 于是patch诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。 而put虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了put，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空。 参考：https://segmentfault.com/q/1010000005685904/ http缺陷 通信使用明文（不加密），内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 通信使用明文可能会被窃听 如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。 不验证通信方的身份，可能遭遇伪装 在http协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。 摘自：https://blog.csdn.net/wangxp423/article/details/80033225 https http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，设计了SSL（Secure Sockets Layer）/ TLS（Transport Layer Security）协议用于对http协议传输的数据进行加密，从而诞生了https。 因此，https很安全。此外，https同时也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。 SSL/TLS握手过程 Client Hello 握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。 Server Hello 第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。 注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Hello Done Server Hello Done通知客户端Server Hello过程结束。 Certificate Verify 客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。 https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的 Client Key Exchange 上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。 至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。 为什么要使用三个随机数？ 这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。 最重要理解前六步 Change Cipher Spec（Client） 这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。 Encrypted Handshake Message(Client) 这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。 Change Cipher Spec(Server) 这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server) 这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data 到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https://juejin.im/post/584b76d3a22b9d0058d5036f http1.0/1.1/2.0的区别http1.0 http协议老的标准是http1.0。为了提高系统的效率，http1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个tcp连接，服务器完成请求处理后立即断开tcp连接，服务器不跟踪每个客户也不记录过去的请求。连接无法复用。 客户端和服务器端每次建立和关闭连接是一个相对比较费时的过程，并且会严重影响客户端和服务器的性能。 http1.1 为了克服http1.0的这个缺陷，http1.1支持持久连接，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。 同时，http1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分每次请求的内容。 http1.1还克服了http1.0的性能问题。http1.1通过增加更多的请求头和响应头来改进和扩充http1.0的功能。 http1.x的缺陷 Head-Of-Line Blocking：一旦队首的请求处理太慢，就会阻塞后面请求的处理。 在HTTP/1.x中，由于服务器必须按接受请求的顺序发送响应的规则限制，假设浏览器在一个（tcp）连接上发送了两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个请求的响应。 连接无法复用：连接无法复用会导致每次请求都会经历三次握手和慢启动。 HTTP1.1虽然加入了keep-alive可以复用一部分连接，但在一些情况下仍然需要建立多个连接来避免任务阻塞问题（Head-Of-Line Blocking），比如通过并发连接和域名分片增加任务队列，这样就不至于一个队伍的任务阻塞其他所有任务。因为此时需要建立多个连接，所以一定程度上会消耗资源，给服务器性能带来性能压力。 协议开销大：HTTP/1.x中header内容过大（每次请求header基本不怎么变化），增加了传输的成本。 安全因素：HTTP/1.x中传输的内容都是明文，客户端和服务端双方无法验证身份。 http2.0http2.0比之前的协议在性能上有很大的提升： 多路复用：允许在一个连接上发送多个请求，响应多个请求。 每个请求和它所对应的响应会在一个stream中 一个连接中可以有多个stream 每个stream高度独立，阻塞的stream不会影响其他stream的处理，所以可以避免Head-Of-Line Blocking。 二进制分帧：用二进制的格式去定义报文。 http1.1的解析是基于文本的，基本文本协议的格式存在天然的缺陷。因为文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。 http2.0和http1.1报文格式区别： 首部压缩 如上图所示，第2个请求的Header只有:path不一样，因此压缩空间非常可观。 Headers压缩的算法HPACK本身似乎很复杂(其实也不难)，但是算法思想其实非常简单的，假设我们在浏览器发起100个请求，它们的user-agent是不会变的，那我们为什么需要重复传输这个长长的字符串呢？用dictionary记录一次不就行了！ 服务端推送：服务端可以主动推送一些客户端之后可能会请求的资源。 如何升级到http2.0 参考FunDebug文章：https://blog.fundebug.com/2019/10/28/speedup-fundebug-by-using-http2/ 我们使用了Nginx作为前端页面与后端接口的反向代理服务器(Reverse Proxy)，只需要修改一下Nginx配置文件就可以升级HTTP/2了，非常简单。 注意，在 Nginx 上 开启 HTTP/2 需要 Nginx 1.9.5 以上版本（包括1.9.5），并且需要 OpenSSL 1.0.2 以上版本(包括1.0.2)。使用nginx -V命令可以查看Nginx的版本信息： 123456nginx -Vnginx version: nginx&#x2F;1.12.1built by gcc 6.3.0 20170516 (Debian 6.3.0-18)built with OpenSSL 1.1.0f 25 May 2017TLS SNI support enabledconfigure arguments: --prefix&#x3D;&#x2F;etc&#x2F;nginx --sbin3-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt&#x3D;&#39;-g -O2 -fdebug-prefix-map&#x3D;&#x2F;data&#x2F;builder&#x2F;debuild&#x2F;nginx-1.12.1&#x2F;debian&#x2F;debuild-base&#x2F;nginx-1.12.1&#x3D;. -specs&#x3D;&#x2F;usr&#x2F;share&#x2F;dpkg&#x2F;no-pie-compile.specs -fstack-protector-strong -Wformat -Werror&#x3D;format-security -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fPIC&#39; --with-ld-opt&#x3D;&#39;-specs&#x3D;&#x2F;usr&#x2F;share&#x2F;dpkg&#x2F;no-pie-link.specs -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#39; 可知，我们使用的Nginx版本为1.12.1，OpenSSL版本为1.1.0f，符合要求。 还有一点，虽然HTTP/2标准并没有要求加密，但是所有浏览器都要求HTTP/2必须加密，这样的话，只有HTTPS才能升级HTTP/2。 如果你还没用过HTTPS的话，不妨看看我的博客：教你快速撸一个免费HTTPS证书，其实也很简单。 一切前提没问题的话(Nginx&gt;=1.9.5，OpenSSL&gt;=1.0.2，HTTPS)，只需要修改1行配置，在listen指令后面添加http2： 12345server&#123; listen 443 ssl http2; server_name www.fundebug.com;&#125; 重启Nginx，升级HTTP/2就成功了，可以使用curl命令检查： 12345678910111213curl -sI https:&#x2F;&#x2F;www.fundebug.comHTTP&#x2F;2 200server: nginx&#x2F;1.12.1date: Mon, 07 Oct 2019 00:12:53 GMTcontent-type: text&#x2F;html; charset&#x3D;UTF-8content-length: 4892x-powered-by: Expressaccept-ranges: bytescache-control: public, max-age&#x3D;0last-modified: Sun, 06 Oct 2019 23:07:25 GMTetag: W&#x2F;&quot;131c-16da353dbc8&quot;vary: Accept-Encodingstrict-transport-security: max-age&#x3D;15768001 curl指令：用来请求web服务器。它的名字就是客户端（client）的URL工具的意思。 参考：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html 如何查看当前网站使用哪种协议打开chrome的devTool（f12），选择network项： 如果没有的话在Status一栏，点击右键，选择protocol项即可：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"什么是跨域以及跨域解决方案","slug":"什么是跨域以及跨域解决方案","date":"2020-12-06T08:30:16.000Z","updated":"2020-12-19T15:06:16.894Z","comments":true,"path":"2020/12/06/什么是跨域以及跨域解决方案/","link":"","permalink":"http://delaprada.com/2020/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"在介绍跨域前，先介绍浏览器的一个重要的安全策略——同源策略。 在文中，web 端地址为 localhost:8000 服务端地址为 localhost:8080 同源策略 同源策略是浏览器的一个安全功能，它是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器很容易受到XSS和CSFR等攻击。 同源指的是：协议，域名，端口号都相同 同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源 跨域什么是跨域跨域是指一个源下的文档或脚本试图去请求另一个源下的资源。 常见的跨域场景： 1234567891011121314151617181920URL 说明 是否允许通信http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同文件或路径 允许http:&#x2F;&#x2F;www.domain.com&#x2F;lab&#x2F;c.jshttp:&#x2F;&#x2F;www.domain.com:8000&#x2F;a.jshttp:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同端口 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttps:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同协议 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;192.168.4.12&#x2F;b.js 域名和域名对应相同ip 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;x.domain.com&#x2F;b.js 主域相同，子域不同 不允许http:&#x2F;&#x2F;domain.com&#x2F;c.js http:&#x2F;&#x2F;www.domain1.com&#x2F;a.jshttp:&#x2F;&#x2F;www.domain2.com&#x2F;b.js 不同域名 不允许 为什么会出现跨域归结于前后端分离这种架构设计和开发模式。前端开发人员只需负责将页面设计做好，后端开发人员只需将后端逻辑写好，这样降低了前端和后端程序员的门槛，也提升了开发效率。那在开发过程中，前后端需要进行联调，才能对各种功能进行测试。但在前后端分离的模式下，前后端的域名是不一致的，此时浏览器向服务器发起请求的时候就会发生跨域的问题。 为什么需要跨域限制不同源的请求比如用户登录a网站，同时新开tab打开了b网站，如果不限制同源，b可以像a网站发起任何请求，会让不法分子有机可趁。 限制dom操作如果现在有一个和百度很类似的网站叫：www.baidu1.com。我们先登录一下百度，然后访问这个www.baidu1.com。如果可以进行dom操作（例如：document.cookie）的话，大家的信息在这些钓鱼网站上会被轻松获取。 跨域解决方案 CORS跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin（domain）上的web应用被准许访问来自不同源服务器上的指定的资源。当这个web应用向一个与之不同域、协议或端口号的服务器请求资源的时候，就会发起一个跨域请求。 CORS中的请求分为两种：简单请求和非简单请求。 简单请求，例如请求方法为HEAD，GET，POST；非简单请求，例如：PUT，DELETE。 浏览器对这两种请求的处理是不一样的。 简单请求 如果浏览器发现这次跨域请求是简单请求，就自动在头信息中添加一个Origin字段。Origin字段用来说明，本次请求来自哪个源。服务器会根据这个值决定是否同意这次请求。 如果服务器同意这次请求的话，就会在响应报文加入头字段Access-Control-Allow-Origin。它的值要么是请求时Origin字段的值，要么是一个*，表示接收任意域名的请求。 非简单请求 预检请求：浏览器如果发现此次请求是一个非简单请求的话，就自动发出一个预检请求。预检请求用的请求方法是OPTIONS，表示这个请求是用来询问服务器，当前网页所在域名是否在服务器的许可名单之中，以及可以使用哪些HTTP头字段。在这个报文中还会带有Access-Control-Request-Method字段，表示CORS请求中使用的http方法是什么，比如PUT；还有Access-Control-Request-Headers，指定浏览器CORS请求会额外发送的头信息字段。 预检请求的回应：服务器在收到预检请求之后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨域请求，就可以做出回应。回应的关键字段也是Access-Control-Allow-Origin。 想要携带cookie需要满足3个条件： 客户端设置withCredentials属性为true，例如在axios中的设置方式为：axios.defaults.withCredentials = true 服务器端添加Access-Control-Allow-Credentials: true 服务器端配置的Access-Control-Allow-Origin为非* Node的跨域解决例子原生方式1234567891011121314app.use(async (ctx, next) =&gt; &#123; ctx.set(\"Access-Control-Allow-Origin\", ctx.headers.origin); ctx.set(\"Access-Control-Allow-Credentials\", true); ctx.set(\"Access-Control-Request-Method\", \"PUT,POST,GET,DELETE,OPTIONS\"); ctx.set( \"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, cc\" ); if (ctx.method === \"OPTIONS\") &#123; ctx.status = 204; return; &#125; await next();&#125;); 第三方中间件123const cors = require(\"koa-cors\");app.use(cors()); Node正向代理代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点（代理服务器）同域。 代理前： 代理后： cli工具中的代理Webpack（4.x）在webpack中可以配置proxy来快速获得接口代理的能力。 1234567891011121314151617181920212223242526const path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123; entry: &#123; index: \"./index.js\" &#125;, output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") &#125;, devServer: &#123; port: 8000, proxy: &#123; \"/api\": &#123; target: \"http://localhost:8080\" &#125; &#125; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: \"index.html\", template: \"webpack.html\" &#125;) ]&#125;; 修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）： 1234567891011121314&lt;button id=\"getlist\"&gt;获取列表&lt;/button&gt;&lt;button id=\"login\"&gt;登录&lt;/button&gt;&lt;script src=\"https://cdn.bootcss.com/axios/0.19.2/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.defaults.withCredentials = true; getlist.onclick = () =&gt; &#123; axios.get(\"/api/corslist\").then(res =&gt; &#123; console.log(res.data); &#125;); &#125;; login.onclick = () =&gt; &#123; axios.post(\"/api/login\"); &#125;;&lt;/script&gt; 因为前端现在是向webpack的devServer发起请求，所以不需要带域名(也就是http://localhost:8080)，devServer会自动转发给目标服务器地址http://localhost:8080。 Vue-cli 2.x123456789// config/index.js...proxyTable: &#123; '/api': &#123; target: 'http://localhost:8080', &#125;&#125;,... Vue-cli 3.x12345678910111213// vue.config.js 如果没有就新建module.exports = &#123; devServer: &#123; port: 8000, proxy: &#123; \"/api\": &#123; target: \"http://localhost:8080\" &#125; &#125; &#125;&#125;;... Parcel（2.x）123456// .proxyrc&#123; \"/api\": &#123; \"target\": \"http://localhost:8080\" &#125;&#125; 以上配置方式虽多，但都是有着共同的底层包http-proxy-middleware。里面需要用到的各种websocket，rewrite等功能，直接看这个库的配置即可。搜索技巧就是，想要那个框架直接google xxx proxy即可，官网有配置答案。 Nginx反向代理Nginx则是通过反向代理的方式，这里需要自定义一个域名。这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。 nginx安装教程：https://blog.csdn.net/diaojw090/article/details/89135073 配置hosts：127.0.0.1 local.test 配置nginx： 12345678910server &#123; listen 80; server_name local.test; location /api &#123; proxy_pass http://localhost:8080; &#125; location / &#123; proxy_pass http://localhost:8000; &#125;&#125; 启动nginx：sudo nginx 重启nginx：sudo nginx -s reload 前端代码： 1234567891011&lt;script&gt; axios.defaults.withCredentials = true; getlist.onclick = () =&gt; &#123; axios.get(\"/api/corslist\").then(res =&gt; &#123; console.log(res.data); &#125;); &#125;; login.onclick = () =&gt; &#123; axios.post(\"/api/login\"); &#125;;&lt;/script&gt; 后端代码： 1234567891011&lt;script&gt; axios.defaults.withCredentials = true; getlist.onclick = () =&gt; &#123; axios.get(\"/api/corslist\").then(res =&gt; &#123; console.log(res.data); &#125;); &#125;; login.onclick = () =&gt; &#123; axios.post(\"/api/login\"); &#125;;&lt;/script&gt; 疑惑：为什么客户端访问nginx反向代理服务器不会跨域，domain都不一样。。 用nginx反向代理解决跨域 参考：https://blog.csdn.net/qq_34020571/article/details/80597136 第一步：配置nginx.config 1234567891011121314151617181920212223242526272829server &#123; listen 8000; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root E:/h5; #h5项目路径 &#125; location /urm &#123; #代理的接口路径 proxy_pass http://192.168.1.111:9003/urm; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; &#125; location = /favicon.ico &#123; log_not_found off; access_log off; &#125; &#125; 第二步：启动后端服务器，启动nginx 第三步：修改前端ajax访问的url 从http://192.168.1.111:9003/urm —&gt; http://192.168.1.111:8000/urm 第四步：访问前端项目 http://192.168.1.111:8000/agent/merchant_manage.html 正向代理和反向代理的区别 参考链接：https://blog.csdn.net/m13666368773/article/details/8060481 正向代理：客户端知道服务端，通过代理端连接服务端。代理端代理的是服务端。 反向代理：所谓反向，是对正向而言的。服务端知道客户端，客户端不知道服务端，通过代理端连接服务端。代理端代理客户端。代理对象恰好相反，故名为反向代理。 JSONPJSONP主要是利用了script标签没有跨域限制的特性来完成的。 使用限制仅支持GET方法，如果想要使用完整的REST接口，请使用CORS或者其他代理方式。 流程解析 前端定义回调函数（例如 jsonpCallback=function(){....}） 通过params形式包装请求参数，并且声明执行函数（例如：cb=jsonpCallback） 后端获取前端声明的执行函数（jsonpCallback），并以带上参数和调用执行函数的方式传递给前端 使用示例后端实现： 12345678910111213const Koa = require(\"koa\");const fs = require(\"fs\");const app = new Koa();app.use(async (ctx, next) =&gt; &#123; if (ctx.path === \"/api/jsonp\") &#123; const &#123; cb, msg &#125; = ctx.query; ctx.body = `$&#123;cb&#125;($&#123;JSON.stringify(&#123; msg &#125;)&#125;)`; return; &#125;&#125;);app.listen(8080); 前端普通js示例： 123456789&lt;script type=\"text/javascript\"&gt; window.jsonpCallback = function(res) &#123; console.log(res); &#125;;&lt;/script&gt;&lt;script src=\"http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback\" type=\"text/javascript\"&gt;&lt;/script&gt; jQuery Ajax示例： 123456789101112131415&lt;script src=\"https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url: \"http://localhost:8080/api/jsonp\", dataType: \"jsonp\", type: \"get\", data: &#123; msg: \"hello\" &#125;, jsonp: \"cb\", success: function(data) &#123; console.log(data); &#125; &#125;);&lt;/script&gt; WebsocketWebSocket协议是html5一种新的协议。在WebSocket协议中，客户端和服务端都可以主动地推送消息，而且没有同源策略的限制，不存在跨域问题。协议的标识符为ws。像https一样如果加密的话就是wxs。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。 前端部分： 123456789&lt;script&gt; let socket = new WebSocket(\"ws://localhost:8080\"); socket.onopen = function() &#123; socket.send(\"秋风的笔记\"); &#125;; socket.onmessage = function(e) &#123; console.log(e.data); &#125;;&lt;/script&gt; 后端部分： 1234567const WebSocket = require(\"ws\");const server = new WebSocket.Server(&#123; port: 8080 &#125;);server.on(\"connection\", function(socket) &#123; socket.on(\"message\", function(data) &#123; socket.send(data); &#125;);&#125;); 本节内容代码：https://github.com/hua1995116/node-demo/tree/master/node-cors 参考： https://segmentfault.com/a/1190000022398875 https://blog.csdn.net/m13666368773/article/details/8060481","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Decorator用法与实践","slug":"Decorator用法与实践","date":"2020-12-01T06:19:07.000Z","updated":"2020-12-01T08:23:15.230Z","comments":true,"path":"2020/12/01/Decorator用法与实践/","link":"","permalink":"http://delaprada.com/2020/12/01/Decorator%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"今天看关注的公众号发了一篇关于Decorator在组件当中的应用，觉得比较新颖，因为之前看过的文章都是在类和类的方法里应用的。所以想趁此契机梳理一下Decorator知识。 Decorator特性可能在将来会发生改变，需等到定案之后再对其内容进行更新。 什么是Decorator装饰器装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类的方法。它体现了一种控制反转的设计思想，可以用来降低代码之间的耦合度，也称作依赖注入（常见的控制反转方法）。 装饰器是一种函数，写成@+函数名。它可以放在类和类方法定义的前面。 123456789@frozenclass Foo &#123; @configurable(false) @enumerable(true) method() &#123;&#125; @throttle(500) expensiveMethod() &#123;&#125;&#125; 代码中使用了四个装饰器，一个用在类本身，另外三个用在类方法。这是一种方便的手段来增加或修改类的功能。 类的装饰12345678@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true @testable就是一个装饰器，它修改了MyTestableClass这个类的的行为，为它添加了静态属性isTestable。testable函数的参数target就是MyTestableClass类本身。 装饰器函数的第一个参数就是所要修饰的目标类。如果觉得一个参数不够用，可以在装饰器外面再封装一层函数： 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 注意：装饰器对类的行为的改变，是代码编译时发生的，而不是运行时。 前面的例子只是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作： 123456789function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true 方法的装饰1234567891011121314151617181920class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;function readonly(target, name, descriptor) &#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', descriptor);// 类似于Object.defineProperty(Person.prototype, 'name', descriptor); 装饰器第一个参数是类的原型对象，上例是Person.prototype，装饰器的本意是要“装饰”类的实例，但这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况target参数指的是类本身） 第二个参数是所要装饰的属性名 第三个参数是该属性的描述对象 @log装饰器，可以起到输出日志的作用（这个常常会使用到）： 12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor;&#125;const math = new Math();// passed parameters should get logged nowmath.add(2, 4); 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行： 1234567891011121314function dec(id)&#123; console.log('evaluated', id); return (target, property, descriptor) =&gt; console.log('executed', id);&#125;class Example &#123; @dec(1) @dec(2) method()&#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 装饰器不能用于函数装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。 123456789var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125; 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样： 123456789101112var counter;var add;@addfunction foo() &#123;&#125;counter = 0;add = function () &#123; counter++;&#125;; Mixin在装饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，意在为一个对象之中混入另外一个对象的方法。 一般是通过Object.assign方法实现。 比如： 12345export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; 使用上面这个装饰器，为类”混入”各种方法： 1234567891011import &#123; mixins &#125; from './mixins';const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // \"foo\" 如何体现依赖注入我们从代码中可以发现，如果我们想要为某个类添加一些方法，只需要在类的前面添加一个装饰器即可。在没有装饰器之前我们一般会怎么做呢？我们会定义一个抽象类，在其中定义继承这个抽象类的所有类共有的一些方法，这样的话子类和子类之间的耦合度会比较高。那装饰器这种模式就可以降低类与类之间的耦合度。 Decorator装饰器在前端组件中的应用Decorator（装饰器模式）属于结构型模式，是一种拓展对象额外功能的设计模式，别名wrapper。 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。 wrapper经常在前端搭建场景中遇到，当搭建平台加载一个组件时，希望拓展其基础能力，一般会使用wrapper层对组件进行嵌套，wrapper层就是在不改变API的情况下，对第三方组件进行加强。 不同于继承，组合可以在运行时进行，所以称之为“动态添加”，这里的“额外职责”泛指一切功能，比如在按钮点击时进行一些log日志的打印，在绘制text文本框时，额外绘制一个滚动条和边框等等。 “就增加功能来说，Decorator模式相比生成子类更加灵活” 这句话的含义是，组合比继承更灵活，当可拓展的功能很多时，继承方案会产生大量的子类，而组合可以提前写好处理函数，在需要时动态构造，显然是更灵活的。 结构图 ConcreteComponent指的是需要被装饰的组件，可以看到，装饰器Decorator与他都继承同一个类，这样能保证API的一致，才保证无论装饰多少层，始终符合Component类型。 装饰器如果有多种，就要将Decorator申明为抽象类，ConcreteDecoratorA、ConcreteDecoratorB分别实现它们，如果只有一种装饰器，可以退化到Decorator自身就是一种实现。 代码例子1234567891011121314151617181920class Component &#123; public onClick = () =&gt; &#123;&#125;&#125;class Decorator extends Component &#123; private _component constructor(component) &#123; this._component = component &#125; public onClick = () =&gt; &#123; log('打点') this._component.onClick(); &#125;&#125;const component = new Component()// 一个普通的点击component.onClick()const wrapperComponent = new Decorator(component)// 一个具有打点功能的点击wrapperComponent.onClick() 其实方法很简单，通过组合，我们得到一个能力更强的组件，而实现方式就是利用构造函数保存组件实例，并在复写函数时，增加一些增强实现。 弊端装饰器的问题也是组合的问题，过多的组合会导致： 组合过程的复杂，要生成过多的对象 包装器层次增多，会增加调试成本，我们比较难追溯到一个bug是在哪一层包装导致的 总结装饰器模式是非常常用的模式，Decorator是一个透明的包装，只要保证包装的透明性，就可以最大限度发挥装饰器模式的优势。 最后总结一个装饰器应用图： 关于兼容性由于是es7的新特性，需要配置babel才能支持装饰器。 配置方法： babel：7.X版本 依赖安装 12npm install --save-dev @babel/plugin-proposal-decorators npm install --save-dev @babel/plugin-proposal-class-properties 配置（一般在.babelrc或babel.config.js中进行配置） 123456&#123; \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], [\"@babel/plugin-proposal-class-properties\", &#123; \"loose\" : true &#125;] ]&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"ES11新增属性解析","slug":"ES11新增属性解析","date":"2020-11-25T02:45:59.000Z","updated":"2020-11-25T03:00:01.362Z","comments":true,"path":"2020/11/25/ES11新增属性解析/","link":"","permalink":"http://delaprada.com/2020/11/25/ES11%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90/","excerpt":"","text":"ES11新增属性解析ES2020(ES11)引入了以下新特性（个人觉得比较实用的以粗体形式展示）： String的matchAll方法 动态导入语句import() import.meta export * as ns from &#39;module&#39; Promise.allSettled 新的数据类型BigInt GlobalThis Nullish coalescing Operator Optional Chaining matchAllmatchAll()方法返回一个包含所有匹配正则表达式的结果的迭代器。使用for...of遍历或者使用操作符...、Array.from将其转换成数组。 12345678910const reg = /[0-3]/g;const data = '2020'; console.log(data.matchAll(reg));//data.matchAll 的返回值是一个迭代器console.log([...data.matchAll(reg)]);/** * 0: [\"2\", index: 0, input: \"2020\", groups: undefined] * 1: [\"0\", index: 1, input: \"2020\", groups: undefined] * 2: [\"2\", index: 2, input: \"2020\", groups: undefined] * 3: [\"0\", index: 3, input: \"2020\", groups: undefined] */ Dynamic import标准用法的import导入的模块时静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。 在import()（也就是动态import）之前，当我们需要根据条件导入模块时，不得不使用require()。 如： 123if(XXX) &#123; const menu = require('./menu');&#125; 如今可以替换为： 123if(XXX) &#123; const menu = import('./menu');&#125; @babel/preset-env已经包含了@babel/plugin-syntax-dynamic-import，因此如果要使用import()语法，只需要配置@babel/preset-env即可。 提示：请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好地初始化依赖，而且更有利于静态分析工具和tree shaking发挥作用。 另外，import()返回的是一个promise对象。例如： 1234// menu.jsexport default &#123; menu: 'menu'&#125; 12345678//index.jsif(true) &#123; let menu = import('./menu'); console.log(menu); //Promise &#123;&lt;pending&gt; menu.then(data =&gt; console.log(data));//Module &#123;default: &#123;menu: \"menu\"&#125;, __esModule: true, Symbol(Symbol.toStringTag): \"Module\"&#125;&#125; else &#123; &#125; export * as ns from ‘module’12//menu.jsexport * as ns from './info'; 可以理解为是将下面两条语句合并为一句： 12import * as ns from './info';export &#123; ns &#125;; 不过需要注意的是，export * as ns from &#39;./info&#39;并不会真正导入模块，因此在该模块（menu.js）中，我们是获取不到ns的。 Promise.allSettledPromise.all或者Promise.race有的时候并不能满足我们的需求。比如，我们需要在所有的promise都结束的时候做一些操作，而并不在乎它们是成功还是失败。在没有Promise.allSettled之前，我们需要自己去写实现。 Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。 12345678910111213const promise1 = Promise.resolve(100);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'info'));const promise3 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 200, 'name'))Promise.allSettled([promise1, promise2, promise3]). then((results) =&gt; console.log(result));/* [ &#123; status: 'fulfilled', value: 100 &#125;, &#123; status: 'rejected', reason: 'info' &#125;, &#123; status: 'fulfilled', value: 'name' &#125; ]*/ BigIntBigInt是一种数字类型，它可以表示任意精度格式的整数。在此之前，JS中安全的最大数字是2^53-1，可在控制台输入Number.MAX_SAFE_INTEGER查看。超过这个值，JS没有办法精确表示。另外，大于或等于2的1024次方的数值，JS无法表示，会返回Infinity。 BigInt则解决了这两个问题。BigInt只用来表示整数，没有位数限制，任何位数的整数都可以精确表示。为了和Number类型进行区分，BigInt类型的数据必须添加后缀n。 1234567//Number类型在超过9009199254740991后，计算结果即出现问题const num1 = 90091992547409910;console.log(num1 + 1); //90091992547409900//BigInt 计算结果正确const num2 = 90091992547409910n;console.log(num2 + 1n); //90091992547409911n 还可以使用BigInt对象来初始化BigInt实例： 1console.log(BigInt(999)); // 999n 注意：没有 new 关键字！！！ 需要说明的是，BigInt和Number是两种数据类型，不能直接进行四则运算，不过可以进行比较操作： 123console.log(99n == 99); //trueconsole.log(99n === 99); //false console.log(99n + 1);//TypeError: Cannot mix BigInt and other types, use explicit conversionss GlobalThisJS中存在一个顶层对象，但是，顶层对象在各种实现里是不统一的。 从不同的JS环境中获取全局对象需要不同的语句。在Web中，可以通过window、self取得全局对象，但是在Web Workers中，只有self可以。在Node.js中，它们都无法获取，必须使用global。 在globalThis之前，我们需要这样去获取全局对象： 123456var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; ES2020中引入globalThis作为顶层对象，在任何环境中，都可以简单地通过globalThis拿到顶层对象。 Nullish coalescing OperatorES2020新增了一个运算符??。当左操作数为null或者undefined时，返回其右侧操作数，否则返回左侧操作数。 使用||操作符，当左侧的操作数为0、null、undefined、NaN、false、&#39;&#39;时，都会使用右侧的操作数。如果使用||来为某些变量设置默认值，可能会遇到意料之外的行为。 比如： 123const defaultValue = 100;let value = someValue || defaultValue;//当 someValue 转成 boolean 值为 false 时，value 的值都是 defaultValue 当someValue的值为0时，我们其实期望value值为0，但是它被错误分配成100。 ??操作符可以规避以上问题，它只有在左操作数为null或者是undefined时，才会返回右操作数。 Optional Chaining可选链操作符?.允许读取位于连接对象链深处的属性的值，而不必明确验证链中每一个引用是否有效。 例如，我们要访问info对象的animal的reptile的tortoise。但是我们不确定animal，reptile是否存在，因此我们需要这样写： 1const tortoise = info.animal &amp;&amp; info.animal.reptile &amp;&amp; info.animal.reptile.tortoise; 因为null.reptile或undefined.reptile会抛出错误：TypeError: Cannot read property &#39;reptile&#39; of undefined/null。如果我们需要访问的属性更深，那么这句代码会越来越长。 而有了可选链操作符?.，我们在访问reptile之前，不再需要校验info.animal的值。同样，在访问info.animal.reptile.tortoise之前，也不需要校验info.animal.reptile的值。 上面的代码简化为： 1const tortoise = info.animal?.reptile?.tortoise; JS在尝试访问info.animal.reptile之前，会隐式检查并确定info.animal的值不是null或undefined，如果其值是null或undefined，那么表达式短路计算直接返回undefined。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"使用better-scroll创建Scroll组件","slug":"使用better-scroll创建Scroll组件","date":"2020-04-19T06:39:24.000Z","updated":"2020-12-16T02:20:58.432Z","comments":true,"path":"2020/04/19/使用better-scroll创建Scroll组件/","link":"","permalink":"http://delaprada.com/2020/04/19/%E4%BD%BF%E7%94%A8better-scroll%E5%88%9B%E5%BB%BAScroll%E7%BB%84%E4%BB%B6/","excerpt":"","text":"在学习《React Hooks与Immutable数据流实战》这本书的时候，其中一章讲到了使用better scroll打造一个scroll组件，花了蛮长时间去理解里面使用到的各种的方法，比如：better scroll、forwardRef等，在此总结一下。 better-scroll better-scroll的基本原理：https://juejin.im/post/59300b2e2f301e006bcdd91c#heading-0 better-scroll 是一个移动端滚动的解决方案，它是基于 iscroll 的重写，它和 iscroll 的主要区别在这里。better-scroll 也很强大，不仅可以做普通的滚动列表，还可以做轮播图、picker 等等。 better-scroll的滚动原理浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵向滚动条；当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。 那么对于 better-scroll 也是一样的道理，我们先来看一下 better-scroll 常见的 html 结构： 1234567&lt;div class=\"wrapper\"&gt; &lt;ul class=\"content\"&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt; 为了更加直观，我们再来看一张图： 绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。 那么，我们怎么初始化 better-scroll 呢，如果是上述 html 结构，那么初始化代码如下： 123import BScroll from &#39;better-scroll&#39;let wrapper &#x3D; document.querySelector(&#39;.wrapper&#39;)let scroll &#x3D; new BScroll(wrapper, &#123;&#125;)复制代码 better-scroll 对外暴露了一个 BScroll 的类，我们初始化只需要 new 一个类的实例即可。第一个参数就是我们 wrapper 的 DOM 对象，第二个是一些配置参数，具体参考 better-scroll 的文档。 better-scroll 的初始化时机很重要，因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动。因此，我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用 scroll.refresh() 方法重新计算来确保滚动效果的正常。所以同学们反馈的 better-scroll 不能滚动的原因多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构发送变化的时候并没有重新计算 better-scroll。 创建一个scroll组件12&#x2F;&#x2F; 安装 better-scrollnpm install better-scroll@next --save 我们依然采用函数式组件的形式进行开发，不过作为一个通用组件，scroll 组件在业务中会被经常取到原生 DOM 对象，而函数式组件天生不具备被上层组件直接调用 ref 的条件，因此需要用 React 当中一些特殊的方式来处理，即使用 forwardRef 进行包裹。 forwardRef可以将子组件通过ref暴露给父组件，使得父组件可以通过ref获取到子组件的dom。 123const Scroll = forwardRef ((props, ref) =&gt; &#123; // 编写组件内容&#125;) 首先梳理一下这个组件需要接受哪些参数: 123456789101112Scroll.propTypes = &#123; direction: PropTypes.oneOf (['vertical', 'horizental']),// 滚动的方向 click: true,// 是否支持点击 refresh: PropTypes.bool,// 是否刷新 onScroll: PropTypes.func,// 滑动触发的回调函数 pullUp: PropTypes.func,// 上拉加载逻辑 pullDown: PropTypes.func,// 下拉加载逻辑 pullUpLoading: PropTypes.bool,// 是否显示上拉 loading 动画 pullDownLoading: PropTypes.bool,// 是否显示下拉 loading 动画 bounceTop: PropTypes.bool,// 是否支持向上吸顶 bounceBottom: PropTypes.bool// 是否支持向下吸底&#125;; 通过propTypes定义参数的类型。 目前归纳出了这些可能的参数，也正是后面的开发中所需要的，给他们赋默认值: 123456789101112Scroll.defaultProps = &#123; direction: \"vertical\", click: true, refresh: true, onScroll:null, pullUpLoading: false, pullDownLoading: false, pullUp: null, pullDown: null, bounceTop: true, bounceBottom: true&#125;; 通过defaultProps定义这些参数的默认值。 现在来写 scroll 组件的核心逻辑代码，首先声明如下 hooks 变量: 1234//better-scroll 实例对象const [bScroll, setBScroll] = useState ();//current 指向初始化 bs 实例需要的 DOM 元素 const scrollContaninerRef = useRef (); 从外面接受 props，解构赋值拿到这些参数: 12const &#123; direction, click, refresh, pullUpLoading, pullDownLoading, bounceTop, bounceBottom &#125; = props;const &#123; pullUp, pullDown, onScroll &#125; = props; 接下来创建 better-scroll: 12345678910111213141516useEffect (() =&gt; &#123; const scroll = new BScroll (scrollContaninerRef.current, &#123; scrollX: direction === \"horizental\", scrollY: direction === \"vertical\", probeType: 3, click: click, bounce:&#123; top: bounceTop, bottom: bounceBottom &#125; &#125;); setBScroll (scroll); return () =&gt; &#123; setBScroll (null); &#125;&#125;, []); 通过new BScroll创建一个scroll实例，第一个参数是父容器，也就是说scrollContainerRef所指向的DOM作为这个scroll组件的父容器。 setBScroll方法就是将创建出来的scroll实例赋值给bScroll。 return()=&gt;{...}就是在组件销毁的时候对effect进行清除 每次重新渲染都要刷新实例，防止无法滑动: 12345useEffect (() =&gt; &#123; if (refresh &amp;&amp; bScroll)&#123; bScroll.refresh (); &#125;&#125;); 给实例绑定 scroll 事件: 123456789useEffect (() =&gt; &#123; if (!bScroll || !onScroll) return; bScroll.on ('scroll', (scroll) =&gt; &#123; onScroll (scroll); &#125;) return () =&gt; &#123; bScroll.off ('scroll'); &#125;&#125;, [onScroll, bScroll]); 进行上拉到底的判断，调用上拉刷新的函数: 123456789101112useEffect (() =&gt; &#123; if (!bScroll || !pullUp) return; bScroll.on ('scrollEnd', () =&gt; &#123; // 判断是否滑动到了底部 if (bScroll.y &lt;= bScroll.maxScrollY + 100)&#123; pullUp (); &#125; &#125;); return () =&gt; &#123; bScroll.off ('scrollEnd'); &#125;&#125;, [pullUp, bScroll]); 进行下拉的判断，调用下拉刷新的函数: 123456789101112useEffect (() =&gt; &#123; if (!bScroll || !pullDown) return; bScroll.on ('touchEnd', (pos) =&gt; &#123; // 判断用户的下拉动作 if (pos.y &gt; 50) &#123; pullDown (); &#125; &#125;); return () =&gt; &#123; bScroll.off ('touchEnd'); &#125;&#125;, [pullDown, bScroll]); 现在已经完成了滑动事件，上拉下拉事件的判断，现在需要给外界暴露组件方法，假设这样的一个情景： 1234// 上层组件代码const scrollRef = useRef ();...&lt;Scroll ref=&#123;scrollRef&#125;&gt;&lt;/Scroll&gt; 想要通过这种调用方法的方式刷新 scroll 组件： 1scrollRef.current.refresh (); 这应该怎么办呢？ React Hooks 中的 useImperativeHandle 已经给了我们解决方案，我们这样做就好了: 12345678910111213141516// 一般和 forwardRef 一起使用，ref 已经在 forWardRef 中默认传入useImperativeHandle (ref, () =&gt; (&#123; // 给外界暴露 refresh 方法 refresh () &#123; if (bScroll) &#123; bScroll.refresh (); bScroll.scrollTo (0, 0); &#125; &#125;, // 给外界暴露 getBScroll 方法，提供 bs 实例 getBScroll () &#123; if (bScroll) &#123; return bScroll; &#125; &#125;&#125;)); 这样上层组件就可以通过ref获取到这些方法。比如有时候要执行刷新之类的操作的时候，就需要去调用refresh方法。 剩下的是 UI 的渲染工作: 12345return ( &lt;ScrollContainer ref=&#123;scrollContaninerRef&#125;&gt; &#123;props.children&#125; &lt;/ScrollContainer&gt;); scrollContainerRef所指向的dom就是这个ScrollContainer。 同时贴出样式部分的 js 代码: 12345const ScrollContainer = styled.div` width: 100%; height: 100%; overflow: hidden;` 将Scroll组件应用到Recommend.js中导入Scroll组件： 1import Scroll from '../../scroll.js'; 在return中应用： 12345678&lt;Content&gt; &lt;Scroll className=\"list\"&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerList&#125;&gt;&lt;/Slider&gt; &lt;RecommendList recommendList=&#123;recommendList&#125;&gt;&lt;/RecommendList&gt; &lt;/div&gt; &lt;/Scroll&gt;&lt;/Content&gt; 这里作者用了个Content，来去保证父组件高度固定，这里是我疑惑的一个点，按照better-scroll的官方文档的内容，我们执行 123456789new BScroll (scrollContaninerRef.current, &#123; scrollX: direction === \"horizental\", scrollY: direction === \"vertical\", probeType: 3, click: click, bounce:&#123; top: bounceTop, bottom: bounceBottom &#125;) 操作的时候，已经将scrollContainerRef.current作为父容器了。 后来我仔细想了一下发觉这么做是有道理的。 但我们可以看到scrollContainerRef的样式： 12345const ScrollContainer = styled.div` width: 100%; height: 100%; overflow: hidden;` scrollContainer的高度是根据父元素高度来固定的。这么做的一个好处就是scrollContainer能够在多个地方复用，根据不同的父元素高度来调节自身的高度，因为better-scroll很重要的一点就是wrapper的高度要固定（即scrollContainerRef.current的高度要固定）。如果一开始便设置ScrollContainer的高度是固定的，比如30px，那么它就不能够在多个地方复用了，因为不同地方scroll的高度是不一样的。","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"React+Redux 通过axios向接口获取数据的流程","slug":"React-Redux-通过axios向接口获取数据的流程","date":"2020-04-17T11:45:34.000Z","updated":"2020-04-17T12:34:39.946Z","comments":true,"path":"2020/04/17/React-Redux-通过axios向接口获取数据的流程/","link":"","permalink":"http://delaprada.com/2020/04/17/React-Redux-%E9%80%9A%E8%BF%87axios%E5%90%91%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/","excerpt":"","text":"最近在学习《React Hooks与Immutable数据流实战》小书，想把在React+Redux项目中用axios发起请求的配置流程记录下来，做个总结，加深一些印象。 启动服务器首先是将github上网易云音乐接口的node.js项目启动，在项目中都是向这个服务器去发起请求，获取接口数据。 12&#x2F;&#x2F;启动服务器指令node app.js 安装axios1npm install axios --save 现在在 src/api 目录下新建 config.js 文件，里面编写 axios 的配置: 12345678910111213141516171819import axios from 'axios';export const baseUrl = 'http://xxx自己填';//axios 的实例及拦截器配置const axiosInstance = axios.create (&#123; baseURL: baseUrl&#125;);axiosInstance.interceptors.response.use ( res =&gt; res.data, err =&gt; &#123; console.log (err, \"网络错误\"); &#125;);export &#123; axiosInstance&#125;; baseUrl的话就是服务器的基地址，比如http://localhost:3000，那请求的一些接口数据就会在这个baseUrl的不同路由下，比如banner数据会通过http://localhost:3000/banner接口获取。 axios.create：创建一个axios实例，可以添加一些基本配置。 官网解释： axios.create([config])12345const instance &#x3D; axios.create(&#123; baseURL: &#39;https:&#x2F;&#x2F;some-domain.com&#x2F;api&#x2F;&#39;, timeout: 1000, headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;&#125;); axiosInstance.interceptors.response.use 用于将公共的业务逻辑抽离出来。 然后在同一个目录下新建 request.js 用来封装不同的网络请求，内容如下: 123456789import &#123; axiosInstance &#125; from \"./config\";export const getBannerRequest = () =&gt; &#123; return axiosInstance.get ('/banner');&#125;export const getRecommendListRequest = () =&gt; &#123; return axiosInstance.get ('/personalized');&#125; 在request.js中封装一些向服务器发起请求的方法，注意返回的是promise对象。 redux层开发在 Recommend 目录下，新建 store 文件夹，然后新建以下文件： 1234actionCreators.js&#x2F;&#x2F; 执行一些request.js中封装好的方法，获取到接口数据，并通过dispatch更新store的内容constants.js &#x2F;&#x2F; 常量集合，存放不同 action 的 type 值index.js &#x2F;&#x2F; 用来导出 reducer，actionreducer.js &#x2F;&#x2F; 存放 initialState 和 reducer 函数 constants.js1234//定义action类型export const CHANGE_BANNER='recommend/CHANGE_BANNER';export const CHANGE_RECOMMEND_LIST='recommend/RECOMMEND_LIST'; reducer.js定义reducer函数，并初始化state: 123456789101112131415161718192021import * as actionTypes from './constants';import &#123;fromJS&#125; from 'immutable'; // 这里用到 fromJS 把 JS 数据结构转化成 immutable 数据结构import &#123;combineReducer&#125; from 'redux-immutable';const defaultState=fromJS(&#123; bannerList: [], recommendList: []&#125;)//定义reducer函数export default (state=defaultState, action)=&gt;&#123; switch(action.type)&#123; case actionTypes.CHANGE_BANNER: return state.set('bannerList', action.data); case actionTypes.CHANGE_RECOMMEND_LIST: return state.set('recommendList', action.data); default: return state; &#125;&#125; actionCreators.js执行request.js中的方法，通过axios从接口获取数据，然后通过dispatch方法，使用获取到的新数据去更新state。 12345678910111213141516171819202122232425262728293031323334import * as actionTypes from './constants';import &#123;fromJS&#125; from 'immutable';import &#123;getBannerRequest, getRecommendListRequest&#125; from '../../../api/request'export const changeBannerList=(data)=&gt;(&#123; type: actionTypes.CHANGE_BANNER, data: fromJS(data)&#125;);export const changeRecommendList=(data)=&gt;(&#123; type: actionTypes.CHANGE_RECOMMEND_LIST, data: fromJS(data)&#125;)export const getBannerList=()=&gt;&#123; return (dispatch)=&gt;&#123; getBannerRequest().then(data=&gt;&#123; //返回的数据格式为：&#123;banners: Array(8), code:200&#125; dispatch(changeBannerList(data.banners)); &#125;).catch(()=&gt;&#123; console.log(\"轮播图数据传输错误\"); &#125;) &#125;&#125;export const getRecommendList=()=&gt;&#123; return (dispatch)=&gt;&#123; getRecommendListRequest().then(data=&gt;&#123; dispatch(changeRecommendList(data.result)); &#125;).catch(()=&gt;&#123; console.log(\"推荐歌单数据传输错误\"); &#125;) &#125;&#125; index.js用于将相关变量导出： 12345//index.jsimport reducer from './reducer'import * as actionCreators from './actionCreators'export &#123; reducer, actionCreators &#125;; 组件连接Redux首先，需要将 recommend 下的 reducer 注册到全局 store，在 store/reducer.js 中，内容如下: 123456import &#123; combineReducers &#125; from 'redux-immutable';import &#123; reducer as recommendReducer &#125; from '../application/Recommend/store/index';export default combineReducers (&#123; recommend: recommendReducer,&#125;); 注册完成！ 现在在 Recommend/index.js 中，准备连接 Redux。组件代码更新如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; useEffect &#125; from 'react';import Slider from '../../components/slider/';import &#123; connect &#125; from \"react-redux\";import * as actionTypes from './store/actionCreators';import RecommendList from '../../components/list/';import Scroll from '../../baseUI/scroll/index';import &#123; Content &#125; from './style';function Recommend (props)&#123; const &#123; bannerList, recommendList &#125; = props; const &#123; getBannerDataDispatch, getRecommendListDataDispatch &#125; = props; useEffect (() =&gt; &#123; getBannerDataDispatch (); getRecommendListDataDispatch (); //eslint-disable-next-line &#125;, []); const bannerListJS = bannerList ? bannerList.toJS () : []; const recommendListJS = recommendList ? recommendList.toJS () :[]; return ( &lt;Content&gt; &lt;Scroll&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerListJS&#125;&gt;&lt;/Slider&gt; &lt;RecommendList recommendList=&#123;recommendListJS&#125;&gt;&lt;/RecommendList&gt; &lt;/div&gt; &lt;/Scroll&gt; &lt;/Content&gt; );&#125;// 映射 Redux 全局的 state 到组件的 props 上const mapStateToProps = (state) =&gt; (&#123; // 不要在这里将数据 toJS // 不然每次 diff 比对 props 的时候都是不一样的引用，还是导致不必要的重渲染，属于滥用 immutable bannerList: state.getIn (['recommend', 'bannerList']), recommendList: state.getIn (['recommend', 'recommendList']),&#125;);// 映射 dispatch 到 props 上const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; getBannerDataDispatch () &#123; dispatch (actionTypes.getBannerList ()); &#125;, getRecommendListDataDispatch () &#123; dispatch (actionTypes.getRecommendList ()); &#125;, &#125;&#125;;// 将 ui 组件包装成容器组件export default connect (mapStateToProps, mapDispatchToProps)(React.memo (Recommend)); 通过connect高阶函数，将mapStateToProps、mapDispatchToProps的属性和方法整合起来，传入内嵌组件（Recommend），内嵌组件就可以通过props获取到数据。 mapStateToProps：获取store中的state，对数据进行初始化操作 mapDispatchToProps：声明一些数据更新、数据获取操作 在useEffect阶段执行getBannerDataDispatch (); getRecommendListDataDispatch ();操作。useEffect是Hook的API，用于完成副作用操作。它相当于class中的一些声明周期，在特定时期执行响应的操作。此处useEffect的第二个参数为[]，表示只在第一次执行，用来请求异步数据；如果第二个参数不为空数组，比如数组内有一些属性的话，则在这些属性发生变化的时候，useEffect才会执行。 Hook的API介绍详情： React官方文档 https://juejin.im/post/5e53d9116fb9a07c9070da44 启动1npm start 看到结果： 要注意的点： 12345678910export const getBannerList=()=&gt;&#123; return (dispatch)=&gt;&#123; getBannerRequest().then(data=&gt;&#123; //返回的数据格式为：&#123;banners: Array(8), code:200&#125; dispatch(changeBannerList(data.banners)); &#125;).catch(()=&gt;&#123; console.log(\"轮播图数据传输错误\"); &#125;) &#125;&#125; 要注意看接口返回的数据，比如getBannerRequest()获取到的数据是对象，那我们要使用data.banners才能获取到banner的内容，直接data是会出错的。","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"Node.js——Express和koa框架对比","slug":"Node-js——Express和koa框架对比","date":"2020-04-07T03:10:47.000Z","updated":"2020-04-07T06:08:19.023Z","comments":true,"path":"2020/04/07/Node-js——Express和koa框架对比/","link":"","permalink":"http://delaprada.com/2020/04/07/Node-js%E2%80%94%E2%80%94Express%E5%92%8Ckoa%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/","excerpt":"","text":"此文参考：阿里技术协会《Node.js框架之express与koa对比分析》 https://yq.aliyun.com/articles/3062","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——事件循环","slug":"Node——事件循环","date":"2020-04-07T00:51:23.000Z","updated":"2020-04-07T02:23:07.020Z","comments":true,"path":"2020/04/07/Node——事件循环/","link":"","permalink":"http://delaprada.com/2020/04/07/Node%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"异步IO异步IO是指操作系统提供的IO（数据进出）能力，比如键盘输入，对应到显示器上会有专门的数据输出接口，这就是我们生活中可见的IO能力；这个接口在向下会进入到操作系统这个层面，在操作系统中，会提供诸多的能力，比如：磁盘的读写，DNS的查询，数据库的连接啊，网络请求的处理，等等。 在不同的操作系统层面，表现的不一致。有的是异步非阻塞的；有的是同步的阻塞的，无论如何，我们都可以看做是上层应用于下层系统之间的数据交互；上层依赖于下层，但是反过来，上层也可以对下层提供的这些能力进行改造。如果这种操作是异步的，非阻塞的，那么这种就是异步非阻塞的异步IO模型；如果是同步的阻塞的，那么就是同步IO模型。 koa就是一个上层的web服务框架，全部由JavaScript实现，他有操作系统之间的交互，全部通过nodejs来实现；如nodejs的 readFile就是一个异步非阻塞的接口，readFileSync就是一个同步阻塞接口。 事件循环事件循环是指Node.js执行非阻塞I/O操作，尽管JavaScript是单线程的,但由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行。 Node.js是单线程执行的，同时它又是基于事件驱动和非阻塞IO编程模型。这就使得我们不用等待异步操作结果返回，就可以继续往下执行代码。当异步事件触发之后，就会通知主线程，主线程执行相应事件的回调。 Node.js架构分析说道 Nodejs 架构, 首先要知道Nodejs 与 V8 和 libUV 的关系和作用: V8: 执行 JS 的引擎. 也就是翻译 JS. 包括我们熟悉的编译优化, 垃圾回收等等. libUV: 提供 async I/O, 提供消息循环. 可见, 是操作系统 API 层的一个抽象层. JavaScript引擎是一种专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器中。 V8：是Google开发的JavaScript引擎，用于Google Chrome和Chromium。V8能够即时编译JavaScript，使得JavaScript代码能够高效运行。 以往我们在执行c++的时候，会先进行编译工作，变为可执行文件后，再执行这个可执行文件。这个编译工作是由编译器完成的。 解释器就提供了一种边编译边运行的动态运行方法，而也正因为通过解释器运行的代码是边编译边运行的，所以运行的速度比静态编译的那种慢很多。 所以程序运行的方式分为静态编译和动态编译。 回到Node.js架构，Node.js如何组织它们呢？ Node.js通过一层C++ Binding，把JavaScript传给V8，V8解析后交给libUV发起异步IO，并等待消息循环调度。所以，Node.js实现异步机制的核心便是libUV。 Node.js启动过程可以分为以下步骤： 1、调用platformInit方法 ，初始化 nodejs 的运行环境。 2、调用 performance_node_start 方法，对 nodejs 进行性能统计。 3、openssl设置的判断。 4、调用v8_platform.Initialize，初始化 libuv 线程池。 5、调用 V8::Initialize，初始化 V8 环境。 6、创建一个nodejs运行实例。 7、启动上一步创建好的实例。 8、开始执行js文件，同步代码执行完毕后，进入事件循环。 9、在没有任何可监听的事件时，销毁 nodejs 实例，程序执行完毕。 以上是Node.js执行一个JavaScript文件的全过程，事件循环是在第八个步骤中。 Nodejs 完全是单线程的. 从进程启动后, 由主线程加载我们的 js 文件(下图中 main.js), 然后进入消息循环. 可见对于 js 程序而言, 完整运行在单线程之中。 事件循环Node.js中事件循环分为6个阶段： timers：执行setTimeout() 和 setInterval()中到期的回调。 I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 idle, prepare：仅内部使用 poll：最为重要的阶段，执行I/O 回调，在适当的条件下会阻塞在这个阶段 check：执行setImmediate的回调 close callbacks：执行close事件的回调，例如socket.on(&quot;close&quot;,func) 重点关注timers、poll、check三个阶段 步骤： node的初始化 初始化node环境 执行同步任务（例如console.log） 执行process.nextTick回调 执行microtasks（Promise.then） 进入event-loop 进入timers阶段 检查timer队列是否有到期的timer回调，如果有，将到期的timer回调按照timerID升序执行 检查是否有process.nextTick任务，如果有，全部执行 检查是否有microtask，如果有，全部执行 退出该阶段 进入IO callback阶段 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段。 检查是否有 process.nextTick 任务，如果有，全部执行。 检查是否有microtask，如果有，全部执行。 退出该阶段。 进入idle、prepare阶段： 这两个阶段与我们编程关系不大，暂且按下不表。 进入poll阶段 首先检查是否存在尚未完成的回调，如果存在，分两种情况： 如果有可用回调（可用回调包含：到期的定时器、一些IO事件等），执行所有可用回调。 检查是否有process.nextTick回调，如果有，全部执行 检查是否有 microtaks，如果有，全部执行。 退出该阶段。 如果没有可用回调 检查是否有setImmediate回调，如果有，退出poll阶段。如果没有，阻塞在此阶段，等待新的事件通知。 如果不存在尚未完成的回调，退出poll。 进入check阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 check 阶段 进入closing阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 closing 阶段 在事件循环的每个子阶段退出之前都会按顺序执行如下过程： 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出当前阶段。 常见问题process.nextTick和Promise这个队列先保证所有的 process.nextTick 回调, 然后将所有的 Promise 回调追加在后面. 最终在每个 Phase 结束的时候一次性拿出来执行。 setTimeout(..., 0)vs. setImmediate 到底谁快?1234// index.jssetImmediate(() =&gt; console.log(2))setTimeout(() =&gt; console.log(1),0) 答案：可能是1 2，也可能是2 1。 首先我们在初始化阶段会将setImmediate添加到check phase中，将setTimeout添加到timer phase中。 如果进入timer phase的时间 &gt; 消息循环保存的时间（即将以上两个回调添加到它们各自的phase的时间） 那在进入timer phase的时候setTimeout的回调已经在里面了，就可以立即执行，然后到check phase的时候再执行setImmediate的回调。此时输出1 2。 如果进入timer phase的时间 &lt; 消息循环保存的时间（即将以上两个回调添加到它们各自的phase的时间） 那在进入timer phase的时候setTimeout的回调还不在里面，那就会先执行check phase中的setImmediate，然后在下一轮循环中再执行timer phase中的setTimeout。此时输出2 1。 如果把代码改为如下，则一定会得到稳定输出： 12345require('fs').readFile('my-file-path.txt', () =&gt; &#123; setImmediate(() =&gt; console.log(2)) setTimeout(() =&gt; console.log(1))&#125;);// 2 1 因为消息在poll phase才会将setImmediate进入check phase，将setTimeout进入timer phase，那poll阶段后就回到check阶段，所以会输出2 1。 判断输出顺序12345678910111213141516171819setImmediate(() =&gt; &#123; console.log('setImmediate1'); setTimeout(() =&gt; &#123; console.log('setTimeout1') &#125;, 0);&#125;);Promise.resolve().then(res=&gt;&#123; console.log('then');&#125;)setTimeout(() =&gt; &#123; process.nextTick(() =&gt; &#123; console.log('nextTick'); &#125;); console.log('setTimeout2'); setImmediate(() =&gt; &#123; console.log('setImmediate2'); &#125;);&#125;, 0);//then setTimeout2 nextTick setImmediate1 setImmediate2 setTimeout1 step1：初始化阶段 setImmediate进入check phase、Promise.resolve().then进入微任务event queue、setTimeout进入timer phase。 没有process.nextTick 执行microtask，输出then 结束该阶段 step2：进入Timer phase（或者poll phase？） 执行setTimeout 执行console.log(&#39;setTimeout2&#39;)，输出setTimeout2 setImmediate进入check phase 有process.nextTick，输出nextTick step3：进入check phase 执行第一个setImmediate，输出setImmediate1，将setTimeout进入Timer phase 执行第二个setImmediate，输出setImmediate2 step4：下一个循环，进入Timer phase 执行setTimeout，输出setTimeout1 参考： https://juejin.im/post/5b61d8e3e51d45191d7a28a8 https://www.jianshu.com/p/906eafb41ea6","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Vue项目中如何用Node作后端代理获取接口数据","slug":"Vue项目中如何用Node作后端代理获取接口数据","date":"2020-04-06T02:12:17.000Z","updated":"2020-04-06T02:37:40.638Z","comments":true,"path":"2020/04/06/Vue项目中如何用Node作后端代理获取接口数据/","link":"","permalink":"http://delaprada.com/2020/04/06/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8Node%E4%BD%9C%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%90%86%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/","excerpt":"","text":"在做音乐APP项目的时候，发觉QQ音乐的有些接口是没有办法直接获取其中的数据的，因为它指定了请求的host和referer，所以我们需要用Node在其中做一层代理，去“欺骗”QQ，这样就能够获取数据。有点像跨域的思想，只不过跨域是用代理作为跳板，转发请求，不存在跨域问题；这里是用Node Server发起请求，将请求的referer和host改为接口允许访问的referer和host，来“欺骗”QQ。 怎么配置Node代理我们使用Vue.cli搭项目的脚手架的时候，build/webpack.dev.conf.js文件中有个devServer这里就可以用来配置。以前是有单独的文件dev-server.js，最新版本的Vue.cli放弃了这个。 首先要在devServer中添加before(app){}，将我们的操作放在before(app){}中。webpack 3 内置了 express，app 就是 express() 返回的对象。 123456789101112131415161718devServer: &#123; before(app)&#123; app.get('/api/getDiscList',function(req,res)&#123; const url='https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'; axios.get(url,&#123; headers:&#123; referer:'https://c.y.qq.com', host:'c.y.qq.com' &#125;, params:req.query &#125;).then((response)=&gt;&#123; res.json(response.data) &#125;).catch((e)=&gt;&#123; console.log(e); &#125;) &#125;)...&#125; 当Node服务器接收到来自/api/getDiscList的get请求时，就会执行后面的回调函数，用axios向QQ的URL发起请求，关键是要指定请求的头部headers，设定referer和host，这个referer和host是URL &lt;’https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&#39;&gt; 允许访问的referer和host。 向Node代理服务器发起请求我们使用模块化开发的时候，就可以在方法当中使用axios向Node代理服务器发起请求，返回一个Promise对象。 1234567891011121314151617181920export function getDiscList()&#123; const url='/api/getDiscList'; const data=Object.assign(&#123;&#125;,commonParams,&#123; platform:'yqq', hostUin:0, sin:0, ein:29, sortId:5, needNewCode:0, categoryId:10000000, rnd:Math.random(), format:'json' &#125;) return axios.get(url,&#123; params:data &#125;).then((res)=&gt;&#123; return Promise.resolve(res.data); &#125;)&#125; 组件当中的设置首先是要导入方法： 1import &#123;getDiscList&#125; from 'api/recommend' 我们在created生命周期阶段执行方法： 1234created()&#123; this._getRecommend(); this._getDiscList();&#125; 获取到数据： 123456789methods:&#123; _getDiscList()&#123; getDiscList().then((res)=&gt;&#123; if(res.code===ERR_OK)&#123; console.log(res.data.list); &#125; &#125;) &#125;&#125; 执行npm run dev，可在控制台看到数据：","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——Connect和Express","slug":"Node——Connect和Express","date":"2020-04-05T06:03:20.000Z","updated":"2020-04-05T07:56:24.980Z","comments":true,"path":"2020/04/05/Node——Connect和Express/","link":"","permalink":"http://delaprada.com/2020/04/05/Node%E2%80%94%E2%80%94Connect%E5%92%8CExpress/","excerpt":"","text":"前言Connect和Express是两个热门的Node模块。Express就是在Connect的基础上，通过添加高层糖衣扩展和搭建出来的。 Connect创建简单的Connect程序指令： 1npm install connect@3.4.0 在要安装的模块后加@可以指定版本号 简单的Connect程序应该是这样的： 12345const app&#x3D;require(&#39;connect&#39;)();app.use((req,res,next)&#x3D;&gt;&#123; res.end(&#39;Hello, world!&#39;);&#125;);app.listen(3000); 这个程序会用Hello, World!做出响应。也就是访问http://localhost:3000的时候，页面显示Hello, world!。传给app.use的函数是个中间件，它以文本Hello, world!作为响应结束了请求处理过程。中间件是所有Connect和Express程序的基础。 Connect中间件的工作机制Connect中间件就是JavaScript函数。这个函数一般会有三个参数：请求对象、响应对象、以及一个名为next的回调函数。一个中间件完成自己的工作，要执行后续的中间件时，可以调用这个next回调函数。 在中间件运行之前，Connect会用分派器接管请求对象，然后交给程序中的第一个中间件。 借助中间件API，可以把一些小的构件块组合到一起，实现复杂的处理逻辑。 组合中间件Connect中的use方法就是用来组合中间件的。我们先来定义两个中间件函数，然后把它们都添加到程序中。 12345678910111213const connect=require('connect');function logger(req,res,next)&#123; console.log('%s %s', req.method, req.url); next();&#125;function hello(req,res)&#123; res.setHeader('Content-Type', 'text/plain'); res.end('hello world');&#125;connect() .use(logger) .use(hello) .listen(3000); 这两个中间件的名称签名不一样：一个有next，一个没有。因为后面这个中间件完成了HTTP响应，再也不需要把控制权交还给分派器了。 use()函数返回的是Connect程序的实例，支持方法链。也可以不写成链式调用的形式： 1234const app=connect();app.use(logger);app.use(hello);app.listen(3000); 需要注意的是，如果某个中间件不调用next()，那链在它后面的中间件就不会被调用。所以如果logger和hello两个函数的调用顺序反过来，则logger是不会执行的。 使用错误处理中间件Connect中有一种用来处理错误的中间件变体。跟常规的中间件相比，除了请求和响应对象外，错误处理中间件的参数中还多了一个错误对象。 1234567891011121314151617//Connect中的错误处理中间件const env=process.env.NODE_ENV||'development';function errorHandler(err,req,res,next)&#123; res.statusCode=500; switch(env)&#123; //开发模式和生产模式的响应不同 case 'development': console.error('Error:'); console.error(err); res.setHeader('Content-Type','application/json'); res.end(JSON.stringify(err)); break; default: res.end('Server error'); &#125;&#125;module.exports=errorHandler; 开发环境（development）：开发同学开发时使用的环境，每位开发同学在自己的dev分支上工作，开发到一定程度后，各位同学会合并代码，进行联调。 生产环境（production）：线上环境，用户使用的环境。由特定人员来维护。 设置环境变量 UNIX系统中设置环境变量的指令：$ NODE_ENV=production node app Windows中用这个： $ set NODE_ENV=production $ node app 产品在开发环境中运行时，你可能想要看到尽可能详细的日志；但在生产环境中，你可能想让日志尽量精简，可能还要用gzip进行压缩。 用NODE_ENV设定程序的模式，Connect一般会根据环境变量NODE_ENV(process.env.NODE_ENV)来切换不同服务器环境（比如生产环境和开发环境）下的行为。 当Connect遇到错误时，它会切换，只去调用错误处理中间件。 假设有一个允许用户登录到管理区域的博客程序。如果负责用户路由的中间件引发了一个错误，则中间件blog和admin都会被跳过，因为它们不是错误处理中间件（只有三个参数）。然后Connect看到接受错误参数的errorHandler，就会调用它。中间件看起来像下面这样： 12345connect() .use(router(require('./routes/user'))) .use(router(require('./routes/blog'))) //跳过 .use(router(require('./routes/admin'))) //跳过 .use(errorHandler); ExpressExpress是非常流行的Web框架，以前是在Connect的基础上搭建的。尽管提供了一些基本的功能，比如静态文件服务、URL路由和程序配置等，但它依然是极简的Web框架。 简单的Express程序 12345678const express=require('express');const app=express();app.get('/',(req,res)=&gt;&#123; res.send('Hello');&#125;);app.listen(3000); 生成程序框架安装指令： 1npm install -g express-generator 生成程序 用-e或（--ejs）指定要使用的模板引擎是EJS（EJS是一个嵌入JavaScript模板引擎，通过编译生成HTML代码）。执行express -e shoutbox，shoutbox是文件名。一个功能完备的程序会出现在shoutbox目录中。其中会有描述项目和依赖项的package.json文件、程序主文件、public目录，以及一个放路由处理器的目录。 Express路由入门根据官网定义： Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on). 路由的定义： 1app.METHOD(PATH, HANDLER) app是express的一个实例 METHOD是HTTP请求方法（小写） PATH是服务器上的路径 HANDLER是在这个路径上发起HTTP请求时执行的回调函数 Respond with Hello World! on the homepage: 123app.get('/', function (req, res) &#123; res.send('Hello World!')&#125;) Respond to POST request on the root route (/), the application’s home page: 123app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125;) Respond to a PUT request to the /user route: 123app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user')&#125;) Respond to a DELETE request to the /user route: 123app.delete('/user', function (req, res) &#123; res.send('Got a DELETE request at /user')&#125;) 做个简单的留言板程序效果： 步骤： 创建消息模型 添加与消息相关的路由 创建消息表单 添加业务逻辑，用提交上来的表单数据创建消息 创建消息模型在创建消息模型之前，需要先安装Node redis模块。执行命令npm install --save redis。而且要安装Redis，Windows系统可以使用Redis Chocolately。 安装教程：https://www.cnblogs.com/julyluo/p/6646155.html 官网没有windows版本，github下载速度太慢。 Redis就是一个数据库，可以将我们post的留言存储起来。 创建保存在线留言板消息条目的模型。 创建models/entry.js文件： 12345678910111213141516171819202122232425262728293031323334353637383940'use strict';const redis = require('redis');const db = redis.createClient();class Entry &#123; constructor(obj) &#123; for (let key in obj) &#123; this[key] = obj[key]; &#125; &#125; static getRange(from, to, cb) &#123; db.lrange('entries', from, to, (err, items) =&gt; &#123; if (err) return cb(err); let entries = []; items.forEach((item) =&gt; &#123; entries.push(JSON.parse(item)); &#125;); cb(null, entries); &#125;); &#125; save(cb) &#123; const entryJSON = JSON.stringify(this); db.lpush( 'entries', entryJSON, (err) =&gt; &#123; if (err) return cb(err); cb(); &#125; ); &#125; static count(cb) &#123; db.llen('entries', cb); &#125;&#125;module.exports = Entry; 创建消息表单 在app.js中添加如下路由部分 12app.get('/post', entries.form);app.post('/post', entries.submit); 即：使用get向/post发起http请求时，执行entries.form回调函数。使用post向/post发起http请求时，执行entries.submit回调。 这个`entries`是从`routes`中导入的模块。看一下定义： 表单模块部分： 1234//routes/entries.jsexports.form = (req, res) =&gt; &#123; res.render('post', &#123; title: 'Post' &#125;);&#125;; 这里是用views/post.ejs，即表单，去渲染页面。 123456789101112131415161718192021222324&#x2F;&#x2F;views&#x2F;post.ejs&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt; &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;h1&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h1&gt; &lt;p&gt;Fill in the form below to add a new post.&lt;&#x2F;p&gt; &lt;form action&#x3D;&#39;&#x2F;post&#39; method&#x3D;&#39;post&#39;&gt; &lt;p&gt; &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;entry[title]&#39; placeholder&#x3D;&#39;Title&#39; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;p&gt; &lt;textarea name&#x3D;&#39;entry[body]&#39; placeholder&#x3D;&#39;Body&#39;&gt;&lt;&#x2F;textarea&gt; &lt;&#x2F;p&gt; &lt;p&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&#39;Post&#39; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 表单中用了形如entry[title]之类的输入控件名称，需要用扩展的消息体解析器来解析。找到app.js将 1app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); 改为： 1app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); 实现消息提交功能 123456789101112131415//将代码添加到文件routes/entries.js中，实现用表单提交上来的数据创建消息exports.submit = (req, res, next) =&gt; &#123; const data = req.body.entry; const user = res.locals.user; const username = user ? user.name : null; const entry = new Entry(&#123; username: username, title: data.title, body: data.body &#125;); entry.save((err) =&gt; &#123; if (err) return next(err); res.redirect('/'); &#125;);&#125;; 这里使用了Common JS进行模块化开发 添加显示消息的首页 在routes/entries.js中添加： 123456789101112const Entry = require('../models/entry');exports.list = (req, res, next) =&gt; &#123; const page = req.page; Entry.getRange(0, -1, (err, entries) =&gt; &#123; if (err) return next(err); res.render('entries', &#123; title: 'Entries', entries: entries &#125;); &#125;);&#125;; 视图entries.ejs 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt; &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;% entries.forEach((entry) &#x3D;&gt; &#123; %&gt; &lt;div class&#x3D;&#39;entry&#39;&gt; &lt;h3&gt;&lt;%&#x3D; entry.title %&gt;&lt;&#x2F;h3&gt; &lt;p&gt;&lt;%&#x3D; entry.body %&gt;&lt;&#x2F;p&gt; &lt;p&gt;Posted by &lt;%&#x3D; entry.username %&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;% &#125;) %&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 在程序运行之前先在同一目录下创建menu.ejs创建菜单模板文件，后续会用到。目前空白着先。 添加与消息相关的路由 在app.js中： 1const entries = require('./routes/entries'); 添加路由： 1app.get('/', entries.list); 运行程序 先以管理员身份进入CMD，运行redis-server启用Redis。 在terminal中运行npm start，访问http://localhost:3000/post 点击post后跳转到首页： 完成。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——Gulp基于流的自动化构建工具","slug":"Node——Gulp基于流的自动化构建工具","date":"2020-04-03T02:59:55.000Z","updated":"2020-04-03T04:01:47.163Z","comments":true,"path":"2020/04/03/Node——Gulp基于流的自动化构建工具/","link":"","permalink":"http://delaprada.com/2020/04/03/Node%E2%80%94%E2%80%94Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"用Gulp实现自动化Gulp是基于流的构建系统。我们可以通过对这些流的引导来创建构建过程，除了转译和缩码，还能做很多事情。 Gulp之所以能实现高度重用，主要归功于两项技术：使用插件和自定义构建任务。Gulp的构建过程是一个流，所以这些任务和插件是可以一个接一个拼在一起的。 把Gulp添加到项目中添加Gulp需要用npm安装gulp-cli和gulp两个包。下面这段代码中，全局安装gulp-cli，并创建一个带有Gulp开发依赖项的新Node项目。 123npm i --global gulp-clinpm init -ynpm i -save-dev gulp 接着创建gulpfile.js 1touch gulpfile.js touch为linux指令 现在用Gulp构建一个小型的React项目。这里会用到gulp-babel、gulp-sourcemaps和gulp-concat： 12npm i --save-dev gulp-sourcemaps gulp-babel babel-preset-es2015npm i --save-dev gulp-concat react react-dom babel-preset-react 这里要注意的是，安装gulp-babel的时候要安装7版本的，后续还要安装babel-core。如果直接安装，是安装8版本，babel-core是7，就会出错。 Gulp任务的创建及运行创建Gulp任务需要在gulpfile.js中编写Node代码，调用Gulp的API。Gulp的API可以做很多事情，比如查找文件，把对文件进行某种转换的插件拼到一起等。 打开gulpfile.js设置一个构建任务，用gulp.src查找JSX文件，用Babel处理ES6和React，然后把这些文件拼到一起。 gulpfile.js 123456789101112131415const gulp=require('gulp');const sourcemaps=require('gulp-sourcemaps');const babel=require('gulp-babel');const concat=require('gulp-concat');gulp.task('default',()=&gt;&#123; return gulp.src('app/*.jsx') .pipe(sourcemaps.init()) .pipe(babel(&#123; presets:['es2015','react'] &#125;)) .pipe(concat('all.js')) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('dist'));&#125;) gulp.src：Gulp自带的文件聚集工具，查找所有的React jsx文件 sourcemaps.init()：开始监视源文件，为调试构建源码映射 concat(&#39;all.js&#39;)：把所有源码文件拼到一个all.js中 soucemaps.write(&#39;.&#39;)：单独写入源码映射文件 gulp.dest(&#39;dist&#39;)：将所有文件放到dist/目录下 创建一个名为app/index.jsx的文件，就可以试验一下Gulp了。可以用下面这段JSX代码： 1234567import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello,world!&lt;/h1&gt;, document.getElementById('example')) 在终端运行gulp： 123[10:21:44] Using gulpfile ~\\Desktop\\大三\\实习\\笔记\\Node.js\\gulp_test\\gulpfile.js[10:21:44] Starting &#39;default&#39;...[10:21:44] Finished &#39;default&#39; after 213 ms 目录： 打包生成的all.js： 123456789101112131415161718'use strict';var _react = require('react');var _react2 = _interopRequireDefault(_react);var _reactDom = require('react-dom');var _reactDom2 = _interopRequireDefault(_reactDom);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;_reactDom2.default.render(_react2.default.createElement( 'h1', null, 'Hello,world'), document.getElementById('example'));//# sourceMappingURL=all.js.map 总结在Gulp中，用JavaScript表示构建阶段很容易。并且我们可以用gulp.task()往这个文件里添加自己的任务。这些任务通常都遵循相同的模式。 源文件：收集输入文件 转译：让它们依次通过一个个对它们进行转换的插件 合并：把这些文件合到一起，创建一个整体构建文件 输出：设定文件的目标地址或移动输出文件 在前面那个例子中，sourcemaps是个特例，因为它需要两次pipe：第一次是配置，最后一次是输出文件。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——串行化/并行化流程控制","slug":"Node——串行化-并行化流程控制","date":"2020-04-01T03:15:11.000Z","updated":"2020-04-01T04:05:56.067Z","comments":true,"path":"2020/04/01/Node——串行化-并行化流程控制/","link":"","permalink":"http://delaprada.com/2020/04/01/Node%E2%80%94%E2%80%94%E4%B8%B2%E8%A1%8C%E5%8C%96-%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"异步逻辑的顺序化在异步程序的执行过程中，有些任务可能会随时发生，跟程序中的其他部分在做什么没关系，什么时候做这些任务都不会出问题。但有些任务只能在某些特定的任务之前或之后做。 让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类：串行和并行。 串行任务：需要一个接着一个执行的任务 并行任务：不需要一个接着一个执行的任务。这些任务彼此之间开始和结束时间并不重要，但在后续逻辑执行前它们应该全部执行完成。 实现串行化流程控制为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组起到队列的作用：完成一个任务后按顺序从数组中取出下一个。 实例做一个小程序，让它从一个随机选择的RSS预订源中获取一篇文章的标题和URL，并显示出来。RSS预订源列表放在一个文本文件中。 例如： 123&#x2F;&#x2F;rss_feeds.txthttp:&#x2F;&#x2F;www.read.org.cn&#x2F;feedhttps:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;feed&#x2F;blog.xml 这个rss_feeds.txt放在文件夹sequence中。 从npm存储库中下载两个辅助模块。在sequence文件目录下，terminal中输入： 123npm init -ynpm install --save request@2.60.0npm install --save htmlparser@1.7.7 request模块是个经过简化的HTTP客户端，你可以用它获取RSS数据。htmlparser模块能把原始的RSS数据转换成JavaScript数据结构。 然后再目录下创建index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const fs=require('fs');const request=require('request');const htmlparser=require('htmlparser');const configFilename='./rss_feeds.txt';//确保包含RSS预订源URL列表的文件存在function checkForRSSFile()&#123; fs.exists(configFilename,(exists)=&gt;&#123; if(!exists)&#123; return next(new Error(`Missing RSS file:$&#123;configFilename&#125;`)); &#125; next(null,configFilename); &#125;)&#125;//读取并解析包含预订源URL的文件function readRSSFile(configFilename)&#123; fs.readFile(configFilename,(err,feedList)=&gt;&#123; if(err)&#123; return next(err); &#125; feedList=feedList.toString().replace(/^\\s+|\\s+$/g,'').split('\\n'); //从预订源URL数组中随机选择一个预订源URL const random=Math.floor(Math.random()*feedList.length); next(null,feedList[random]); &#125;)&#125;//向选定的预订源发送HTTP请求以获取数据function downloadRSSFeed(feedUrl)&#123; request(&#123;uri:feedUrl&#125;,(err,res,body)=&gt;&#123; if(err) return next(err); if(res.statusCode!==200)&#123; return next(new Error('Abnormal response status code')); &#125; next(null,body); &#125;)&#125;//将预订源数据解析到一个条目数组中function parseRSSFeed(rss)&#123; const handler=new htmlparser.RssHandler(); const parser=new htmlparser.Parser(handler); parser.parseComplete(rss); if(!handler.dom.items.length)&#123; return next(new Error('No RSS items found')); &#125; const item=handler.dom.items.shift(); //如果有数据，显示第一个预订源条目的标题和URL console.log(item.title); console.log(item.link);&#125;//把所有要做的任务按执行顺序添加到一个数组中const tasks=[ checkForRSSFile, readRSSFile, downloadRSSFeed, parseRSSFeed];//负责执行任务的next函数function next(err,result)&#123; if(err)&#123; throw err; &#125; const currentTask=tasks.shift(); //从任务数组中取出下个任务 if(currentTask)&#123; currentTask(result); &#125;&#125;next(); //开始执行 串行化执行的实现是通过一个数组tasks去承载要执行的任务。首先通过tasks.shift()方法从tasks数组中取出第一个任务checkForRSSFile，在执行这个任务的时候，它内部又调用了next方法，使得我们能够执行下一个任务，以此类推。这个负责执行任务的next函数会多次执行。 执行node index.js，输出结果： 12《聪明人用方格笔记术》“黄金三分法”http:&#x2F;&#x2F;www.read.org.cn&#x2F;html&#x2F;2438-cong-ming-ren-yong-fang-ge-bi-ji-shu-huang-jin-san-fen-fa.html 实现并行化流程控制为了让异步任务并行执行，仍然是要把任务放在数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续逻辑。 这里的例子就做一个简单的程序，读取几个文本文件的内容，并输出单词在整个文件中出现的次数。我们会用异步的readFile函数读取文本文件的内容，所以几个文件的读取可以并行执行。 这是目录组成： 1.txt： 1do you love me 2.txt： 1yes i do love you word_count.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const fs=require('fs');const tasks=[];const wordCounts=&#123;&#125;;const filesDir='../text';let completedTasks=0;function checkIfComplete()&#123; completedTasks++; if(completedTasks===tasks.length)&#123; for(let index in wordCounts)&#123; console.log(`$&#123;index&#125;:$&#123;wordCounts[index]&#125;`); &#125; &#125;&#125;function addWordCount(word)&#123; wordCounts[word]=(wordCounts[word])?wordCounts[word]+1:1;&#125;function countWordsInText(text)&#123; const words=text.toString().toLowerCase().split(/\\W+/).sort(); words.filter(word=&gt;word).forEach(word=&gt;addWordCount(word));&#125;fs.readdir(filesDir,(err,files)=&gt;&#123; if(err)&#123; throw err; &#125; files.forEach(file=&gt;&#123; //task函数声明，是立即执行的，获取filename const task=(file=&gt;&#123; return ()=&gt;&#123; fs.readFile(file,(err,text)=&gt;&#123; if(err)&#123; throw err; &#125; countWordsInText(text); checkIfComplete(); &#125;) &#125; &#125;)(`$&#123;filesDir&#125;/$&#123;file&#125;`); //将当前tast push到tasks数组中 tasks.push(task); &#125;) //开始并行执行所有任务 tasks.forEach(task=&gt;task());&#125;) 执行node word_count.js： 123456do:2i:1love:2yes:1you:2me:1","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"虚拟DOM","slug":"虚拟DOM","date":"2020-03-31T08:37:58.000Z","updated":"2020-03-31T09:24:53.071Z","comments":true,"path":"2020/03/31/虚拟DOM/","link":"","permalink":"http://delaprada.com/2020/03/31/%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"昨天面试的时候，面试官问到虚拟DOM的原理，被问到的时候，就把自己之前的理解说了一通，因为之前面试的时候也被问到过，觉得应该没问题。后来面试官质问了一下：“虚拟DOM最终也是使用DOM API去操作DOM，它的性能就一定会更好么 ? ” 然后就懵了….后来在网上搜了些资料，又有了些新的见解。 虚拟DOM的含义虚拟DOM是使用JS去模拟真实的DOM。DOM树上的结构、属性信息我们都可以使用JavaScript对象表示出来： 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;, ]&#125; 上面对应的HTML写法是： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 用JS操作真实DOM的操作：状态变更-&gt;重新渲染整个视图的方式，可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：虚拟DOM是局部更新的。虽然视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，减少了不必要的调用DOM API去操作DOM的操作。 算法实现步骤一：用JS对象模拟真实DOM用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js 123456789function Element (tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children&#125;module.exports = function (tagName, props, children) &#123; return new Element(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element') //模块化导入Element函数var ul = el('ul', &#123;id: 'list'&#125;, [ el('li', &#123;class: 'item'&#125;, ['Item 1']), el('li', &#123;class: 'item'&#125;, ['Item 2']), el('li', &#123;class: 'item'&#125;, ['Item 3'])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的&lt;ul&gt;： 1234567891011121314151617181920Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) &#123; // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的&lt;ul&gt;的DOM结构： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 步骤二：比较两棵虚拟DOM树的差异当我们要做出修改的时候，首先是要创建一个新的结点，然后使用diff算法去对比新旧节点的不同，这种对比只会在同层级进行，不会跨层进行，此处是使用深度优先遍历算法，然后将差异记录在patches对象当中。 同层级比较的话算法复杂度更低，降到O(n)。 深度优先遍历，记录差异： 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是0，那么： 1patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 差异类型： 上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;] 如果给div新增了属性id为container，就记录下： 123456789patches[0] &#x3D; [&#123; type: REPALCE, node: newNode &#x2F;&#x2F; el(&#39;section&#39;, props, children)&#125;, &#123; type: PROPS, props: &#123; id: &quot;container&quot; &#125;&#125;] 如果是文本节点，如上面的文本节点2，就记录下： 1234patches[2] = [&#123; type: TEXT, content: \"Virtual DOM2\"&#125;] 那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这就涉及到两个列表的对比算法，其实可以抽象出来是最小编辑距离问题（动态规划思想）。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： 1234patches[0] = [&#123; type: REORDER, moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]&#125;] 步骤三：把差异应用到真正的DOM树上因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。 使用patch方法将对象patches当中记录的更改应用到真实DOM上。 123456789101112131415161718192021function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点 var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; if (currentPatches) &#123; applyPatches(node, currentPatches) // 对当前节点进行DOM操作 &#125;&#125; applyPatches，根据不同类型的差异对当前节点进行 DOM 操作： 1234567891011121314151617181920function applyPatches (node, currentPatches) &#123; currentPatches.forEach(function (currentPatch) &#123; switch (currentPatch.type) &#123; case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 总结虚拟DOM的优缺点优点： 很多 DOM API 的读写都涉及页面布局的“重新计算”，以确保返回值的准确，涉及样式、结构的还会触发页面“重新绘制”，更耗性能。 综上，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。 虚拟DOM实际上最终还是会调用DOM API，但它能够减少不必要的DOM API调用。虚拟DOM遵循“在JS中缓存必要数据，计算界面更新时的阶段数据差异，只提交最终差集”的基本思路。 缺点： 使用JS去模拟真实DOM，会占用一定内存 diff算法，有计算方面的额外开销 参考： &lt;https://www.zhihu.com/search?type=content&amp;q=%E8%99%9A%E6%8B%9Fdom&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"使用JSONP实现跨域","slug":"使用JSONP实现跨域","date":"2020-03-29T07:23:53.000Z","updated":"2020-03-30T07:11:36.322Z","comments":true,"path":"2020/03/29/使用JSONP实现跨域/","link":"","permalink":"http://delaprada.com/2020/03/29/%E4%BD%BF%E7%94%A8JSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"同源策略 同源策略是浏览器的一个安全功能 同源指的是：协议，域名，端口号都相同 同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源 同源策略限制的内容有： cookie、localStorage等存储性内容 DOM节点 AJAX请求发送后，非同源会被浏览器拦截 但是有三个标签时允许跨域加载资源的： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 这就是JSONP的来源 JSONP实现跨域基本思想：网页通过添加一个&lt;script&gt;元素（因为src属性），向服务器请求json数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。但只支持GET请求。 实践代码： 创建一个JSONP文件夹，在其中添加template.html以及server.js。 template.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;jsonp testing&lt;/p&gt;&lt;/body&gt;&lt;script&gt; function jsonp(&#123;url,params,callback&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let script=document.createElement('script'); params=JSON.parse(JSON.stringify(params)); let arrs=[]; for(let key in params)&#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; arrs.push(`callback=$&#123;callback&#125;`); script.src=`$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;`; document.body.appendChild(script); window[callback]=function(data)&#123; resolve(data); document.body.removeChild(script); &#125; &#125;) &#125; jsonp(&#123; url:'http://localhost:3000/say', params:&#123; wd:'I love you' &#125;, callback:'show' &#125;).then(data=&gt;&#123; console.log(data); &#125;)&lt;/script&gt;&lt;/html&gt; server.js 123456789101112131415161718var express = require('express');var router = express.Router();var app = express();router.get('/say',function(req,res,next) &#123; //要响应回去的数据 let data = &#123; username : 'zs', password : 123456 &#125; let &#123;wd , callback&#125; = req.query; console.log(wd); console.log(callback); // 调用回调函数 , 并响应 res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`);&#125;)app.use(router);app.listen(3000); 上述代码实现的就是我们的html文档，使用jsonp方法向http://localhost:3000/say发起请求。当服务器监听到请求之后，将响应的数据放在指定名字的回调函数中传回来，然后调用callback回调函数执行resolve(data)。因为jsonp函数返回的是一个Promise对象，所以之后可以调用.then执行后续的console.log操作。 结果： 如果是AJAX请求： 12345678var xhr=new XMLHttpRequest();xhr.onReadyStateChange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; alert(xhr.responseText); &#125;&#125;xhr.open('get','http://localhost:3000/say',true);xhr.send(); 就会报跨域的错误：","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"乱序数组的三种方法","slug":"乱序数组的三种方法","date":"2020-03-28T05:27:18.000Z","updated":"2020-03-30T01:49:58.115Z","comments":true,"path":"2020/03/28/乱序数组的三种方法/","link":"","permalink":"http://delaprada.com/2020/03/28/%E4%B9%B1%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"今天面试的时候被问到实现乱序数组的最简便的方法，自己只知道使用Math.random()和结果数组的笨方法…总结一下。 sort()方法数组的sort()方法是按照return的值的正负来去做排序判定，所以实现的思路可以是使得返回的值随机正负。 12345function randArr(arr)&#123; return arr.sort(()=&gt;&#123; return (Math.random()-0.5); &#125;)&#125; Math.random()是生成0.0（包含）~1.0（不包含）之间的随机数。 但这么做是一个伪排序。参考：https://zhuanlan.zhihu.com/p/33260052 有大神做过测试，进行10000次乱序操作后，元素大概率停留在自己的初始位置上。 洗牌算法思路是： 找到数组的最后一个元素 从数组开头到最后一个元素之间，找到随机的一个数 交换两个元素的位置 此时最后一个元素已经是乱序后的结果 指向最后一个元素的索引前移 直到指向索引为0 1234567891011//洗牌算法function randArr3(arr)&#123; var length=arr.length; var r=length; var rand=0; while(r)&#123; rand=Math.floor(Math.random()*(r--)); [arr[r],arr[rand]]=[arr[rand],arr[r]]; &#125; return arr;&#125; Math.random()+结果数组12345678910function randArr2(arr)&#123; var res=[]; var len=arr.length; for(var i=0;i&lt;len;++i)&#123; var index=Math.floor(Math.random()*arr.length); res.push(arr[index]); arr.splice(index,1); &#125; return res;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"每日一题——单词的压缩编码","slug":"每日一题——单词的压缩编码","date":"2020-03-28T01:18:31.000Z","updated":"2020-03-28T01:25:53.258Z","comments":true,"path":"2020/03/28/每日一题——单词的压缩编码/","link":"","permalink":"http://delaprada.com/2020/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/","excerpt":"","text":"单词的压缩编码给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。 例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。 对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。 那么成功对给定单词列表进行编码的最小字符串长度是多少呢？ 示例： 123输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]输出: 10说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。 提示： 1231 &lt;&#x3D; words.length &lt;&#x3D; 20001 &lt;&#x3D; words[i].length &lt;&#x3D; 7每个单词都是小写字母 。 思路： 首先要先读懂题意，如果是单词之间的覆盖，只能是后缀覆盖，而不能是中间覆盖；其次，不一定是相邻的单词之间会出现覆盖，有可能像[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;, &quot;atime&quot;]跨着来覆盖。 所以我们先按单词的长度进行降序排列，这样先将最大的添加到结果字符串中，后续判断较小的单词只需要使用indexOf方法，就能够判断是否在结果字符串中。 需要注意的是，单词之间的覆盖只能是后缀覆盖，所以使用indexOf判断的时候要加上“#”。 题解： 123456789101112131415161718/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var minimumLengthEncoding = function(words) &#123; words.sort(function(a,b)&#123; return b.length-a.length; &#125;) var res=\"\"; res+=words[0]+\"#\"; for(var i=1;i&lt;words.length;++i)&#123; //加上#号就控制必须是后缀部分 if(res.indexOf(words[i]+\"#\")===-1)&#123; res+=words[i]+\"#\"; &#125; &#125; return res.length;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——合并区间","slug":"每日一题——合并区间","date":"2020-03-26T07:16:28.000Z","updated":"2020-03-26T07:22:58.815Z","comments":true,"path":"2020/03/26/每日一题——合并区间/","link":"","permalink":"http://delaprada.com/2020/03/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","excerpt":"","text":"合并区间给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路： 将每个区间的第一个数字放入start数组中，将每个区间的第二个数字放入end数组中，对start数组和end数组进行排序。判断start[i+1]和end[i]的大小，如果前者小，则说明区间有覆盖，i++；如果前者大，说明区间没有覆盖，可以将这个结果push进结果数组res中，同时j=i+1（j最开始为0）。 题解： 123456789101112131415161718192021222324252627282930/** * @param &#123;number[][]&#125; intervals * @return &#123;number[][]&#125; */var merge = function(intervals) &#123; var start=[]; var end=[]; var res=[]; for(var i=0;i&lt;intervals.length;++i)&#123; start.push(intervals[i][0]); end.push(intervals[i][1]); &#125; start.sort(function(a,b)&#123; return a-b; &#125;) end.sort(function(a,b)&#123; return a-b; &#125;) for(var n=0,m=0;n&lt;intervals.length;++n)&#123; if(n==intervals.length-1||start[n+1]&gt;end[n])&#123; res.push([start[m],end[n]]); m=n+1; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——编辑距离","slug":"每日一题——编辑距离","date":"2020-03-25T02:15:59.000Z","updated":"2020-03-25T02:44:32.174Z","comments":true,"path":"2020/03/25/每日一题——编辑距离/","link":"","permalink":"http://delaprada.com/2020/03/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"编辑距离给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符 示例 1: 123456输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 示例 2: 12345678输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;) 思路： 动态规划的思想。 如果word1[i]===word2[j]，dp[i][j]=dp[i-1][j-1]，也就是说word1的第i个单词和word2的第j个单词相同的话，那word1前i个单词要变为word2前j个单词的编辑次数就会等于word1前i-1和单词变为word2前j-1个单词的编辑次数。 如果word1[i]!=word2[j]，那dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 dp[i-1][j-1]表示替换操作，也就是将word1[i]替换为word2[j]，那dp[i][j]就等于dp[i-1][j-1]+1，也就是将word1前i-1个单词变为word2前j-1个单词所要执行的编辑次数+1（一次替换操作）。 dp[i-1][j]表示删除操作，就是将word1前i-1个字符变为word2前j个字符所要执行的操作+1（一次删除操作，即将word1的第i个字符删掉） dp[i][j-1]表示插入操作，就是将word1前i个字符变为word2前j-1个字符所要执行的操作+1（一次插入操作，在word1插入一个和word2第j个字符一样的字符） 题解： 12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;number&#125; */var minDistance = function(word1, word2) &#123; var dp=[]; var len1=word1.length; var len2=word2.length; for(var i=0;i&lt;=len1;++i)&#123; dp[i]=new Array(); &#125; for(var j=0;j&lt;=len1;++j)&#123; dp[j][0]=j; &#125; for(var k=0;k&lt;=len2;++k)&#123; dp[0][k]=k; &#125; for(var n=1;n&lt;=len1;++n)&#123; for(var m=1;m&lt;=len2;++m)&#123; //这里表示的是word1[n]==word2[m],但是因为n和m是从1开始取的,所以比较的时候要-1 if(word1[n-1]==word2[m-1])&#123; dp[n][m]=dp[n-1][m-1]; &#125; else&#123; dp[n][m]=Math.min(dp[n-1][m-1],dp[n][m-1],dp[n-1][m])+1; &#125; &#125; &#125; return dp[len1][len2];&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——按摩师","slug":"每日一题——按摩师","date":"2020-03-24T08:57:23.000Z","updated":"2020-03-24T08:58:20.779Z","comments":true,"path":"2020/03/24/每日一题——按摩师/","link":"","permalink":"http://delaprada.com/2020/03/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%8C%89%E6%91%A9%E5%B8%88/","excerpt":"","text":"面试题 17.16. 按摩师一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1： 123输入： [1,2,3,1]输出： 4解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。 示例 2： 123输入： [2,7,9,3,1]输出： 12解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。 示例 3： 123输入： [2,1,4,5,3,1,1,3]输出： 12解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。 思路： 动态规划的思想。但是这题和最大上升子序列的动态规划思想不同。这题与背包问题都是要求一个对于整体来说最大的和，但是最大上升子序列是求一个最长的上升子序列，之前的数要比当前的数小才能做一次计算，和是否相邻无关，所以最大上升子序列还需要在内层加多一层循环。 题解： 最初想的方案： 内层多了一个循环。 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var massage = function(nums) &#123; var F=[]; if(nums.length==1)&#123; return nums[0]; &#125; for(var m=0;m&lt;nums.length;++m)&#123; F[m]=0; &#125; F[0]=nums[0]; F[1]=nums[1]; for(var i=2;i&lt;nums.length;++i)&#123; for(var j=0;j&lt;=i-2;++j)&#123; F[i]=Math.max(F[j]+nums[i],F[i]); &#125; &#125; var max=0; for(var t=0;t&lt;F.length;++t)&#123; if(F[t]&gt;max)&#123; max=F[t]; &#125; &#125; return max;&#125;; 后来看评论优化的题解： dp思想：F[i]=Math.max(F[i-1],F[i-2]+nums[i]); 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var massage = function(nums) &#123; var F=[]; if(nums.length==0)&#123; return 0; &#125; if(nums.length==1)&#123; return nums[0]; &#125; for(var m=0;m&lt;nums.length;++m)&#123; F[m]=0; &#125; F[0]=nums[0]; F[1]=Math.max(nums[0],nums[1]); for(var i=2;i&lt;nums.length;++i)&#123; F[i]=Math.max(F[i-1],F[i-2]+nums[i]); &#125; return F[nums.length-1];&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"由instanceof原生实现理解__proto__和prototype的区别","slug":"由instanceof原生实现理解-proto-和prototype的区别","date":"2020-03-24T08:04:15.000Z","updated":"2020-03-24T08:55:41.494Z","comments":true,"path":"2020/03/24/由instanceof原生实现理解-proto-和prototype的区别/","link":"","permalink":"http://delaprada.com/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前几天面试的时候被问到instanceof的原生实现，当时对__proto__和prototype的区别理解不是很透彻，一直记得的是几个月前在网上的某篇博客上看到的结论：“__proto__：和prototype其实是一个东西，prototype是官方所定义的属性，__proto__是浏览器自己对prototype所做的实现。”后来仔细再查了些文章发现似乎并不是这样。 __proto__和prototype的区别原型prototype原型的定义：每个js对象（除了null）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 比如我们定义一个构造函数Person： 123function Person(name)&#123; this.name=name;&#125; 这样我们就创建了一个对象（function也是对象），那这个Person构造函数是有它的prototype的。这个Person prototype的构造函数constructor就是这个Person构造函数。我们还可以在这个Person prototype上去定义一些共享的属性和方法。 1234567function Person(name)&#123; this.name=name;&#125;Person.prototype.name=\"Alice\";Person.prototype.sayHello=function()&#123; console.log(\"Hello \"+this.name);&#125; 这样写就在Person prototype上定义了公用的属性name和sayHello。 现在创建两个对象实例： 12345var person1=new Person();var person2=new Person();person1.name=\"Emma\";console.log(person1.name); //Emmaconsole.log(person2.name); //Alice 我们为这个person1定义了它的实例属性name为”Emma”，那person2没有定义它的实例属性，所以它会沿着原型链去找它的原型去找是否有这个属性，因为Person.prototype里定义了name属性，所以输出Alice。 如果Person.prototype中没有定义name属性，那person2.name输出的是undefined，构造函数里的this.name是不起作用的。 __proto__ 以上这幅图大致可以说明__proto__和prototype的关系。 现在来说一下我们使用new去创建一个构造函数实例的时候做了些什么： new的原生实现： 123456function new(Parent,...args)&#123; var obj=&#123;&#125;; obj.__proto__=Parent.prototype; var res=Parent.apply(obj,args); return typeof res==\"object\"?res:obj;&#125; 我们使用new创建一个实例的时候，我们将这个实例的__proto__指向构造函数的原型。 __proto__和prototype并不是一样的： constructor1234function Person()&#123;&#125;Person.prototype.constructor===Person; //true 这个由上图可以看出。 12345function Person()&#123;&#125;var person1=new Person();person1.constructor===Person; //true 但是person1是没有constructor属性的，而是通过原型链去找到Person.prototype上的constructor属性。 Object.prototypeObject.prototype是没有原型的，Object.prototype就是尽头。 instanceof的原生实现instanceof在MDN当中的定义就是object instanceof constructor，判断这个constructor的prototype是否在object的原型链上。object原型链上的原型我们可以通过__proto__来去获取。 12345678910111213function myinstanceof(left,right)&#123; var leftval=left.__proto__; //实例用__proto__ var rightval=right.prototype; //构造函数用prototype while(true)&#123; if(leftval==null)&#123; return false; //Object.prototype.__proto__为null &#125; if(leftval==rightval)&#123; return true; &#125; leftval=leftval.__proto__; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Promise实现任务顺序执行&并行执行&发起ajax请求","slug":"Promise实现任务顺序执行和并行执行","date":"2020-03-21T13:46:14.000Z","updated":"2020-03-24T01:17:01.763Z","comments":true,"path":"2020/03/21/Promise实现任务顺序执行和并行执行/","link":"","permalink":"http://delaprada.com/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/","excerpt":"","text":"Promise实现任务并行执行使用Promise.all方法： 123456789101112var p1=new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;)p1.then(result=&gt;result);var p2=new Promise((resolve,reject)=&gt;&#123; resolve('hi');&#125;)p1.then(result=&gt;result);var p=Promise.all([p1,p2]);p.then(result=&gt;console.log(result)); Promise实现任务顺序执行在.then里要return一个new Promise，这样后续才能继续使用.then执行后续操作： 1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) 输出： Promise封装ajax请求123456789101112131415161718192021222324252627282930function myHttpClient(method,url,data)&#123; return new Promise(function(resolve,reject)&#123; var xhr; if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125; else&#123; xhr=new ActiveXObject('Microsoft XMLHttp'); &#125; var method=method||'GET'; var data=data||null; xhr.open(method,url,true); xhr.onReadyStateChange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;=300)||xhr.status==304)&#123; resolve(xhr.responseText); &#125; else&#123; reject(new Error(xhr.statusText)); &#125; &#125; &#125; xhr.send(data); &#125;)&#125;myHttpClient('GET',url,null).then(function(data)&#123; console.log(data);&#125;,function(error)&#123; console.log(error);&#125;) 思想就是：将整个使用XMLHttpRequest去发起异步网络请求的操作封装在new Promise当中，执行函数返回一个Promise，那后续可以使用.then来执行后续的操作。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"设置display:none对DOM树和渲染树的影响","slug":"设置display-none对DOM树和渲染树的影响","date":"2020-03-21T01:50:17.000Z","updated":"2020-03-30T03:38:27.569Z","comments":true,"path":"2020/03/21/设置display-none对DOM树和渲染树的影响/","link":"","permalink":"http://delaprada.com/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"原本的样式12345678910111213141516171819&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .main&#123; width:100px; height:100px; background-color: lightyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"main\"&gt; display属性testing &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置display:none对渲染树的影响在原本的style中添加上display:none： 12345678&lt;style&gt; .main&#123; width:100px; height:100px; background-color: lightyellow; display:none; &#125;&lt;/style&gt; 页面上没有显示任何东西： 所以设置display:none是会将节点从渲染树中摘除的。 设置display:none对DOM树的影响我们在刚才的代码中添加上一段js代码： 1234&lt;script&gt; var node=document.getElementsByClassName(\"main\")[0]; console.log(node.innerText);&lt;/script&gt; 控制台输出： 说明DOM树中该节点并没有消失，否则不会获取到DOM上的信息。 设置display:none对CSS规则树的影响我们在div当中添加style样式： 123&lt;div class=\"main\" style=\"width:100px\"&gt; display属性testing&lt;/div&gt; 在script中添加： 1console.log(node.style.width); 控制台输出： 说明CSS规则树中该节点的样式没有消失。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"每日一题——水壶问题","slug":"每日一题——水壶问题","date":"2020-03-21T00:37:01.000Z","updated":"2020-03-21T00:43:46.398Z","comments":true,"path":"2020/03/21/每日一题——水壶问题/","link":"","permalink":"http://delaprada.com/2020/03/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/","excerpt":"","text":"有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: (From the famous *”Die Hard”* example) 12输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4输出: True 示例 2: 12输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5输出: False 思路： 当x=3,y=5,z=4的时候怎么倒出4L水： 首先装满x，将x中的3L水倒入y中， 然后再装满x，将x的水倒入y中，此时只能倒2L，那x中就剩下1L水 将y中的水倒掉，将x中的1L水倒入 x再装满3L水，倒入y中，此时y就有4L水 它的思路就是：x和y的最大公约数是否能够被z整除。与此同时要考虑，x和y加起来的大小是否比z要小，如果小的话就不可能装得下。还要考虑，两个壶为0的情况，因为mod操作是不能mod0的。 题解： 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @param &#123;number&#125; z * @return &#123;boolean&#125; */var canMeasureWater = function(x, y, z) &#123; var temp; if(x&gt;y)&#123; temp=x; x=y; y=temp; &#125; if(x+y&lt;z)&#123; return false; &#125; while(x!=0)&#123; temp=y; y=x; x=temp%x; &#125; if(y==0&amp;&amp;z==0)&#123; return true; &#125; else if(y==0&amp;&amp;z!=0)&#123; return false; &#125; else&#123; if(z%y==0)&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——矩阵重叠","slug":"每日一题——矩阵重叠","date":"2020-03-18T01:28:56.000Z","updated":"2020-03-18T01:31:05.226Z","comments":true,"path":"2020/03/18/每日一题——矩阵重叠/","link":"","permalink":"http://delaprada.com/2020/03/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/","excerpt":"","text":"矩形重叠矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 12输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]输出：true 示例 2： 12输入：rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]输出：false 说明： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。矩形中的所有坐标都处于 -10^9 和 10^9 之间。 思路： 两个矩形，我们只需要关注它们离彼此最近的两个点。两个矩阵只要靠左边矩形的右上角的x比右边矩形左下角的x要小（小于等于）的话，就不会重叠；或者是，靠左边矩形的右下角的y比右边矩形右上角y要大（大于等于）的话，也不会重叠。因为rec1和rec2的顺序不一定就是rec1在左，rec2在右，所以要考虑反过来情况。 题解： 12345678/** * @param &#123;number[]&#125; rec1 * @param &#123;number[]&#125; rec2 * @return &#123;boolean&#125; */var isRectangleOverlap = function(rec1, rec2) &#123; return !(rec1[2]&lt;=rec2[0]||rec2[2]&lt;=rec1[0]||rec1[1]&gt;=rec2[3]||rec2[1]&gt;=rec1[3]);&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——岛屿的最大面积","slug":"每日一题——岛屿的最大面积","date":"2020-03-15T01:13:59.000Z","updated":"2020-03-15T01:20:00.660Z","comments":true,"path":"2020/03/15/每日一题——岛屿的最大面积/","link":"","permalink":"http://delaprada.com/2020/03/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"岛屿的最大面积给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 思路：和腐烂的橘子的思想类似，使用广度优先遍历，然后queue来实现（JS中用普通数组，使用shift来获取列头元素，不要写错成pop()，c++中队列的pop()和JS中普通数组的shift()才是对应的）。而且要另外维护一个flag数组，用来记录每个数组中的元素是否已经判断过了，如果判断过了的话，就要将flag变为true，下一次不用再去判断。 用JS声明二维数组的方式： 12345678var a = new Array();for(var i=0;i&lt;3;i++)&#123; //一维长度为3 a[i] = new Array(); for(var j=0;j&lt;5;j++)&#123; //二维长度为5 a[i][j] = i+j; &#125;&#125; 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var maxAreaOfIsland = function(grid) &#123; var q=[]; var res=0; var count=0; var step=[[-1,0],[1,0],[0,1],[0,-1]]; //用来进行广度遍历 var flag=new Array(); for(var n=0;n&lt;grid.length;++n)&#123; flag[n]=new Array(); for(var m=0;m&lt;grid[0].length;++m)&#123; flag[n][m]=false; &#125; &#125; for(var i=0;i&lt;grid.length;++i)&#123; for(var j=0;j&lt;grid[0].length;++j)&#123; if(grid[i][j]==1&amp;&amp;flag[i][j]==false)&#123; count++; q.push([i,j]); flag[i][j]=true; while(q.length!==0)&#123; var temp=q.shift(); for(var k=0;k&lt;step.length;++k)&#123; var x=temp[0]+step[k][0]; var y=temp[1]+step[k][1]; if(x&gt;=0&amp;&amp;x&lt;grid.length&amp;&amp;y&gt;=0&amp;&amp;y&lt;grid[0].length)&#123; if(grid[x][y]==1&amp;&amp;flag[x][y]==false)&#123; q.push([x,y]); flag[x][y]=true; count++; &#125; &#125; &#125; &#125; if(count&gt;res)&#123; res=count; &#125; count=0; &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——最大上升子序列","slug":"最大上升子序列","date":"2020-03-14T03:11:50.000Z","updated":"2020-03-14T03:13:45.148Z","comments":true,"path":"2020/03/14/最大上升子序列/","link":"","permalink":"http://delaprada.com/2020/03/14/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 思路： 动态规划的思想。先初始化每个元素的最大上升子序列长度为1。当前元素的最大上升子序列数应为在它前面比该元素小的元素的最大上升子序列数的最大值+1。 题解： 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var lengthOfLIS = function(nums) &#123; if(nums.length==0)&#123; return 0; &#125; var dp=[]; for(var i=0;i&lt;nums.length;++i)&#123; dp[i]=1; &#125; for(var j=0;j&lt;nums.length;++j)&#123; for(var k=0;k&lt;j;++k)&#123; if(nums[j]&gt;nums[k])&#123; dp[j]=Math.max(dp[k]+1,dp[j]); &#125; &#125; &#125; var res=1; for(var p=0;p&lt;nums.length;++p)&#123; if(dp[p]&gt;res)&#123; res=dp[p]; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"如何理解异步","slug":"如何理解异步","date":"2020-03-13T02:59:49.000Z","updated":"2020-03-13T03:03:10.481Z","comments":true,"path":"2020/03/13/如何理解异步/","link":"","permalink":"http://delaprada.com/2020/03/13/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/","excerpt":"","text":"什么是异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。 例如： 1234setTimeout(function()&#123; XXX;&#125;,1000)console.log(\"XXX\"); setTimeout就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。setTimeout是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行setTimeout任务的第二部分，执行XXX。 如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。 异步编程的解决方案回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。callback的意思就是“重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 PromisePromise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。 Promise的话任务也是分为两个部分，new Promise作为第一部分立即执行，然后将执行权交给其他任务，当执行完毕后才会执行event queue当中的回调函数。 Promise的最大问题是代码冗余：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 （其他代码部分属于一个协程，中间的yield部分属于另一个协程） 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 执行gen（）的时候，它执行了var url = &#39;https://api.github.com/users/github&#39;;操作，因为遇到了yield，所以交出了当前异步任务的执行权。执行.next()方法的时候才会执行fetch(url)操作，fetch(url)任务执行完毕之后，才会将执行权交还给异步任务，去执行异步任务的第二部分。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"每日一题——零钱兑换","slug":"每日一题——零钱兑换","date":"2020-03-08T00:33:18.000Z","updated":"2020-03-08T00:38:37.811Z","comments":true,"path":"2020/03/08/每日一题——零钱兑换/","link":"","permalink":"http://delaprada.com/2020/03/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","excerpt":"","text":"零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11输出: 3 解释: 11 &#x3D; 5 + 5 + 1 示例 2: 12输入: coins &#x3D; [2], amount &#x3D; 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 思路：动态规划的思想，每种硬币都找到当前自身的最优解，从而求出结果为amount时的最优解。在初始化的时候，要为每种金额的硬币声明一个初始的解，这个解应该是个比amount要大的值（因为解最大为amount）。这样我们在做结果判断的时候就可以知道，如果当前解是amount+1就说明没有组合能组成总金额。 题解： 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; coins * @param &#123;number&#125; amount * @return &#123;number&#125; */var coinChange = function(coins, amount) &#123; coins.sort(function(a,b)&#123; return a-b; &#125;) console.log(coins); var F=[]; for(var i=0;i&lt;=amount;++i)&#123; F[i]=amount+1; &#125; F[0]=0; for(var j=0;j&lt;=amount;++j)&#123; for(var k=0;k&lt;coins.length;++k)&#123; if(j&lt;coins[k])&#123; break; &#125; else&#123; F[j]=Math.min(F[j-coins[k]]+1,F[j]); //注意此处是F[j] &#125; &#125; &#125; return F[amount]!==amount+1?F[amount]:-1;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——腐烂的橘子","slug":"每日一题——腐烂的橘子","date":"2020-03-04T01:47:21.000Z","updated":"2020-03-04T07:26:47.849Z","comments":true,"path":"2020/03/04/每日一题——腐烂的橘子/","link":"","permalink":"http://delaprada.com/2020/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","excerpt":"","text":"在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 123456789101112输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。示例 3：输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1231 &lt;&#x3D; grid.length &lt;&#x3D; 101 &lt;&#x3D; grid[0].length &lt;&#x3D; 10grid&#96;[i][j]&#96; 仅为 0、1 或 2 思路： 广度优先搜索。广度优先搜索的话一般会使用队列的思想，深度优先搜索使用栈的思想。最主要还有如何去控制节点去上下左右遍历，所以我们要设置一个locs数组为：[[0,-1],[0,1],[1,0],[-1,0]]，在遍历每个队列元素时，都让它去和locs数组的每个元素进行相加减，得到这个元素上下左右的元素，将为1的元素（即新鲜橙子），变为2（即腐烂橙子）。因为我们要计算时间，但又不能将循环次数用来计时，所以我们将时间和节点的x，y坐标一齐作为一个元素进入队列。 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var orangesRotting = function(grid) &#123; var row=grid.length; var col=grid[0].length; var queue=[]; var locs=[[0,-1],[0,1],[1,0],[-1,0]]; var time=0; var x,y; for(var i=0;i&lt;row;++i)&#123; for(var j=0;j&lt;col;++j)&#123; if(grid[i][j]==2)&#123; queue.push([i,j,time]); &#125; &#125; &#125; while(queue.length!==0)&#123; //这是queue！！不要写成stack,先进先出是用shift [x,y,time]=queue.shift(); for(var t=0;t&lt;locs.length;++t)&#123; var new_x=x+locs[t][0]; var new_y=y+locs[t][1]; if(new_x&gt;=0&amp;&amp;new_x&lt;row&amp;&amp;new_y&gt;=0&amp;&amp;new_y&lt;col)&#123; if(grid[new_x][new_y]===1)&#123; queue.push([new_x,new_y,time+1]); grid[new_x][new_y]=2; &#125; &#125; &#125; &#125; for(var p=0;p&lt;row;++p)&#123; for(var q=0;q&lt;col;++q)&#123; if(grid[p][q]==1)&#123; return -1; &#125; &#125; &#125; return time;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——版本号比较 随机生成字符串 类型比较","slug":"每日一题——版本号比较-随机生成字符串","date":"2020-03-03T09:01:38.000Z","updated":"2020-03-03T14:14:37.536Z","comments":true,"path":"2020/03/03/每日一题——版本号比较-随机生成字符串/","link":"","permalink":"http://delaprada.com/2020/03/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"版本号比较比较版本号 （类似1.0.1/1.2.0/1.2/0.1）实现一个方法，用于比较两个版本号（version1、version2）如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则x.y.z，xyz均为大于等于0的整数，至少有x位 123456789101112131415161718192021222324252627282930313233function compare(str1,str2)&#123; str1=str1.split(\".\"); str2=str2.split(\".\"); str1=str1.map(Number); str2=str2.map(Number); var len; var len1=str1.length; var len2=str2.length; if(len1&gt;len2)&#123; len=len2; &#125; else&#123; len=len1; &#125; for(var i=0;i&lt;len;++i)&#123; if(str1[i]&gt;str2[i])&#123; return 1; &#125; else if(str1[i]&lt;str2[i])&#123; return -1; &#125; &#125; if(len1===len2)&#123; return 0; &#125; else if(len1&gt;len2)&#123; return 1; &#125; else&#123; return -1; &#125;&#125;console.log(compare('1.0.1','1.0')); 随机生成字符串随机生成字符串实现一个随机符串生成函数 randomStr()，要求如下：生成的随机的字符串应该以字母开头，并包含 [a-z][0-9] 这些字符。生成的字符串长度为 8。生成的字符串不能够在程序运行的生命周期中存在重复的情形。 1234567891011121314function randomString(len,chars)&#123; var res=''; for(var i=0;i&lt;len;++i)&#123; //因为Math.random()包括0但不包括1，所以可以直接乘上chars.length if(i==0)&#123; res+=chars[Math.floor(Math.random()*26)]; &#125; else&#123; res+=chars[Math.floor(Math.random()*chars.length)]; &#125; &#125; return res;&#125;console.log(randomString(8,'abcdefghijklmnopqrstuvwxyz0123456789')); 隐式类型转换下面代码中 a 在什么情况下会打印 1？1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 题解： 123456789var a=&#123; i:1, toString()&#123; return this.i++; &#125;&#125;if(a==1&amp;&amp;a==2&amp;&amp;a==3)&#123; console.log(1);&#125;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"易混淆JS题目——this指向 闭包","slug":"易混淆JS题目——this指向-闭包","date":"2020-02-18T02:23:00.000Z","updated":"2020-02-18T02:24:06.154Z","comments":true,"path":"2020/02/18/易混淆JS题目——this指向-闭包/","link":"","permalink":"http://delaprada.com/2020/02/18/%E6%98%93%E6%B7%B7%E6%B7%86JS%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94this%E6%8C%87%E5%90%91-%E9%97%AD%E5%8C%85/","excerpt":"","text":"Q：代码运行结果 1234567var a = function () &#123; this.b = 3; &#125;var c = new a();a.prototype.b = 9;var b = 7;a();console.log(b);console.log(c.b); 解： 整个代码在变量提升之后可以写为： 123456789101112var a;var c;var b;a=function()&#123; this.b=3;&#125;c=new a();a.prototype.b=9;b=7;a();console.log(b);console.log(c.b); 注意：函数声明的时候还没有执行！不要弄混了。当执行c=new a()的时候，会将函数a内部的this指向c，所以c.b此时就是3。a.prototype.b=9没有什么影响。b=7;表示将全局变量b赋值为7。此后执行了函数a()，要注意在默认情况下，函数中this的指向是指向全局作用域的，所以执行函数a()的话是把全局变量b的值变为3。所以输出的是3 3。 Q：以最小的改动解决以下代码的错误（可以使用es6） 123456789101112131415const obj = &#123;name: \" jsCoder\",skill: [\"es6\", \"react\", \"angular\"],say: function () &#123; for(var i = 0, len = this.skill.length; i&lt; len; i++)&#123; setTimeout(function()&#123; console.log('No.' + i + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i); &#125;&#125;&#125;;obj.say(); 解： 第一点：for循环当中有个异步函数，而且异步函数根据for循环i的值依次输出No.1，No.2，No.3，这样的话for循环中i必须使用let去声明，因为使用let才能让异步函数记住每一轮i的值，得到相应的输出结果。 第二点：在对象函数say中，有一个异步函数，它使用了this。源代码的意图是想让这个this表示对象obj，但是对象的方法say的this指向的是obj，但是这个方法内部的函数（使用了闭包）是指向全局变量的！这么写是得不到想要的结果的。所以要将setTimeout函数改为箭头函数，因为箭头函数它会继承上一层作用域的this，所以它会继承say函数的this，就会指向obj了。 修改后的代码为： 12345678910111213141516const obj = &#123; name: \" jsCoder\", skill: [\"es6\", \"react\", \"angular\"], say: function () &#123; for(let i = 0,len=this.skill.length; i&lt;len; i++)&#123; //闭包！！ setTimeout(()=&gt;&#123; console.log('No.' + (i+1) + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i+1); &#125; &#125;&#125;;obj.say(); Q：repeat 实现，使用JS实现一个repeat方法，调用这个 repeatedFunc(“helloworld”)，会alert4次 helloworld, 每次间隔3秒 1234function repeat(func, times, wait) &#123;&#125;const repeatFunc = repeat(alert, 4, 3000)repearFunc(\"helloworld\"); 解： 这种问题一般要结合闭包来实现。 1234567891011121314function repeat(func, times, wait)&#123; var count=0; var timer=null; return function()&#123; var args=[].slice.call(arguments); timer=setInterval(function()&#123; if(count==(times-1))&#123; clearTimeout(timer); &#125; func(args.join(\"\")); count++; &#125;,wait) &#125;&#125; 题目中说，调用repeatedFunc(&quot;helloworld&quot;)会有相关的结果，所以它应该是在函数中还有一个函数的，所以应该有个闭包。通过闭包可以记住count的值。注意clearTimeout要写在setInterval函数当中，这个和防抖节流不同，因为它只执行了一次函数，它是通过setInterval函数的循环才会输出多次结果，所以要写在里面才能够判断count的值是否已经到达输出次数。 Q：实现每隔1s输出一个数组的元素及其索引 解： 这题和上一题的思路类似，但是它没有需要说要调用的时候再去执行，那就不需要写return functionf(){}了。因为setInterval函数已经是output函数的内部函数，有闭包能够记住count的值了。 123456789101112131415function output(arr) &#123; var length = arr.length; var count = 0; var timer = null; timer = setInterval(function() &#123; if (count == length - 1) &#123; clearTimeout(timer); &#125; console.log(arr[count]); console.log(count); count++; &#125;, 1000);&#125;output([1, 2, 3, 4, 5]);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Vue之计算属性的应用","slug":"Vue之计算属性的应用","date":"2020-02-17T02:52:19.000Z","updated":"2020-02-17T02:54:22.665Z","comments":true,"path":"2020/02/17/Vue之计算属性的应用/","link":"","permalink":"http://delaprada.com/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"昨天面试的时候被问到了Vue计算属性相关的代码题，又是一脸懵逼呀…赶紧来总结一下。 面试官先出了第一道题，点击div时输出是什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 输出是3。 首先，computed中的属性都是以函数的形式声明的，看看官网的例子： 结果是： 123Original message: &quot;Hello&quot;Computed reversed message: &quot;olleH&quot; computed属性它所依赖的数据是data当中的，是要使用this来去获取的。所以计算属性c中的this.b和this.a其实是data当中的属性值。执行点击事件之后，b是会发生变化的，所以在计算属性c中输出this.b是会发生变化的，所以在控制台会输出3。因为计算属性creturn的是this.a，所以的值是不变的，是1。 接着面试官又出了第二道题，此时又输出什么？（其实面试官人真的好好，他的表述是此时会输出么？他这么问的话我就会倾向于回答不会输出） 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; if(false)&#123; console.log(this.b); return this.a; &#125; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 答案是不输出。此时c连渲染都不会发生。 最后面试官又问了第三道题，此时会输出什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;absdflj&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 此时这个计算属性并没有写在页面上，所以是不会监听c的值，此时控制台没有输出，页面显示的是：absdflj。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"JavaScript之变量提升","slug":"JavaScript之变量提升","date":"2020-02-17T01:58:59.000Z","updated":"2020-02-17T02:32:12.967Z","comments":true,"path":"2020/02/17/JavaScript之变量提升/","link":"","permalink":"http://delaprada.com/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"今天面试的时候被问到了变量提升的问题，一脸懵逼，掌握得不够熟练，写篇博客来总结一下。 JS代码解析规则 第一步为解释：先扫描所有的JS代码，把所有声明提升到顶端。 第二步为执行：执行就是操作一类的。 变量提升例一： 12console.log(a); //undefinedvar a=10; 因为有变量提升，上面的代码相当于： 123var a;console.log(a);a=10; 函数提升函数声明的两种方式 函数声明式 1function bar()&#123; &#125; 函数字面量式 1var bar=function()&#123; &#125; 注意：函数字面量式的提升和变量提升一样，都是只提升声明，不提升赋值，比如上面代码中函数字面量式，只会把var bar提升上去，但是函数声明式是会将整个函数体都提升上去。 例二： 1234foo(); //aaafunction foo()&#123; console.log(\"aaa\");&#125; 因为存在函数声明提升，函数声明提升会直接把整个函数提升到执行环境的最顶端。相当于： 1234function foo()&#123; console.log(\"aaa\");&#125;foo(); 注意：变量提升只提升变量名，而函数提升是会提升整个函数体。函数提升在变量提升之前。 例三： 1234foo(); //foo is not a functionvar foo = function()&#123; console.log(\"aaa\");&#125; 因为进行了变量提升（函数字面量式），上面的代码相当于： 12345var foo;foo();foo=function()&#123; console.log(\"aaa\");&#125; JS解析在遇到foo()时会默认当做函数来解析，所以会输出foo is not a function。 例四： 1234567console.log(foo);var foo=10;console.log(foo);function foo()&#123; console.log(10);&#125;console.log(foo); 输出： 上面的代码相当于： 12345678function foo()&#123; console.log(10);&#125;var foo;console.log(foo); //foo()&#123;console.log(10);&#125;foo=10;console.log(foo); //10console.log(foo); //10 第一个console.log(foo)之所以输出函数体，是因为var foo只是声明（提升了的声明），并没有赋值，所以它会调用上面的函数体。 面试题先看一道经典面试题： 123456789console.log(v1);var v1 = 100;function foo() &#123; console.log(v1); var v1 = 200; console.log(v1);&#125;foo();console.log(v1); 输出是： 1234&#x2F;&#x2F;undefined&#x2F;&#x2F;undefined&#x2F;&#x2F;200&#x2F;&#x2F;100 上面的代码相当于： 1234567891011var v1;console.log(v1); //undefinedv1=100;function foo()&#123; var v1; console.log(v1); //undefined v1=200; console.log(v1); //200&#125;foo();console.log(v1); //100 注意，如果内部没有声明v1的时候，函数才会到全局作用域去查找变量的赋值。但是如果函数作用域内部定义了的话，就不会到全局作用域去找。参照作用域链的定义。 看一道字节面试时候的题目： 1234567891011var a = 'byte'function foo() &#123; if (a === undefined) &#123; var a = 'dance' &#125; else &#123; a = 'bytedance' &#125; return a;&#125;console.log(foo());console.log(a); 输出为： 12&#x2F;&#x2F;dance&#x2F;&#x2F;byte 上面代码实际效果是： 1234567891011121314function foo()&#123; var a; if(a===undefined)&#123; a='dance'; &#125; else&#123; a='bytedance'; &#125; return a;&#125;var a;a='byte';console.log(foo());console.log(a); 在当前作用域有对变量进行声明的时候，是不会去上一级作用域去寻找变量的声明的。 因为console.log(a)在当前函数作用域找到了var a;，即a的定义，所以它不会去全局作用域去找a的声明（及值）。 上面的代码也是这个道理，a===undefined会找到当前函数作用域的var a;的定义，所以a的值为undefined。 参考：https://blog.csdn.net/qq_39712029/article/details/80951958 ​ https://blog.csdn.net/Demo_18/article/details/78493489","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Math.floor()和~~运算符的异同","slug":"Math-floor-和-的异同","date":"2020-02-10T03:14:06.000Z","updated":"2020-02-10T03:30:38.297Z","comments":true,"path":"2020/02/10/Math-floor-和-的异同/","link":"","permalink":"http://delaprada.com/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"今天在用JavaScript实现大数相加的时候，发现网上的解法当中有使用~~运算符，之前没有见过。在网上一查，说是Math.floor()的更好的一种表示方法，运行速度更快。但是将大数相加的代码中的~~换成Math.floor()发觉得不到正确的答案，所以想来分析一下异同。 ~和~~~运算符用于将整数变为-(N+1)。 例如： 1234~2 &#x3D;&#x3D;&#x3D; -3; &#x2F;&#x2F;true~1 &#x3D;&#x3D;&#x3D; -2; &#x2F;&#x2F;true~0 &#x3D;&#x3D;&#x3D; -1; &#x2F;&#x2F;true~-1 &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;true ~~运算符~~是Math.floor()的一个替代，相同的操作但是更快。可以使用它将任何浮点数转换为整数（下取整）。 例如： 123~~2 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~2.4 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~3.9 &#x3D;&#x3D;&#x3D; Math.floor(3); &#x2F;&#x2F;true, 3 ~~和Math.floor()在性能上的不同： # Browser Math.floor() Bitwise double NOT ~~ #1 Firefox 7.0.1 42ms 29ms #2 Firefox 7.0.1 44ms 28ms #3 Chrome 15 63ms 64ms #4 Chrome 15 63ms 68ms #5 IE8 265ms 192ms #6 IE8 324ms 190ms 大数相加在大数相加时，使用~~能够的到正确的结果： 但是使用Math.floor()时，结果是： 主要是因为当a数组已经pop完毕之后，再对a执行pop操作时，输出的是undefined。而~~操作undefined和Math.floor()操作undefined是会得出不同的结果的： 所以才会导致上面的结果。 参考：http://rocha.la/JavaScript-bitwise-operators-in-practice","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2020-02-04T10:17:33.000Z","updated":"2020-02-17T10:17:45.311Z","comments":true,"path":"2020/02/04/浏览器缓存/","link":"","permalink":"http://delaprada.com/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"缓存过程分析： 浏览器每次发起请求，都会先在浏览器缓存中查找请求的结果以及缓存标识 如果没有该请求的缓存结果和缓存标识的话，浏览器会向服务器发起http请求，服务器返回该请求结果和缓存规则 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强缓存和协商缓存浏览器缓存分为：强缓存和协商缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源。可以通过设置两种http header实现：Expires和Cache-Control。 Expires是http/1的产物。它用来指定资源到期的时间，Expires是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间之前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 1Expires: Thu, 10 Nov 2017 08:45:11 GMT 这个字段设置时有两个缺点： 由于是绝对时间，用户可能会将客户端本地的时间修改，而导致浏览器判断缓存失效，重新请求该资源。 写法太复杂，表示时间的字符串多个空格，少个字母都会导致非法属性从而失效 Cache-control是http/1.1的产物。和Expires的差别在于，Expires是绝对时间，Cache-control表示的是相对时间 1Cache-control: max-age=2592000 Cache-control字段常用的值： max-age：即最大有效时间 must-revalidate：如果超过了max-age的时间，浏览器必须向服务器发送请求，验证资源是否还有效 no-cache：不是不缓存的意思！表示可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用。 no-store：彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取 public：所有内容都可以被缓存（包括客户端和代理服务器，如CDN） private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。 自从http/1.1开始，Expires逐渐被Cache-control取代。Cache-control是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且Cache-control的可配置性比较强大。 强缓存判断是否缓存的依据来自于是否超出某个时间或者时间段，而不关心服务器端文件是否已经更新，这可能导致加载文件不是服务器端最新的内容。那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存：是由服务器来确定缓存资源是否可用，所以客户端与服务器端需要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 主要有以下两种标识： Last-Modified和If-Modified-Since： Last-Modified：浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加Last-Modified的header，值是这个资源在服务器端的最后修改时间。 If-Modified-Since：浏览器下一次请求这个资源，浏览器检测有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值。服务器再次收到这个资源的请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，可以直接从缓存读取。如果服务器端这个资源在If-Modified-Since之后被修改了，说明文件有更新，返回新的资源文件和200。 Etag和If-None-Match: Etag和If-None-Match返回的是一个校验码。Etag可以保证每一个资源是唯一的，资源变化都会导致Etag变化。 当浏览器第一次请求资源的时候，服务器会在响应报文中添加Etag（表示资源的标签）。当浏览器再次发起请求的时候，请求报文中会添加If-None-Match字段，其值是上一次响应报文中Etag的值。服务器收到请求报文的时候，会检查If-None-Match的值与当前资源Etag的值是否匹配。如果匹配，也就是资源没有被修改，返回304；如果不匹配，也就是服务器端资源被修改了，返回200，并返回新的资源。 为什么有了Last-Modified和If-Modified-Since还要Etag和If-None-Match呢？ 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用 某些文件修改非常频繁，比如在秒以下级别的时间内进行修改（比如1s内修改了N次），If-Modified-Since能检查到的粒度只能是秒级别的，这种修改无法判断。 协商缓存生效：返回304和Not Modified。即服务器端资源并没有更新，可以继续使用浏览器缓存中的结果。 协商缓存失败，返回200和请求结果。即服务器端资源更新了，获取服务器端的返回结果，并把请求结果和缓存标识存入浏览器缓存中 总结缓存机制： 强制缓存优先于协商缓存进行 若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match) 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。 Last-Modified/If-Modified-Since 和 Etag/If-None-Match的主要区别就是一个是通过时间判断资源是否已被更改，一个是通过Etag来判断。Etag/If-None-Match相比于Last-Modified/If-Modified-Since来说更好。 摘自：https://www.cnblogs.com/yayaxuping/p/9707471.html ​ https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器渲染过程","slug":"浏览器渲染过程","date":"2020-01-31T01:50:01.000Z","updated":"2020-02-18T03:29:31.895Z","comments":true,"path":"2020/01/31/浏览器渲染过程/","link":"","permalink":"http://delaprada.com/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","excerpt":"","text":"浏览器渲染的过程主要包括以下5步 浏览器将获取的HTML文档解析为DOM树 处理CSS标记，构成CSS规则树 将DOM树和CSS规则树合并为渲染树（rendering tree），生成渲染树 渲染树布局，确定每个节点对象在页面上的确切大小和位置 将渲染树的各个节点绘制到屏幕上 具体流程构建DOM树当浏览器接受到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。注意：DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。 构建CSS规则树浏览器解析CSS文件并生成CSS规则树。注意：CSS解析可以与DOM解析同时执行，但与script的执行互斥。 构建渲染树（Render Tree）通过DOM树和CSS规则树，浏览器可以通过它们构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。 渲染树生成后，还不能渲染到屏幕上。因为渲染到屏幕上需要得到各个节点的位置信息，这就需要布局的处理。 渲染树布局布局阶段从渲染树的根节点开始遍历，渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。浏览器通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。 渲染树绘制将渲染树绘制到浏览器上。 主流的一些浏览器排版（渲染）引擎 浏览器 排版引擎 Chrome Opera Blink Firefox Gecko IE Trident Safari WebKit 渲染阻塞渲染阻塞的原因：由于JavaScript可以操作DOM来修改DOM结构，可以操作CSS规则树来修改节点样式，这就导致浏览器在遇到&lt;script&gt;标签时，DOM构建将暂停，直到脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。 现在可以通过在&lt;script&gt;标签上增加属性defer或者async，解决上述问题。这两个属性使得script标签不会阻塞DOM的渲染，能够异步加载script脚本，不阻塞DOM渲染。 defer如果script标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行） 使用方法： asyncasync的设置，会使得script脚本异步加载。async的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。 用图表来展示： 文档渲染 应该为 文档解析 普通的script文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载。 资源的下载是在解析过程中进行的，虽说script1脚本会很快的加载完毕，但是他前边的script2并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待script2执行完毕后再执行。当这两个脚本都执行完毕后，才会继续解析页面。 defer文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。 asyncasync脚本会在加载完毕后执行。async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的。 浏览器的回流与重绘回流：对于整个网页重新渲染一遍。 会导致回流的操作有： 页面首次渲染 浏览器窗口大小发生变化 元素尺寸或位置发生变化 元素内容发生变化（文字数量或图片大小等） 元素字体大小变化 添加或删除可见的DOM元素 激活css伪类（例如:hover） 重绘：浏览器只需要对某个元素进行重新绘制即可 会导致重绘的操作有： 修改color/background-color/visibility 由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流操作一定会伴随重绘，重绘却不一定伴随回流。 那么如何针对回流和重绘写出性能更好的代码呢？ CSS： 避免使用table布局 尽可能在DOM树的最末端改变class 避免设置多层内联样式 将动画效果应用到position属性为absolute或fixed的元素上 避免使用css表达式（例如：calc()） JavaScript 避免频繁操作样式 避免频繁操作DOM。创建一个documentFragment，在它上面应用所有的DOM操作，最后再把它添加到文档中 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 DOM CSS JS之间的关系 CSS是不会阻塞DOM的解析的，JS是会阻塞DOM的解析的 CSS是会阻塞DOM的渲染的。如果没有这个策略的话，页面首先会呈现一个原始的模样，待CSS下载完后又变成另一个模样，这样会导致用户体验变差而且渲染是有成本的。 JS是会等待CSS加载完才会执行的（如果CSS文件在JS文件之前声明的话，那JS需要等待CSS文件加载完毕后才会执行）。 原因：因为JS有时需要查询（获取）元素的一些样式，这些样式是定义在CSS文件里的，所以CSS加载完之后再去执行JS会更好一些。 所以&lt;script&gt;最好放在底部，&lt;link&gt;最好放在头部，是因为JS会阻塞DOM树的解析，CSS不会阻塞DOM树的解析。 如果头部同时有&lt;script&gt;和&lt;link&gt;的情况下，最好将&lt;script&gt;放在&lt;link&gt;上面，是因为JS会等待CSS加载完毕后才会执行，但是放在头部的JS一般不会对样式进行查询修改，所以放在前面没有太大影响（比如说引入VUE的CDN的js代码就会在头部，但是和CSS样式是无关的） 参考： https://www.cnblogs.com/jiasm/p/7683930.html https://www.jianshu.com/p/e6252dc9be32","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"什么是哈希hash","slug":"什么是哈希hash","date":"2020-01-29T10:55:11.000Z","updated":"2020-01-30T09:36:28.293Z","comments":true,"path":"2020/01/29/什么是哈希hash/","link":"","permalink":"http://delaprada.com/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/","excerpt":"","text":"哈希Hash什么是Hash通过一些计算，把关键码值映射到数组中的位置来访问记录，这个过程称为散列（hash）。 重要组成： hash函数：把关键码值映射到位置的函数称为散列函数。用h表示。 hash表：存放记录的数组称为散列表。用HT表示。 槽（slot）：散列表中的一个位置称为一个槽。 设计hash表的目标是：使得对于任何关键码值K和某个散列函数h，i=h(K)是表中满足0&lt;=h(K)&lt;M（M为HT中槽的数目）的一个槽，并且记录在HT[i]存储的关键码值与K相等。 冲突解决在实际情况中，我们根据散列方法组织的数据库必须把存储的记录存放在不大的散列表中，以避免浪费过多的空间。这样的话，有可能有多个关键码值计算出来的h(K)是一样的，但又不能同时放在同一个槽中，此时就要使用冲突解决策略。 冲突解决策略冲突解决策略一般分为两类： 开散列方法（open hashing；也称为单链方法） 闭散列方法（closed hashing；也称为开地址方法） 开散列方法开散列方法的最简单形式把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放在这个槽的链表内。 闭散列方法闭散列方法把所有记录直接存储到散列表中。每条关键码值标记为kR，记录R有一个基槽，就是h(kR)，即由散列函数计算出来的槽。如果要插入一条记录R，而另一条记录已经占据了R的基槽，那么就把R存储在表的其他槽内。 桶式散列 一种实现闭散列的方法是把散列表中的槽分成多个桶(bucket)。把散列表中的M个槽分成B个桶，每个桶中包含M/B个槽。 散列函数把每一条记录分配到某个桶的第一个槽中。 如果这个槽已经被占用，那么就顺序地沿着桶查找，直到找到一个空槽。 如果一个桶全部被占满了，那么就把这条记录存储在表后具有无限容量的溢出桶（overflow bucket）中。 线性探查最常用的散列方法。当发生冲突时，从当前基槽开始往后查找，有空位则将记录放进去。例如，2037原本应放在7的槽中，但是7已经被占用，所以往后查找空位，8是空的，于是将2037放进去。 但是这种方法会导致基本聚集。例如在上例中，下一条记录放到第2个槽的概率就是6/10了，因为取模后值为7,8,9,0,1,2都会放到第2个槽中。在理想情况下，表中的每个空槽都应该有相同的机会接受到下一个要插入的记录。 改进的冲突解决方法如何避免基本聚集呢？ 一种可能的改进方式是仍然使用线性探查，但是跳过一些槽，而且每次跳过常数c个而不是1个槽。这会生成探查函数：P(K,i)=ci。 例如，如果常数c是2的话：如果基槽被占用的话，第一次会找基槽+2的位置，看是否被占用，如果被占用了，第二次会找基槽+4的位置，如果还是被占用，则找基槽+6的位置，以此类推。即从基槽开始的偏移量将会为2,4,6。 另一种方法是使用二次探查函数（对于某些常数c1,c2,c3）：p(K,i)=c1i&lt;sup&gt;2&lt;/sup&gt;+c2i+c3。一个最简单的变体就是p(K,i)=i&lt;sup&gt;2&lt;/sup&gt;。 例如，对于一个长度M=101的散列表，假定对于关键码k1和k2，h(k1)=30，h(k2)=29。k1的探查序列为30,31,34,39；k2的探查序列为29,30,33,38。这样，尽管k2会在第二步探查k1的基槽，这两个关键码的探查序列此后就立即分开了。 双散列方法即由两个散列函数，一个散列函数用于计算基槽，另一个散列函数用于确定线性探查中的常数。即线性探查此时的形式为：p(K,i)=i*h2(K)。 例如，假定散列表的长度是M=101，有3个关键码k1，k2，k3，h(k1)=30，h(k2)=28，h(k3)=30，h2(k1)=2，h2(k2)=5，h2(k3)=5。那么k1的探查序列为：30,32,34,36等；k2的探查序列为：28,33,38,43等；k3的探查序列为：30,35,40,45等。这样关键码之间就不会共享同一段探查序列了。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"事件绑定 事件监听 事件委托","slug":"事件绑定-事件监听-事件委托","date":"2020-01-18T08:58:07.000Z","updated":"2020-02-05T12:49:30.054Z","comments":true,"path":"2020/01/18/事件绑定-事件监听-事件委托/","link":"","permalink":"http://delaprada.com/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件绑定为了让JavaScript对用户的操作作出响应，首先要对DOM元素绑定事件处理函数。 三种常用的绑定事件的方法： 在DOM元素中直接绑定 在JavaScript代码中绑定 绑定事件监听函数 在DOM元素中直接绑定我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。 123456&lt;input type=\"button\" value=\"click me\" onclick=\"hello()\"&gt;&lt;script&gt;function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 在JavaScript代码中绑定事件在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 123456&lt;input type=\"button\" value=\"click me\" id=\"btn\"&gt;&lt;script&gt;document.getElementById(\"btn\").onclick = function()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 使用事件监听绑定事件绑定事件的另一种方法是用 addEventListener() 或 attachEvent()来绑定事件监听函数。 事件监听的优点： 可以绑定多个事件 常规的事件绑定（例如onclick）只执行最后绑定的事件，会产生事件覆盖。 12345678910&lt;input type=\"button\" value=\"click me\" id=\"btn3\"&gt;&lt;script&gt;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function()&#123; alert(\"hello 1\"); //不执行&#125;btn3.onclick = function()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 使用addEventListener的话两个事件都会执行： 123456789101112&lt;input type=\"button\" value=\"click me\" id=\"btn4\"&gt;&lt;script&gt;var btn4 = document.getElementById(\"btn4\");btn4.addEventListener(\"click\",hello1);btn4.addEventListener(\"click\",hello2);function hello1()&#123; alert(\"hello 1\"); //执行&#125;function hello2()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 关于事件监听，有3个事件阶段（事件流包括三个状态）：捕获阶段，目标阶段，冒泡阶段。这三个阶段也叫作事件流。 事件捕获当一个事件触发后，从window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点，都会触发对应事件。 事件冒泡当事件到达目标节点后，会沿着捕获阶段路线原路返回。同样，所有经过的节点，都会触发对应的事件。 通过栗子来理解两个事件机制： 假设有body和body节点下的div1均有绑定了一个点击事件。 效果： 当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件 当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件（默认是false，在事件冒泡阶段执行） useCapture：用于指定事件是否在捕获或冒泡阶段执行 12345678910111213141516171819//当useCapture为默认false时,为事件冒泡&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印div1 打印body 1234567891011121314151617//当useCapture为true时,为事件捕获&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;,true) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印body 打印div1 事件委托利用冒泡原理，把事件加到父元素或祖先元素上，触发执行效果。 12345678910111213141516171819202122&lt;script&gt; window.onload = function()&#123; let div = document.getElementById('div'); div.addEventListener('click',function(e)&#123; console.log(e.target) &#125;) let div3 = document.createElement('div'); div3.setAttribute('class','div3') div3.innerHTML = 'div3'; div.appendChild(div3) &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=\"div\"&gt; &lt;div class=\"div1\"&gt;div1&lt;/div&gt; &lt;div class=\"div2\"&gt;div2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 虽然没有给div1和div2添加点击事件，但是无论是点击div1还是div2都会打印当前节点（console.log(e.target)）。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。 举个栗子： 分别点击div1、div2、div3： 无论后代新增了多少个节点，一样具有点击事件的功能。但是如果是传统的事件绑定的话无法对动态添加的元素而动态地添加事件。 事件委托的优点 提高性能：每一个函数都会占用内存空间。只需要添加一个事件处理程序代理所有事件，所占用的内存空间更少。 动态监听：使用事件委托可以自动绑定动态添加的元素。即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。 参考：https://www.cnblogs.com/soyxiaobi/p/9498357.html ​ http://blog.xieliqun.com/2016/08/12/event-delegate/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"分析parseInt()","slug":"分析parseInt","date":"2020-01-18T03:56:24.000Z","updated":"2020-01-18T07:05:51.564Z","comments":true,"path":"2020/01/18/分析parseInt/","link":"","permalink":"http://delaprada.com/2020/01/18/%E5%88%86%E6%9E%90parseInt/","excerpt":"","text":"parseInt()公式1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 parseInt(071)和parseInt(&quot;071&quot;)的区别parseInt(&quot;071&quot;)就是简单将字符串转换为数字： 如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。 以0开头也是转换为十进制。也有说转换为十六进制或者八进制，但是在chrome中实践是十进制。 parseInt(071)就是将071用八进制进行转换： 判断[‘1’,’2’,’3’].map(parseInt)的输出你可能觉得会是[1,2,3]，但实际上是[1,NaN,NaN]。我们来仔细分析一下： map的函数格式 1map((item, index, thisArr) &#x3D;&gt; ( newArr )) 参数解析： item: callback 的第一个参数，数组中正在处理的当前元素 index: callback 的第二个参数，数组中正在处理的当前元素的索引 thisArr: callback 的第三个参数，map 方法被调用的数组 parseInt的格式 上面讲到： 1parseInt(string, radix) 通过上述对 map 和 parseInt 函数的分析可以知道，执行方法时，map给parseInt传递了三个参数: 1parseInt(item, index, thisArr) 因此，索引index会传入parseInt函数当做基数radix。 其中第三个参数会被 parseInt 忽略，因此会依次执行： 123456parseInt('1', 0)// radix 为 0，默认以十进制解析字符串，返回 1parseInt('2', 1)// radix 为 1，不在 2 ~ 36 之间，返回 NaNparseInt('3', 2)// radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN 参考：https://www.cnblogs.com/wx1993/p/8417817.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2020-01-17T02:31:56.000Z","updated":"2020-01-17T02:35:23.204Z","comments":true,"path":"2020/01/17/防抖与节流/","link":"","permalink":"http://delaprada.com/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖和节流如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖（debounce）和节流（throttle）的方式来减少调用频率，同时又不影响实际效果。 防抖含义：当持续触发事件时，一定时间段内没有在触发事件，事件处理函数才会执行一次；如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 代码实现： 123456789101112131415function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 防抖是通过闭包实现的，所以timeout是会被缓存的。如果在频繁触发事件之后的一段时间内，又再次触发了事件，那就会使用clearTimeout清除setTimout设置的timout，重新计时。 具体完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125; &#125; // 处理函数 function handle() &#123; console.log(Math.random()); &#125; // 滚动事件 window.addEventListener('scroll', debounce(handle, 1000)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;防抖演示1&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示2&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示3&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示4&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示5&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示6&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示7&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示8&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示9&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示10&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示11&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示12&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示13&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示14&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示15&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示16&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在网页运行的时候我们会看到，当在滚动页面操作停止后1s，控制台会有输出。这就是防抖。 节流当持续触发事件时，保证每隔一定时间段内只调用一次事件处理函数。 用定时器实现节流： 1234567891011121314151617var throttle=function(func,delay)&#123; var timer=null; return function()&#123; var context=this; var args=arguments; if(!timer)&#123; timer=setTimeout(function()&#123; func.apply(context,args); timer=null; &#125;,delay); &#125; &#125;&#125;function handle()&#123; console.log(Math.random());&#125;window.addEventListener('scroll',throttle(handle,1000)); 节流也是通过闭包实现的。所以会把timer缓存起来，但是由于每次执行setTimeout函数时都设置timer为null，所以每次调用都可以执行if语句当中的内容。同时，下一次滚动事件不会影响上一次的事件处理函数，所以不会重新计时。 将节流代码放入上个例子的具体实现中会发现，执行滚动页面操作后，都会以同一频率在控制台中输出值。 参考：https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"https SSL/TLS握手过程","slug":"https-SSL-TLS握手过程","date":"2020-01-16T13:00:04.000Z","updated":"2020-01-16T13:05:07.058Z","comments":true,"path":"2020/01/16/https-SSL-TLS握手过程/","link":"","permalink":"http://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/","excerpt":"","text":"SSL/TLS 握手过程详解http协议是明文传输，不确认通信方，不保证传输数据完整的协议。它带来了三大风险： （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。 （2） 篡改风险（tampering）：第三方可以修改通信内容。 （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 http协议是明文传输，在安全性方面比较差。https协议使用了SSL/TLS协议来进行加密。SSL/TLS握手是为了安全地协商出一份对称加密的秘钥。 SSL/TLS握手过程 Client Hello 握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。 Server Hello 第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。 注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Hello Done Server Hello Done通知客户端Server Hello过程结束。 Certificate Verify 客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。 https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的 Client Key Exchange 上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。 至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。 为什么要使用三个随机数？ 这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。 最重要理解前六步 Change Cipher Spec（Client） 这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。 Encrypted Handshake Message(Client) 这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。 Change Cipher Spec(Server) 这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server) 这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data 到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html ​ https://juejin.im/post/584b76d3a22b9d0058d5036f","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CSS 圣杯布局和双飞翼布局","slug":"CSS-圣杯布局和双飞翼布局","date":"2020-01-15T08:49:17.000Z","updated":"2020-01-15T12:46:08.385Z","comments":true,"path":"2020/01/15/CSS-圣杯布局和双飞翼布局/","link":"","permalink":"http://delaprada.com/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"CSS 圣杯布局和双飞翼布局两个常见的前端布局。圣杯布局和双飞翼布局作为经典的三栏式布局是面试中的常客。两种布局达到效果上基本相同，都是两边两栏宽度固定，中间栏宽度自适应。在HTML结构上中间栏在最前面保证了最先渲染中间提升性能（因为这两种布局都比较老，我认为在现代浏览器中这点儿性能优化效果并不是很大），并且兼容性良好。两种布局的实现方法前半部分相同，后半部分的实现各有利弊，下面会简单介绍两者的区别。 圣杯布局代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; background-color: skyblue; height:60px; line-height:60px; /*文字水平垂直居中*/ &#125; .container&#123; overflow:hidden; /*因为内部都是浮动元素，所以要设置overflow来撑起父元素*/ padding:0 100px; /*左右内边距为100px*/ &#125; .main&#123; width:100%; background-color: peachpuff; height:100px; line-height: 100px; float:left; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; float:left; margin-left:-100%; /*让left前移一行*/ position:relative; left:-100px; &#125; .right&#123; background-color: pink; width:100px; height:100px; line-height:100px; float:left; margin-left:-100px; /*right只需要前移right的宽度即可*/ position:relative; /*container设置了padding,所以要相对定位移动才能将left和right移动到对应的位置*/ right:-100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 设置父元素container为overflow:hidden，撑起父元素，子元素main、left、right均设为float:left，浮动起来。效果如下： 为了让main模块自适应，将其设为100% 为了让left和right模块跑上去，设置left模块的margin:-100%，可以理解为：负的话就是向上前进，正值的话就是直接的间隔；right模块就设置为margin:-100px，大小为right模块的宽度 为了使main模块往里收，设置.container{ padding: 0 100px}，即设置左右内边距。 利用相对定位移动left和right 双飞翼布局代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; height:60px; background-color: skyblue; line-height:60px; &#125; .container&#123; overflow:hidden; &#125; .main&#123; width:100%; height:100px; line-height:100px; float:left; background-color: peachpuff; &#125; .inner-main&#123; margin-left:100px; /*通过在main内部再设置一个div来进行左右模块的间隔布局*/ margin-right:100px; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; margin-left:-100%; float:left; &#125; .right&#123; background-color: yellow; width:100px; height:100px; line-height:100px; margin-left:-100px; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"inner-main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算。 圣杯布局和双飞翼布局的主要区别： 圣杯布局是设置container的padding属性以及left和right模块的position:relative，left:-100px或right:-100px 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算 参考：https://segmentfault.com/a/1190000004579886","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"JavaScript模块化编程","slug":"JavaScript模块化编程","date":"2020-01-14T15:10:50.000Z","updated":"2020-01-14T15:11:30.414Z","comments":true,"path":"2020/01/14/JavaScript模块化编程/","link":"","permalink":"http://delaprada.com/2020/01/14/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/","excerpt":"","text":"模块化编程目录： AMD CMD commom.js ES6 Module AMDAMD是依赖前置，提前执行。AMD一开始是CommonJS规范中的一个草案，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。 AMD的基本语法通过define来定义一个模块，使用require可以导入定义的模块。 用define定义无依赖的模块： 12345//a.js//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数define(function()&#123; return 1;&#125;) 用define定义有依赖的模块： 1234567define([\"alpha\"], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 用require进行模块加载： 123require(['math'], function(math) &#123; math.add(2, 3);&#125;); AMD的特点对于依赖的模块，AMD推崇依赖前置，提前执行。也就是定义模块和加载模块都要在一开始就把依赖写好。例如define函数当中的[&quot;alpha&quot;]，就是定义模块当中的依赖；require函数当中的[&quot;math&quot;]是加载模块当中的依赖。 CMDCMD是依赖就近，延迟执行。 1234567891011121314151617181920212223//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;); //CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); CMD是在用到了某个模块的时候再去require，类似按需加载。 CMD的特点对于依赖的模块，CMD推崇依赖就近，延迟执行。也就是说，只有到require时依赖模块才执行。 摘自：https://segmentfault.com/a/1190000004873947 CommonJS基本用法 通过module.exports或者exports来输出模块 通过require来导入模块 1234567891011121314151617181920//a.jsmodule.exports = function () &#123; console.log(\"hello world\")&#125;//b.jsvar a = require('./a');a();//\"hello world\"//或者//a2.jsexports.num = 1;exports.obj = &#123;xx: 2&#125;;//b2.jsvar a2 = require('./a2');console.log(a2);//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125; CommonJS的特点 所有代码都运行在模块作用域，不会污染全局作用域 模块都是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果。如果想要再次执行，可清楚缓存 require返回的值是被输出的值的拷贝，模块内部的变化不会影响这个值 ES6 Module基本用法： export或export default来输出模块 import来导入模块 （export default就是能够为导入的模块自定义名称，这样就不用知道模块在原本的js文件当中的名字，按名字导入了） 1234567891011//a.jsvar name = 'lin';var age = 13;var job = 'ninja';export &#123; name, age, job&#125;;//b.jsimport &#123; name, age, job&#125; from './a.js';console.log(name, age, job);// lin 13 ninja 12345678//a2.jsexport default function () &#123; console.log('default ');&#125;//b2.jsimport customName from './a2.js';customName(); // 'default' ES6 Module的特点（对比CommonJS） CommonJS模块是运行时加载，ES6 Module是编译时输出接口； CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口（对应名字单独加载，加载这个模块想=需要的）； CommonJS输出是值的拷贝，ES6 Module输出的是值的引用，被输出模块的内部的改变会影响引用的改变； CommonJS this指向当前模块，ES6 Module this指向undefined; 参考：https://juejin.im/post/5db95e3a6fb9a020704bcd8d","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"异步以及异步编程解决方案","slug":"Generator函数-async函数","date":"2020-01-14T12:43:59.000Z","updated":"2020-04-02T01:03:23.205Z","comments":true,"path":"2020/01/14/Generator函数-async函数/","link":"","permalink":"http://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/","excerpt":"","text":"什么是异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。 例如： 1234setTimeout(function()&#123; XXX;&#125;,1000)console.log(\"XXX\"); setTimeout就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。setTimeout是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行setTimeout任务的第二部分，执行XXX。 如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。 异步编程方案异步编程也有多种解决方案，其演变过程是：回调函数—》Promise—》Generator—》async/await，每个演变都解决了之前的一些痛点。 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。callback的意思就是“重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 也就是说在执行readFile的时候，执行权交给了主线程执行栈的同步任务，同步任务执行完毕后才会执行这个readFile的回调。 回调函数的缺点回调函数会导致回调地狱。 比如现在有多个异步任务，且任务有依赖关系（一个任务需要拿到另一个任务成功后的结果才能开始执行）的时候，回调的方式写出来的代码就会像这样： 1234567891011getData1(data1 =&gt; &#123; getData2(data1, data2 =&gt; &#123; getData3(data2, data3 =&gt; &#123; getData4(data3, data4 =&gt; &#123; getData5(data4, data5 =&gt; &#123; // 终于取到data5了 &#125;) &#125;) &#125;) &#125;)&#125;) 这种多层嵌套的结构就是回调地狱，这种情况下代码的可读性很差。 Promise因此就出现了Promise。Promise的关键点就是将回调函数的嵌套改为了链式调用。 我们使用new Promise去创建一个Promise实例，这个Promise实例会传入一个函数作为参数，函数又有两个函数作为参数，分别是：resolve、reject。 执行resolve函数，Promise实例的状态会变为fulfilled，后续就会去执行.then回调函数 执行reject函数，Promise实例的状态会变为rejected，后续就会去执行.catch回调函数，或者.then的第二个回调函数。 3种状态Promise实例有三种状态： pending（进行中） fulfilled（已成功） rejected（已失败） fulfilled和rejected有可以说是已成功和已失败，这两种状态又归为已完成状态 resolve和reject调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调。resolve和reject两种函数只会执行一种，执行了其中一个之后就不会执行另一个了。 基本结构123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; //做一些事情 //然后在某些条件下resolve，或者reject（以下代码） if(/* 条件随便写 */)&#123; resolve() &#125; else&#123; reject() &#125;&#125;)p.then(()=&gt;&#123; //如果p的状态被resolve了，就进入这里&#125;,()=&gt;&#123; //如果p的状态被reject&#125;) 简单来说，这种.then.then.then的编码方式，就是Promise。 它的异步体现在，new Promise部分是立即执行的，那执行完毕后，就会将执行权交给主线程执行栈的同步任务，同步任务执行完毕后才会去执行.then回调。这里涉及JavaScript事件执行机制Eventloop。 Promise实现多任务顺序执行1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) 需要注意的是：每个.then中要返回一个new Promise对象，把任务放在Promise中，后续才能继续使用.then去执行后续操作。 Promise实现多任务并行（即A、B任务都执行完毕了才能执行C任务）：123456789101112var p1=new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;)p1.then(result=&gt;result);var p2=new Promise((resolve,reject)=&gt;&#123; resolve('hi');&#125;)p1.then(result=&gt;result);var p=Promise.all([p1,p2]);p.then(result=&gt;console.log(result)); 这里主要用到Promise.all这种结构。Promise.all([p1,p2])接受一个数组作为参数，数组的元素都是Promise实例，只有当数组中所有Promise实例的状态都变为fulfilled的时候，这个Promise.all的实例才会变为fulfilled，才能执行后续的.then操作。 和Promise.all相关的还有Promise.race，那Promise.race实例的状态是等于其参数中第一个执行完毕的Promise实例的状态，它有可能是rejected，也有可能是fulfilled。 Promise的缺点Promise的最大问题是代码冗余：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 GeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案,Generator就能够解决上述Promise代码冗余的问题。它能够以一种类似同步的写法来执行一些异步操作。 形式上Generator函数是一个普通函数，有两个特征：1）function关键字与函数名之间有个星号； 2）函数内部使用yield表达式，定义不同的内部状态 执行Generator函数会返回一个遍历器对象 调用Generator函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象 必须调用遍历器对象的next方法，使得指针移向下一个状态，输出返回的结果 Generator函数的写法1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 异步应用因为yield能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序。 例如有两个异步的函数 A 和 B, 并且 B 的参数是 A 的返回值，也就是说，如果 A 没有执行结束，我们不能执行 B。 那这时候我们写一段伪代码： 12345function* effect() &#123; const &#123; param &#125; = yield A(); const &#123; result &#125; = yield B(param); console.table(result);&#125; 这时候我们如果需要得到 result 那么我们就需要: 123const iterator = effect()iterator.next()iterator.next() co库可以用来每次执行A()/b()的请求结束之后，都会自动执行next()方法。 使用Generator去实现Promise的任务顺序执行：我们再回顾一下Promise版本： 1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) Generator版本： 123456789101112131415161718192021function f1() &#123; setTimeout(function() &#123; g.next(\"one\"); //将参数传给data1 &#125;, 3000);&#125;function f2(data1) &#123; console.log(\"接收到了\" + data1); setTimeout(function()&#123; g.next(\"two\"); //将参数传给data2 &#125;,3000)&#125;function* mygenerator() &#123; var data1 = yield f1(); var data2=yield f2(data1); console.log(data2);&#125;var g = mygenerator();g.next(); 看起来就很像同步操作。 这里需要注意的是：执行yield f1()的时候是不会将返回的结果返回给data1的。next方法可以接受参数，这是向 Generator 函数体内输入数据。 第二个next的时候传入参数，就能被变量data1就能够接收到。 而且不能在f1中直接调用g.next()，要在异步函数内调用（这里还不是很懂为什么…）。 执行顺序如下： 再看个栗子理解： 12345678910111213function* G() &#123; const a = yield 100 console.log('a', a) // a aaa const b = yield 200 console.log('b', b) // b bbb const c = yield 300 console.log('c', c) // c ccc&#125;const g = G()g.next() // value: 100, done: falseg.next('aaa') // a aaa value: 200, done: false g.next('bbb') // b bbb value: 300, done: falseg.next('ccc') //c ccc value: undefined, done: true 捕获错误12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw('出错了');// 出错了 使用try...catch。 async和awaitasync函数就是Generator的语法糖。 形式上的不同： async函数将Generator函数的星号（*）替换成async 将yield替换成await async函数对Generator函数的改进体现在以下3点： 内置执行器 也就是说async函数的执行，和普通函数一样，只需要一行就可以。不用像Generator函数需要调用next方法才能真正执行。 例如对于一个async函数来说： 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 调用时只需要： 1asyncReadFile(); 更好的语义 async和await比起星号和yield，语义更加清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 返回值是Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 async函数基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 先执行了第一个await后的getStockSymbol(name)函数；得到了股票的名称symbol后，将symbol传给第二个await后面的getStockPrice(symbol)作为参数；最后返回股票价格stockPrice。 async/await错误处理try/catch 使用try将await语句包含起来，如果await后的语句执行错误，则错误会被catch捕获： 123456789run();async function run() &#123; try &#123; await Promise.reject(new Error(\"Oops!\")); &#125; catch (error) &#123; error.message; // \"Oops!\" &#125;&#125; 123456789101112run();async function run() &#123; const v = null; try &#123; await Promise.resolve(\"foo\"); v.thisWillThrow; &#125; catch (error) &#123; // \"TypeError: Cannot read property 'thisWillThrow' of null\" error.message; &#125;&#125; 参考：https://blog.fundebug.com/2019/07/24/async-await-error-handling-in-js/ ​ https://segmentfault.com/a/1190000012767617 执行顺序问题1234567891011121314async function async1()&#123; console.log('async1 start'); await async2(); console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start');async1();console.log('script end')// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end 当async函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了async函数体。 1234567891011121314151617181920async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 执行顺序为： 执行async1的时候遇到await先去执行async2，然后跳出了函数体，去执行后续的代码，然后再回到当前async1函数当中执行await后续语句。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"函数柯里化","slug":"函数柯里化","date":"2020-01-14T06:27:55.000Z","updated":"2020-02-18T07:59:41.485Z","comments":true,"path":"2020/01/14/函数柯里化/","link":"","permalink":"http://delaprada.com/2020/01/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"函数柯里化柯里化的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 看一个栗子： 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 我们定义了一个add函数，它接受一个参数并返回一个新的函数。调用了add之后，返回的函数就通过闭包的方式记住了add的第一个参数。 因为一次性地调用它有点繁琐，所以使用一个特殊的curry帮助函数使得这类函数的定义和调用更加容易。 一些柯里函数实例： 12345var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;); 12345match(/\\s+/g, \"hello world\");// [ ' ' ]match(/\\s+/g)(\"hello world\");// [ ' ' ] 以上两种方法都可以执行。第二种方法是比较常见的柯里化方法。先传递一部分参数（题目中为正则表达式）来调用函数，然后返回一个函数（题目中为str.match()来处理剩下的函数）。（题目中是匹配空格） 以上的形式可以更加具体化： 12345var hasSpaces = match(/\\s+/g);// function(x) &#123; return x.match(/\\s+/g) &#125;hasSpaces(\"hello world\");// [ ' ' ] 这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 再举一个非常常见的例子： 如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入： 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下： 12check(/^1[34578]\\d&#123;9&#125;$/, '14900000088');check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, 'test@163.com'); 这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用： 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\\d&#123;9&#125;$/);var checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了： 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 再看一个前端面试中常考的题目： 1如何实现add(2)(3)(4) &#x3D; 9 函数柯里化解决这个问题： 12345678910111213141516171819let myAdd = (a, b, c) =&gt; a+b+c;function curry(fn, args)&#123; let len = fn.length; let _this = this; let _args = args || []; return function()&#123; let args = Array.prototype.slice.apply(arguments); args = Array.prototype.concat.call(_args, args); // 当接收到的参数小于fn所需参数个数时，继续接收参数 if(args.length &lt; len)&#123; return curry.call(_this, fn, args); &#125; return fn.apply(this, args); &#125;&#125;let add = curry(myAdd);console.log(add(2)(3)(4)); // 9console.loh(add(2,3)(4)); // 9console.log(add(2,3,4)); // 9 但是这个例子不具有普遍性。如果传入的参数不是3个的话不能这么用。 所以有了下面的进化之后的代码： 1234567891011121314151617181920212223function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() &#123; _args.push(...arguments); return _adder; &#125;; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder;&#125;add(1)(2)(3).toString() // 6add(1, 2, 3)(4).toString() // 10add(1)(2)(3)(4)(5).toString() // 15add(2, 6)(1).toString() // 9 参考的博客说隐式转换的原因是因为函数进行计算的时候会变为字符串，但理解了代码之后觉得并不是这么回事。每次调用函数的时候执行的是这个语句体： 1234var _adder = function() &#123; _args.push(...arguments); return _adder;&#125;; 这个语句体实际上是用于将所有传入的实参放进数组args中。最后执行toString方法的时候是将数组args的每个元素通过reduce函数求和，返回求和的值。单纯执行_adder函数和执行toString()函数做的事情是不一样的。 看到一个面试题目： 实现一个sum函数使得sum(1, 2, 3).valueOf()和sum(1)(2)(3).valueOf()执行输出的结果都等于6 。 解法和上面一致，只需要把toString()改为valueOf()就可以了。 1234567891011121314151617var sum=function()&#123; var args=[].slice.call(arguments); var _adder=function()&#123; args.push(...arguments); return _adder; &#125; _adder.valueOf=function()&#123; return args.reduce(function(a,b)&#123; return a+b; &#125;); &#125; return _adder;&#125;console.log(sum(1,2,3).valueOf());console.log(sum(1)(2)(3).valueOf()); 为什么要进行隐式转化？ 因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果： 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果： 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 参考博客： https://www.jianshu.com/p/5e1899fe7d6b https://www.cnblogs.com/hmchen/p/11564394.html https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript this解析","slug":"JavaScript-this全面解析","date":"2020-01-13T03:12:48.000Z","updated":"2020-03-07T12:09:22.112Z","comments":true,"path":"2020/01/13/JavaScript-this全面解析/","link":"","permalink":"http://delaprada.com/2020/01/13/JavaScript-this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","excerpt":"","text":"为什么要使用thisthis提供了一种更优雅的方式来隐式“传递”一个对象引用。 看下面的例子： 没有使用this的情况下： 1234567891011121314151617var me=&#123; name:\"Kyle\"&#125;var you=&#123; name:\"Reader\"&#125;function identify(context)&#123; return context.name.toUpperCase();&#125;function speak(context)&#123; var greeting=\"Hello, I'm \"+identify(context); console.log(greeting);&#125;identify(you); //READERspeak(me); //hello, I'm KYLE 使用了this的情况： 123456789101112function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greeting=\"Hello, I'm \"+identify.call(this); console.log(greeting);&#125;identify.call(me); //KYLEidentify.call(you); //READERspeak.call(me); //Hello, I'm KYLEspeak.call(you); //Hello, I'm READER 表达上更加的简洁。如果不使用this的话，就需要给identify()和speak()显式传入一个上下文对象。 this绑定对象的规则我们可以顺序应用下面四条规则来判断this的绑定对象： 如果是由new调用，绑定到新创建的对象。 如果是由call或者apply、bind调用，绑定到指定的对象上。 如果是由上下文对象调用（即this是对象中的方法里使用的），绑定到那个上下文对象上。 如果是默认情况下，严格模式绑定到undefined，否则绑定到全局对象上。 但是ES6中的箭头函数并不会使用者四条标准的绑定规则。箭头函数会继承外层函数调用的this绑定。 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar=new foo(2);console.log(bar.a); //2 我们使用new来调用foo(…)时，会构造一个新对象并把它绑定到foo(…)调用中的this上。 显式绑定call、apply、bind1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2;&#125;;foo.call(obj); //2 call用来将函数foo中的this绑定到obj上。 隐式绑定（上下文对象调用）如果this所在的函数是对象中的方法的话，this就会指向这个对象。 12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;obj.foo(); //2 foo此时是obj对象的一个方法，所以this就会指向obj。 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用： 123456789101112function foo()&#123; console.log(this.a);&#125;var obj2=&#123; a:42, foo:foo&#125;;var obj1=&#123; a:2, obj2:obj2&#125;;obj1.obj2.foo(); //42 隐式丢失也是this隐式绑定中常见的问题： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;var bar=obj.foo; //函数别名！var a=\"oops, global\"; //a是全局对象的属性bar(); //“oops, global” 此时bar是obj.foo的一个引用，但实际上它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 回调函数丢失this绑定是也是非常常见的问题： 123456789101112function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn(); //调用位置&#125;var obj=&#123; a:2, foo:foo&#125;;var a=\"oops global\"; //全局对象属性doFoo(obj.foo); //\"oops global\" 函数doFoo传入了函数作为参数，并在doFoo中调用。我们可以把它看做将函数copy到了doFoo函数体中，调用的时候this指向的是全局作用域。 隐式丢失一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。 例一： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;var bar=obj.foo; //函数别名！把函数体赋值了var a=\"oops,global\"; //a是全局对象的属性bar(); \"oops, global\" bar实际上它引用的是foo函数本身。 例二： 123456789101112131415function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;var obj=&#123; a:2, foo:foo&#125;var a=\"oops, global\"; //a是全局对象的属性doFoo(obj.foo); //\"oops, global\" 参数传递实际上是一种隐式赋值，因此我们传入函数时也会被隐式赋值。 例三： 123456789function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo: foo&#125;var a=\"oops, global\";setTimeout(obj.foo,100); //\"oops, global\" 回调函数丢失this绑定是非常常见的！ 栗子： 123456789var obj = &#123; id: \"a\", cool: function coolFn() &#123; console.log( this.id ); &#125;&#125;;var id = \"b\"obj.cool(); // asetTimeout( obj.cool, 100 ); // b 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); //2 在这个例子中，函数调用应用了this的默认绑定，this指向全局对象。 如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，this会绑定到undefined。 123456function foo()&#123; \"use strict\"; console.log(this.a);&#125;var a=2;foo(); //TypeError: this is undefined 箭头函数中的this箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。 12345678910111213function foo()&#123; return (a)=&gt;&#123; console.log(this.a); &#125;&#125;var obj1=&#123; a:2&#125;;var obj2=&#123; a:3&#125;;var bar=foo.call(obj1);bar.call(obj2); //2,不是3！ foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，所以bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。 再看一个例子： 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 foo调用时传入的是什么对象，this就指向谁。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21（严格模式则输出undefined）。 如果foo函数内部是普通函数的话： 由此可以看出，foo函数的this是指向call传入的对象{id:42}，但是foo函数内部的setTimeout函数中的this是指向全局的。 参考书籍：《你不知道的JavaScript》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript基本知识","slug":"JavaScript基本知识","date":"2019-12-30T02:14:24.000Z","updated":"2019-12-30T02:30:31.762Z","comments":true,"path":"2019/12/30/JavaScript基本知识/","link":"","permalink":"http://delaprada.com/2019/12/30/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScriptES6和JavaScript的关系ES6的全称为ECMAScript 6.0，是JavaScript语言下一代的标准，是使得JavaScript可以用来编写复杂的大型应用程序，称为企业级开发语言。ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript前言JavaScript是世界上最流行的脚本语言，是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 JavaScript引入 用直接包含js代码 把js代码放到一个单独的.js文件，在html中通过引入这个文件，这么做更有利于代码维护 JavaScript基本语法 JavaScript的语法和Java类似，每个语句以；结束 JavaScript严格区分大小写 JavaScript的数据类型基本数据类型：Number, String, Boolean, null, undefined, Symbol（ES6中新添加的类型，一种实例是唯一且不可改变的数据类型） NumberJavaScript不区分整数和浮点数，统一用Number表示。可以表示 整数 浮点数 科学计数法 负数 NaN（表示Not a Number，当无法计算结果时用NaN表示） Infinity（表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity） String字符串是以单引号或双引号括起来的文本。 模板字符串要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!';alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串获取字符串长度： 12var s = 'Hello, world!';s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' 字符串常用方法：注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： toUpperCase： toUpperCase()把一个字符串全部变为大写： 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' toLowerCase： toLowerCase()把一个字符串全部变为小写： 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' substring: substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' Booleantrue或者false 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值，要特别注意比较运算符==和===： ==比较：它会自动转换数据类型再比较，很多时候会得到很奇怪的结果 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN===NaN //false 唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN) //true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true null和undefined null表示一个“空”的值、表示“无”的对象，转为数值是为0；undefined是一个表示“无”的原始值，转为数值是NaN，当声明的变量还未被初始化时，变量的默认值为undefined。 Null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 Undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义，典型用法是： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值属性，该属性的值为undefined 函数没有返回值时，默认返回undefined null表示”没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象 作为对象原型链的终点 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： 1[1, 2, 3.14, &#39;Hello&#39;, null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过Array()函数实现： 1new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即truearr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined 要取得Array的长度，直接访问length属性： 12var arr = [1, 2, 3.14, 'Hello', null, true];arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： 123var arr = ['A', 'B', 'C'];arr[1] = 99;arr; // arr现在变为['A', 99, 'C'] (注意此处与String的不同，String是不可变的) 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串&#39;30&#39;是不同的元素。 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 对象JavaScript的对象是一组由键-值组成的无序集合，用一个{...}表示一个对象，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为&#39;Bob&#39;，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用&#39;&#39;括起来： 1234var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School'&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用&#39;&#39;括起来。访问这个属性也无法使用.操作符，必须用[&#39;xxx&#39;]来访问： 123xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红' 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： 1234567891011var xiaoming = &#123; name: '小明'&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符： 12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： 1'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefinedvar $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值truevar t &#x3D; null; &#x2F;&#x2F; t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如： 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言（例如int） 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 循环for…infor循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 12345678910var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // 'name', 'age', 'city' &#125;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for ... in对Array的循环得到的是String而不是Number。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for...in和for...of的区别： for in 循环的是对象的属性（普通数组的属性就是index） for of 循环的是迭代器中的每一个元素 用for ... of循环遍历集合，用法如下： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 你可能会有疑问，for ... of循环和for ... in循环有何区别？ 当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125; for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 12345678'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身： 1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： 1234var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; console.log(element);&#125;); 参考基本数据类型和引用数据类型的区别：https://www.cnblogs.com/c2016c/articles/9328725.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"hexo常用指令及美化博客页面","slug":"hexo常用指令及美化博客页面","date":"2019-12-26T09:54:44.000Z","updated":"2020-01-15T12:46:56.095Z","comments":true,"path":"2019/12/26/hexo常用指令及美化博客页面/","link":"","permalink":"http://delaprada.com/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"hexo常用命令Hexo的命令总体来说比较简单，安装成功之后只需要记住常用的四种即可。在当前blog文件夹根目录下右键点击git bash： hexo s：server启动服务器 hexo clean：clean清除缓存文件（db.json）和已生成的静态文件（public） hexo generate或hexo g：generate生成静态文件 hexo deploy或hexo d：deploy部署网站，部署网站前需预先生成静态文件 一般更改完后执行三条指令：hexo clean，hexo generate，hexo deploy即可（按顺序） 如果要进行文件压缩，在hexo generate指令后，执行gulp指令。 参考https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/ hexo各种美化新建page1hexo new &quot;文章名称&quot; 会在source文件夹下_post中新建文件夹和.md文件 侧栏增加标签和分类页面创建标签页面 创建标签页面 1hexo new page tags 基本设置 123title: tagsdate: 2017-12-02 21:01:24type: &quot;tags&quot; 创建分类页面 创建分类页面 1hexo new page categories 基本设置 123title: categoriesdate: 2017-12-02 21:01:24type: &quot;categories&quot; 文章中插入图片 将图片放置在页面对应的文件夹中 在文章中引入： 1&#123;% asset_img 图片名称 %&#125; 设置站点图标 先在images文件夹下放入你的图标 在主题配置页面_config.yml中搜索favicon，找到以下位置，并将路径修改为你的图标： 部署之后就可以看到效果了，查看效果：http://delaprada.com 设置头像 在images文件夹中放入你的头像图片 在主题配置页面中修改avatar为你的图片地址： 首页文章不显示全文只显示摘要修改/themes/next/_config.yml主题配置文件中： 1234567scroll_to_more: true #如果文章有摘要,会自动滚动到摘要下面save_scroll: true #通过cookies来缓存阅读进度excerpt_description: true #自动摘录描述作为序言auto_excerpt: #设置阅读全文 enable: true length: 150 #摘要次数read_more_btn: true #阅读全文按钮 修改文章底部的带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;（如果想换成其他图标可到font-awesome中文网查看） 在每篇文章末尾统一添加“本文结束”标记在\\themes\\next\\layout\\_macro中新建passage-end-tag.swig，并加入以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=\"text-align:center;color: #ccc;font-size:15px;\"&gt;-------本&amp;nbsp;文&amp;nbsp; 结&amp;nbsp;束&amp;nbsp;&amp;nbsp;&lt;i class=\"fa fa-heart\" aria-hidden=\"true\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;感 &amp;nbsp;谢&amp;nbsp;您&amp;nbsp;的&amp;nbsp;阅&amp;nbsp;读-------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body标签之后，post-footer标签之前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &#39;passage-end-tag.swig&#39; %&#125; &#123;% endif %&#125;&lt;&#x2F;div&gt; 修改网页背景颜色和侧栏上方brand的颜色打开themes/next/layout/source/css/_custom/custom.styl，加入以下代码： 12345678910111213141516171819202122&#x2F;&#x2F;修改网页背景颜色body &#123; background-color: #F0F8FF&#125;#footer a &#123; color:#eee;&#125;&#x2F;&#x2F; 修改网站头部颜色.headband &#123; height: 3px; background: #ADD8E6;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #ADD8E6;&#125;.site-title &#123; color: #fff;&#125; 侧边栏社交设置和友情链接修改主题配置页面：themes/next/_config.yml： 12345678910111213141516171819202122232425262728293031site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: CSDN: https://blog.csdn.net/weixin_41973410 || copyright GitHub: https://github.com/delaprada || githubsocial_icons: #这里是上面社交链接的对应图标 enable: true CSDN: copyright Github: github icons_only: false transition: true# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.#github_banner: https://github.com/Fitz1318 || Follow me on GitHub# Blog rolls #这里时设置一些相关链接 我这里设置了一些推荐阅读的网站#links_icon: linklinks_title: 实用网站#links_layout: blocklinks_layout: inlinelinks: W3Cschool: http://www.w3school.com.cn/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"hexo categories和tags页面不显示解决办法","slug":"hexo-categories和tags页面不显示解决办法","date":"2019-12-25T02:53:13.000Z","updated":"2019-12-26T09:55:44.357Z","comments":true,"path":"2019/12/25/hexo-categories和tags页面不显示解决办法/","link":"","permalink":"http://delaprada.com/2019/12/25/hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"官网也有给出具体步骤，但是有坑Hexo官网教程 第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ：12cd hexo //根目录hexo new page categories //tags和这个操作一致 第二步 找到新建的页面，添加type新建的页面一般在source/categories/index.md中，添加以下内容： 1234title: categoriesdate: 2019-12-25 09:15:45type: \"categories\"layout: \"categories\" 第三步 给你的页面添加分类找到你的页面，在页面上方添加如下内容 123456title: 利用gitpages+hexo搭建自己的博客date: 2019-12-25 09:12:55categories:- Hexotags:- 前端 但此时部署到github上后，打开网页点击分类和标签页面还是出现404！ 第四步 解决方案实属官方坑人系列！！主题配置文件_config.yml中的menu：把 / 后面的空格全部去掉（刚开始的时候默认后面是加了空格导致点击页面出现404）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"利用gitpages+hexo搭建自己的博客","slug":"利用gitpages+hexo搭建自己的博客","date":"2019-12-25T01:12:55.000Z","updated":"2020-01-15T12:50:57.057Z","comments":true,"path":"2019/12/25/利用gitpages+hexo搭建自己的博客/","link":"","permalink":"http://delaprada.com/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言从开始开始着手搭建到完成大概花了一个下午的时间，采坑不少，在此记录一下 第一步 准备工作node.js下载好，github有已注册的账号在github中新建一个repository，命名为：你的github名称.github.io（下面是我的仓库名称）： （有些博客直接让我们fork它们的项目，个人感觉这么做不太好，很多东西自己动手做一遍更好） 第二步 安装HexoHexo就是一个博客框架，官网上也有安装教程Hexo官网 step1：windows系统鼠标右键git bash，输入两个安装指令： 12npm install hexo-cli -g &#x2F;&#x2F;用于安装hexonpm install hexo-deployer-git --save &#x2F;&#x2F;用于安装hexo部署到git page的deployer step2：创建hexo文件夹hexo安装完成之后，在电脑中新建一个hexo文件夹： 右键点击git bash，输入两个命令： 12hexo initnpm install &#x2F;&#x2F;安装所有package.json里的包 执行完成后，hexo文件夹中会多出一些文件： 如果想看本地效果的话，执行以下指令： 12hexo generate &#x2F;&#x2F;自动将md文件生成静态html，css文件hexo server &#x2F;&#x2F;启动本地hexo服务器（localhost:4000） 打开 localhost:4000就可以看到页面啦： （页面会不太一样，我的配了一下主题） 第三步 了解hexo文件夹中的_config.ymlhexo文件夹中比较重要的文件是：_config.yml： 它是一个全局配置文件，包括和github上传链接都在这里配置，例如title之类的： 第四步 本地上传到githubstep1：执行命令，安装deploy.git插件 1npm install hexo-deployer-git --save step2：在主题配置文件_config.yml中修改仓库地址，在_config.yml最下面一行（注意每个冒号后面都有一个空格） step3：配置提交github认证方式执行指令： 1hexo d 直接提交到github仓库中，如果没有认证github和本地的关系，会提示输入用户名和密码 此时打开github的项目会发现原本是空的项目现在有了刚刚上传的文件 第五步 添加域名在阿里云中购买了一个.com的域名（加优惠一年23块，虽然比其他贵一些但是觉得.com好听一些(#^ . ^#)） step1：cmd ping一下github.io获得真实ip地址 step2：然后再域名操作栏点击解析，添加记录 注意要两个都要添加（之前一开始只添加了www不知道为啥就显示不出来） step3：去hexo文件夹的source目录下新建名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www step4：然后部署 1231. hexo clean2. hexo generate3. hexo deploy （每次做出更改建议都部署一遍） step5：点击设置，拉到下面，在custom domain中输入你的域名。如果上面的信息不是显示Your site is published at https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证 输入域名，成功：","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]}],"categories":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"数据库","slug":"数据库","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"},{"name":"Node.js","slug":"React/Node-js","permalink":"http://delaprada.com/categories/React/Node-js/"},{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"},{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://delaprada.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"数据库","slug":"数据库","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"},{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"},{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"},{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]}