{"meta":{"title":"Alice's  wonderland","subtitle":"","description":"Goals determine what you going to be!","author":"Alice","url":"http://delaprada.com","root":"/"},"pages":[{"title":"categories","date":"2019-12-25T01:15:45.000Z","updated":"2019-12-26T12:39:38.305Z","comments":false,"path":"categories/index.html","permalink":"http://delaprada.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-25T01:50:31.000Z","updated":"2019-12-26T12:39:54.263Z","comments":false,"path":"tags/index.html","permalink":"http://delaprada.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node.js——Express和koa框架对比","slug":"Node-js——Express和koa框架对比","date":"2020-04-07T03:10:47.000Z","updated":"2020-04-07T06:08:19.023Z","comments":true,"path":"2020/04/07/Node-js——Express和koa框架对比/","link":"","permalink":"http://delaprada.com/2020/04/07/Node-js%E2%80%94%E2%80%94Express%E5%92%8Ckoa%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/","excerpt":"","text":"此文参考：阿里技术协会《Node.js框架之express与koa对比分析》 https://yq.aliyun.com/articles/3062","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——事件循环","slug":"Node——事件循环","date":"2020-04-07T00:51:23.000Z","updated":"2020-04-07T02:23:07.020Z","comments":true,"path":"2020/04/07/Node——事件循环/","link":"","permalink":"http://delaprada.com/2020/04/07/Node%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"异步IO异步IO是指操作系统提供的IO（数据进出）能力，比如键盘输入，对应到显示器上会有专门的数据输出接口，这就是我们生活中可见的IO能力；这个接口在向下会进入到操作系统这个层面，在操作系统中，会提供诸多的能力，比如：磁盘的读写，DNS的查询，数据库的连接啊，网络请求的处理，等等。 在不同的操作系统层面，表现的不一致。有的是异步非阻塞的；有的是同步的阻塞的，无论如何，我们都可以看做是上层应用于下层系统之间的数据交互；上层依赖于下层，但是反过来，上层也可以对下层提供的这些能力进行改造。如果这种操作是异步的，非阻塞的，那么这种就是异步非阻塞的异步IO模型；如果是同步的阻塞的，那么就是同步IO模型。 koa就是一个上层的web服务框架，全部由JavaScript实现，他有操作系统之间的交互，全部通过nodejs来实现；如nodejs的 readFile就是一个异步非阻塞的接口，readFileSync就是一个同步阻塞接口。 事件循环事件循环是指Node.js执行非阻塞I/O操作，尽管JavaScript是单线程的,但由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行。 Node.js是单线程执行的，同时它又是基于事件驱动和非阻塞IO编程模型。这就使得我们不用等待异步操作结果返回，就可以继续往下执行代码。当异步事件触发之后，就会通知主线程，主线程执行相应事件的回调。 Node.js架构分析说道 Nodejs 架构, 首先要知道Nodejs 与 V8 和 libUV 的关系和作用: V8: 执行 JS 的引擎. 也就是翻译 JS. 包括我们熟悉的编译优化, 垃圾回收等等. libUV: 提供 async I/O, 提供消息循环. 可见, 是操作系统 API 层的一个抽象层. JavaScript引擎是一种专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器中。 V8：是Google开发的JavaScript引擎，用于Google Chrome和Chromium。V8能够即时编译JavaScript，使得JavaScript代码能够高效运行。 以往我们在执行c++的时候，会先进行编译工作，变为可执行文件后，再执行这个可执行文件。这个编译工作是由编译器完成的。 解释器就提供了一种边编译边运行的动态运行方法，而也正因为通过解释器运行的代码是边编译边运行的，所以运行的速度比静态编译的那种慢很多。 所以程序运行的方式分为静态编译和动态编译。 回到Node.js架构，Node.js如何组织它们呢？ Node.js通过一层C++ Binding，把JavaScript传给V8，V8解析后交给libUV发起异步IO，并等待消息循环调度。所以，Node.js实现异步机制的核心便是libUV。 Node.js启动过程可以分为以下步骤： 1、调用platformInit方法 ，初始化 nodejs 的运行环境。 2、调用 performance_node_start 方法，对 nodejs 进行性能统计。 3、openssl设置的判断。 4、调用v8_platform.Initialize，初始化 libuv 线程池。 5、调用 V8::Initialize，初始化 V8 环境。 6、创建一个nodejs运行实例。 7、启动上一步创建好的实例。 8、开始执行js文件，同步代码执行完毕后，进入事件循环。 9、在没有任何可监听的事件时，销毁 nodejs 实例，程序执行完毕。 以上是Node.js执行一个JavaScript文件的全过程，事件循环是在第八个步骤中。 Nodejs 完全是单线程的. 从进程启动后, 由主线程加载我们的 js 文件(下图中 main.js), 然后进入消息循环. 可见对于 js 程序而言, 完整运行在单线程之中。 事件循环Node.js中事件循环分为6个阶段： timers：执行setTimeout() 和 setInterval()中到期的回调。 I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 idle, prepare：仅内部使用 poll：最为重要的阶段，执行I/O 回调，在适当的条件下会阻塞在这个阶段 check：执行setImmediate的回调 close callbacks：执行close事件的回调，例如socket.on(&quot;close&quot;,func) 重点关注timers、poll、check三个阶段 步骤： node的初始化 初始化node环境 执行同步任务（例如console.log） 执行process.nextTick回调 执行microtasks（Promise.then） 进入event-loop 进入timers阶段 检查timer队列是否有到期的timer回调，如果有，将到期的timer回调按照timerID升序执行 检查是否有process.nextTick任务，如果有，全部执行 检查是否有microtask，如果有，全部执行 退出该阶段 进入IO callback阶段 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段。 检查是否有 process.nextTick 任务，如果有，全部执行。 检查是否有microtask，如果有，全部执行。 退出该阶段。 进入idle、prepare阶段： 这两个阶段与我们编程关系不大，暂且按下不表。 进入poll阶段 首先检查是否存在尚未完成的回调，如果存在，分两种情况： 如果有可用回调（可用回调包含：到期的定时器、一些IO事件等），执行所有可用回调。 检查是否有process.nextTick回调，如果有，全部执行 检查是否有 microtaks，如果有，全部执行。 退出该阶段。 如果没有可用回调 检查是否有setImmediate回调，如果有，退出poll阶段。如果没有，阻塞在此阶段，等待新的事件通知。 如果不存在尚未完成的回调，退出poll。 进入check阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 check 阶段 进入closing阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 closing 阶段 在事件循环的每个子阶段退出之前都会按顺序执行如下过程： 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出当前阶段。 常见问题process.nextTick和Promise这个队列先保证所有的 process.nextTick 回调, 然后将所有的 Promise 回调追加在后面. 最终在每个 Phase 结束的时候一次性拿出来执行。 setTimeout(..., 0)vs. setImmediate 到底谁快?1234// index.jssetImmediate(() =&gt; console.log(2))setTimeout(() =&gt; console.log(1),0) 答案：可能是1 2，也可能是2 1。 首先我们在初始化阶段会将setImmediate添加到check phase中，将setTimeout添加到timer phase中。 如果进入timer phase的时间 &gt; 消息循环保存的时间（即将以上两个回调添加到它们各自的phase的时间） 那在进入timer phase的时候setTimeout的回调已经在里面了，就可以立即执行，然后到check phase的时候再执行setImmediate的回调。此时输出1 2。 如果进入timer phase的时间 &lt; 消息循环保存的时间（即将以上两个回调添加到它们各自的phase的时间） 那在进入timer phase的时候setTimeout的回调还不在里面，那就会先执行check phase中的setImmediate，然后在下一轮循环中再执行timer phase中的setTimeout。此时输出2 1。 如果把代码改为如下，则一定会得到稳定输出： 12345require('fs').readFile('my-file-path.txt', () =&gt; &#123; setImmediate(() =&gt; console.log(2)) setTimeout(() =&gt; console.log(1))&#125;);// 2 1 因为消息在poll phase才会将setImmediate进入check phase，将setTimeout进入timer phase，那poll阶段后就回到check阶段，所以会输出2 1。 判断输出顺序12345678910111213141516171819setImmediate(() =&gt; &#123; console.log('setImmediate1'); setTimeout(() =&gt; &#123; console.log('setTimeout1') &#125;, 0);&#125;);Promise.resolve().then(res=&gt;&#123; console.log('then');&#125;)setTimeout(() =&gt; &#123; process.nextTick(() =&gt; &#123; console.log('nextTick'); &#125;); console.log('setTimeout2'); setImmediate(() =&gt; &#123; console.log('setImmediate2'); &#125;);&#125;, 0);//then setTimeout2 nextTick setImmediate1 setImmediate2 setTimeout1 step1：初始化阶段 setImmediate进入check phase、Promise.resolve().then进入微任务event queue、setTimeout进入timer phase。 没有process.nextTick 执行microtask，输出then 结束该阶段 step2：进入Timer phase（或者poll phase？） 执行setTimeout 执行console.log(&#39;setTimeout2&#39;)，输出setTimeout2 setImmediate进入check phase 有process.nextTick，输出nextTick step3：进入check phase 执行第一个setImmediate，输出setImmediate1，将setTimeout进入Timer phase 执行第二个setImmediate，输出setImmediate2 step4：下一个循环，进入Timer phase 执行setTimeout，输出setTimeout1 参考： https://juejin.im/post/5b61d8e3e51d45191d7a28a8 https://www.jianshu.com/p/906eafb41ea6","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Vue项目中如何用Node作后端代理获取接口数据","slug":"Vue项目中如何用Node作后端代理获取接口数据","date":"2020-04-06T02:12:17.000Z","updated":"2020-04-06T02:37:40.638Z","comments":true,"path":"2020/04/06/Vue项目中如何用Node作后端代理获取接口数据/","link":"","permalink":"http://delaprada.com/2020/04/06/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8Node%E4%BD%9C%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%90%86%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/","excerpt":"","text":"在做音乐APP项目的时候，发觉QQ音乐的有些接口是没有办法直接获取其中的数据的，因为它指定了请求的host和referer，所以我们需要用Node在其中做一层代理，去“欺骗”QQ，这样就能够获取数据。有点像跨域的思想，只不过跨域是用代理作为跳板，转发请求，不存在跨域问题；这里是用Node Server发起请求，将请求的referer和host改为接口允许访问的referer和host，来“欺骗”QQ。 怎么配置Node代理我们使用Vue.cli搭项目的脚手架的时候，build/webpack.dev.conf.js文件中有个devServer这里就可以用来配置。以前是有单独的文件dev-server.js，最新版本的Vue.cli放弃了这个。 首先要在devServer中添加before(app){}，将我们的操作放在before(app){}中。webpack 3 内置了 express，app 就是 express() 返回的对象。 123456789101112131415161718devServer: &#123; before(app)&#123; app.get('/api/getDiscList',function(req,res)&#123; const url='https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'; axios.get(url,&#123; headers:&#123; referer:'https://c.y.qq.com', host:'c.y.qq.com' &#125;, params:req.query &#125;).then((response)=&gt;&#123; res.json(response.data) &#125;).catch((e)=&gt;&#123; console.log(e); &#125;) &#125;)...&#125; 当Node服务器接收到来自/api/getDiscList的get请求时，就会执行后面的回调函数，用axios向QQ的URL发起请求，关键是要指定请求的头部headers，设定referer和host，这个referer和host是URL &lt;’https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&#39;&gt; 允许访问的referer和host。 向Node代理服务器发起请求我们使用模块化开发的时候，就可以在方法当中使用axios向Node代理服务器发起请求，返回一个Promise对象。 1234567891011121314151617181920export function getDiscList()&#123; const url='/api/getDiscList'; const data=Object.assign(&#123;&#125;,commonParams,&#123; platform:'yqq', hostUin:0, sin:0, ein:29, sortId:5, needNewCode:0, categoryId:10000000, rnd:Math.random(), format:'json' &#125;) return axios.get(url,&#123; params:data &#125;).then((res)=&gt;&#123; return Promise.resolve(res.data); &#125;)&#125; 组件当中的设置首先是要导入方法： 1import &#123;getDiscList&#125; from 'api/recommend' 我们在created生命周期阶段执行方法： 1234created()&#123; this._getRecommend(); this._getDiscList();&#125; 获取到数据： 123456789methods:&#123; _getDiscList()&#123; getDiscList().then((res)=&gt;&#123; if(res.code===ERR_OK)&#123; console.log(res.data.list); &#125; &#125;) &#125;&#125; 执行npm run dev，可在控制台看到数据：","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——Connect和Express","slug":"Node——Connect和Express","date":"2020-04-05T06:03:20.000Z","updated":"2020-04-05T07:56:24.980Z","comments":true,"path":"2020/04/05/Node——Connect和Express/","link":"","permalink":"http://delaprada.com/2020/04/05/Node%E2%80%94%E2%80%94Connect%E5%92%8CExpress/","excerpt":"","text":"前言Connect和Express是两个热门的Node模块。Express就是在Connect的基础上，通过添加高层糖衣扩展和搭建出来的。 Connect创建简单的Connect程序指令： 1npm install connect@3.4.0 在要安装的模块后加@可以指定版本号 简单的Connect程序应该是这样的： 12345const app&#x3D;require(&#39;connect&#39;)();app.use((req,res,next)&#x3D;&gt;&#123; res.end(&#39;Hello, world!&#39;);&#125;);app.listen(3000); 这个程序会用Hello, World!做出响应。也就是访问http://localhost:3000的时候，页面显示Hello, world!。传给app.use的函数是个中间件，它以文本Hello, world!作为响应结束了请求处理过程。中间件是所有Connect和Express程序的基础。 Connect中间件的工作机制Connect中间件就是JavaScript函数。这个函数一般会有三个参数：请求对象、响应对象、以及一个名为next的回调函数。一个中间件完成自己的工作，要执行后续的中间件时，可以调用这个next回调函数。 在中间件运行之前，Connect会用分派器接管请求对象，然后交给程序中的第一个中间件。 借助中间件API，可以把一些小的构件块组合到一起，实现复杂的处理逻辑。 组合中间件Connect中的use方法就是用来组合中间件的。我们先来定义两个中间件函数，然后把它们都添加到程序中。 12345678910111213const connect=require('connect');function logger(req,res,next)&#123; console.log('%s %s', req.method, req.url); next();&#125;function hello(req,res)&#123; res.setHeader('Content-Type', 'text/plain'); res.end('hello world');&#125;connect() .use(logger) .use(hello) .listen(3000); 这两个中间件的名称签名不一样：一个有next，一个没有。因为后面这个中间件完成了HTTP响应，再也不需要把控制权交还给分派器了。 use()函数返回的是Connect程序的实例，支持方法链。也可以不写成链式调用的形式： 1234const app=connect();app.use(logger);app.use(hello);app.listen(3000); 需要注意的是，如果某个中间件不调用next()，那链在它后面的中间件就不会被调用。所以如果logger和hello两个函数的调用顺序反过来，则logger是不会执行的。 使用错误处理中间件Connect中有一种用来处理错误的中间件变体。跟常规的中间件相比，除了请求和响应对象外，错误处理中间件的参数中还多了一个错误对象。 1234567891011121314151617//Connect中的错误处理中间件const env=process.env.NODE_ENV||'development';function errorHandler(err,req,res,next)&#123; res.statusCode=500; switch(env)&#123; //开发模式和生产模式的响应不同 case 'development': console.error('Error:'); console.error(err); res.setHeader('Content-Type','application/json'); res.end(JSON.stringify(err)); break; default: res.end('Server error'); &#125;&#125;module.exports=errorHandler; 开发环境（development）：开发同学开发时使用的环境，每位开发同学在自己的dev分支上工作，开发到一定程度后，各位同学会合并代码，进行联调。 生产环境（production）：线上环境，用户使用的环境。由特定人员来维护。 设置环境变量 UNIX系统中设置环境变量的指令：$ NODE_ENV=production node app Windows中用这个： $ set NODE_ENV=production $ node app 产品在开发环境中运行时，你可能想要看到尽可能详细的日志；但在生产环境中，你可能想让日志尽量精简，可能还要用gzip进行压缩。 用NODE_ENV设定程序的模式，Connect一般会根据环境变量NODE_ENV(process.env.NODE_ENV)来切换不同服务器环境（比如生产环境和开发环境）下的行为。 当Connect遇到错误时，它会切换，只去调用错误处理中间件。 假设有一个允许用户登录到管理区域的博客程序。如果负责用户路由的中间件引发了一个错误，则中间件blog和admin都会被跳过，因为它们不是错误处理中间件（只有三个参数）。然后Connect看到接受错误参数的errorHandler，就会调用它。中间件看起来像下面这样： 12345connect() .use(router(require('./routes/user'))) .use(router(require('./routes/blog'))) //跳过 .use(router(require('./routes/admin'))) //跳过 .use(errorHandler); ExpressExpress是非常流行的Web框架，以前是在Connect的基础上搭建的。尽管提供了一些基本的功能，比如静态文件服务、URL路由和程序配置等，但它依然是极简的Web框架。 简单的Express程序 12345678const express=require('express');const app=express();app.get('/',(req,res)=&gt;&#123; res.send('Hello');&#125;);app.listen(3000); 生成程序框架安装指令： 1npm install -g express-generator 生成程序 用-e或（--ejs）指定要使用的模板引擎是EJS（EJS是一个嵌入JavaScript模板引擎，通过编译生成HTML代码）。执行express -e shoutbox，shoutbox是文件名。一个功能完备的程序会出现在shoutbox目录中。其中会有描述项目和依赖项的package.json文件、程序主文件、public目录，以及一个放路由处理器的目录。 Express路由入门根据官网定义： Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on). 路由的定义： 1app.METHOD(PATH, HANDLER) app是express的一个实例 METHOD是HTTP请求方法（小写） PATH是服务器上的路径 HANDLER是在这个路径上发起HTTP请求时执行的回调函数 Respond with Hello World! on the homepage: 123app.get('/', function (req, res) &#123; res.send('Hello World!')&#125;) Respond to POST request on the root route (/), the application’s home page: 123app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125;) Respond to a PUT request to the /user route: 123app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user')&#125;) Respond to a DELETE request to the /user route: 123app.delete('/user', function (req, res) &#123; res.send('Got a DELETE request at /user')&#125;) 做个简单的留言板程序效果： 步骤： 创建消息模型 添加与消息相关的路由 创建消息表单 添加业务逻辑，用提交上来的表单数据创建消息 创建消息模型在创建消息模型之前，需要先安装Node redis模块。执行命令npm install --save redis。而且要安装Redis，Windows系统可以使用Redis Chocolately。 安装教程：https://www.cnblogs.com/julyluo/p/6646155.html 官网没有windows版本，github下载速度太慢。 Redis就是一个数据库，可以将我们post的留言存储起来。 创建保存在线留言板消息条目的模型。 创建models/entry.js文件： 12345678910111213141516171819202122232425262728293031323334353637383940'use strict';const redis = require('redis');const db = redis.createClient();class Entry &#123; constructor(obj) &#123; for (let key in obj) &#123; this[key] = obj[key]; &#125; &#125; static getRange(from, to, cb) &#123; db.lrange('entries', from, to, (err, items) =&gt; &#123; if (err) return cb(err); let entries = []; items.forEach((item) =&gt; &#123; entries.push(JSON.parse(item)); &#125;); cb(null, entries); &#125;); &#125; save(cb) &#123; const entryJSON = JSON.stringify(this); db.lpush( 'entries', entryJSON, (err) =&gt; &#123; if (err) return cb(err); cb(); &#125; ); &#125; static count(cb) &#123; db.llen('entries', cb); &#125;&#125;module.exports = Entry; 创建消息表单 在app.js中添加如下路由部分 12app.get('/post', entries.form);app.post('/post', entries.submit); 即：使用get向/post发起http请求时，执行entries.form回调函数。使用post向/post发起http请求时，执行entries.submit回调。 这个`entries`是从`routes`中导入的模块。看一下定义： 表单模块部分： 1234//routes/entries.jsexports.form = (req, res) =&gt; &#123; res.render('post', &#123; title: 'Post' &#125;);&#125;; 这里是用views/post.ejs，即表单，去渲染页面。 123456789101112131415161718192021222324&#x2F;&#x2F;views&#x2F;post.ejs&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt; &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;h1&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h1&gt; &lt;p&gt;Fill in the form below to add a new post.&lt;&#x2F;p&gt; &lt;form action&#x3D;&#39;&#x2F;post&#39; method&#x3D;&#39;post&#39;&gt; &lt;p&gt; &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;entry[title]&#39; placeholder&#x3D;&#39;Title&#39; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;p&gt; &lt;textarea name&#x3D;&#39;entry[body]&#39; placeholder&#x3D;&#39;Body&#39;&gt;&lt;&#x2F;textarea&gt; &lt;&#x2F;p&gt; &lt;p&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&#39;Post&#39; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 表单中用了形如entry[title]之类的输入控件名称，需要用扩展的消息体解析器来解析。找到app.js将 1app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); 改为： 1app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); 实现消息提交功能 123456789101112131415//将代码添加到文件routes/entries.js中，实现用表单提交上来的数据创建消息exports.submit = (req, res, next) =&gt; &#123; const data = req.body.entry; const user = res.locals.user; const username = user ? user.name : null; const entry = new Entry(&#123; username: username, title: data.title, body: data.body &#125;); entry.save((err) =&gt; &#123; if (err) return next(err); res.redirect('/'); &#125;);&#125;; 这里使用了Common JS进行模块化开发 添加显示消息的首页 在routes/entries.js中添加： 123456789101112const Entry = require('../models/entry');exports.list = (req, res, next) =&gt; &#123; const page = req.page; Entry.getRange(0, -1, (err, entries) =&gt; &#123; if (err) return next(err); res.render('entries', &#123; title: 'Entries', entries: entries &#125;); &#125;);&#125;; 视图entries.ejs 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt; &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;% entries.forEach((entry) &#x3D;&gt; &#123; %&gt; &lt;div class&#x3D;&#39;entry&#39;&gt; &lt;h3&gt;&lt;%&#x3D; entry.title %&gt;&lt;&#x2F;h3&gt; &lt;p&gt;&lt;%&#x3D; entry.body %&gt;&lt;&#x2F;p&gt; &lt;p&gt;Posted by &lt;%&#x3D; entry.username %&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;% &#125;) %&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 在程序运行之前先在同一目录下创建menu.ejs创建菜单模板文件，后续会用到。目前空白着先。 添加与消息相关的路由 在app.js中： 1const entries = require('./routes/entries'); 添加路由： 1app.get('/', entries.list); 运行程序 先以管理员身份进入CMD，运行redis-server启用Redis。 在terminal中运行npm start，访问http://localhost:3000/post 点击post后跳转到首页： 完成。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——Gulp基于流的自动化构建工具","slug":"Node——Gulp基于流的自动化构建工具","date":"2020-04-03T02:59:55.000Z","updated":"2020-04-03T04:01:47.163Z","comments":true,"path":"2020/04/03/Node——Gulp基于流的自动化构建工具/","link":"","permalink":"http://delaprada.com/2020/04/03/Node%E2%80%94%E2%80%94Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"用Gulp实现自动化Gulp是基于流的构建系统。我们可以通过对这些流的引导来创建构建过程，除了转译和缩码，还能做很多事情。 Gulp之所以能实现高度重用，主要归功于两项技术：使用插件和自定义构建任务。Gulp的构建过程是一个流，所以这些任务和插件是可以一个接一个拼在一起的。 把Gulp添加到项目中添加Gulp需要用npm安装gulp-cli和gulp两个包。下面这段代码中，全局安装gulp-cli，并创建一个带有Gulp开发依赖项的新Node项目。 123npm i --global gulp-clinpm init -ynpm i -save-dev gulp 接着创建gulpfile.js 1touch gulpfile.js touch为linux指令 现在用Gulp构建一个小型的React项目。这里会用到gulp-babel、gulp-sourcemaps和gulp-concat： 12npm i --save-dev gulp-sourcemaps gulp-babel babel-preset-es2015npm i --save-dev gulp-concat react react-dom babel-preset-react 这里要注意的是，安装gulp-babel的时候要安装7版本的，后续还要安装babel-core。如果直接安装，是安装8版本，babel-core是7，就会出错。 Gulp任务的创建及运行创建Gulp任务需要在gulpfile.js中编写Node代码，调用Gulp的API。Gulp的API可以做很多事情，比如查找文件，把对文件进行某种转换的插件拼到一起等。 打开gulpfile.js设置一个构建任务，用gulp.src查找JSX文件，用Babel处理ES6和React，然后把这些文件拼到一起。 gulpfile.js 123456789101112131415const gulp=require('gulp');const sourcemaps=require('gulp-sourcemaps');const babel=require('gulp-babel');const concat=require('gulp-concat');gulp.task('default',()=&gt;&#123; return gulp.src('app/*.jsx') .pipe(sourcemaps.init()) .pipe(babel(&#123; presets:['es2015','react'] &#125;)) .pipe(concat('all.js')) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('dist'));&#125;) gulp.src：Gulp自带的文件聚集工具，查找所有的React jsx文件 sourcemaps.init()：开始监视源文件，为调试构建源码映射 concat(&#39;all.js&#39;)：把所有源码文件拼到一个all.js中 soucemaps.write(&#39;.&#39;)：单独写入源码映射文件 gulp.dest(&#39;dist&#39;)：将所有文件放到dist/目录下 创建一个名为app/index.jsx的文件，就可以试验一下Gulp了。可以用下面这段JSX代码： 1234567import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello,world!&lt;/h1&gt;, document.getElementById('example')) 在终端运行gulp： 123[10:21:44] Using gulpfile ~\\Desktop\\大三\\实习\\笔记\\Node.js\\gulp_test\\gulpfile.js[10:21:44] Starting &#39;default&#39;...[10:21:44] Finished &#39;default&#39; after 213 ms 目录： 打包生成的all.js： 123456789101112131415161718'use strict';var _react = require('react');var _react2 = _interopRequireDefault(_react);var _reactDom = require('react-dom');var _reactDom2 = _interopRequireDefault(_reactDom);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;_reactDom2.default.render(_react2.default.createElement( 'h1', null, 'Hello,world'), document.getElementById('example'));//# sourceMappingURL=all.js.map 总结在Gulp中，用JavaScript表示构建阶段很容易。并且我们可以用gulp.task()往这个文件里添加自己的任务。这些任务通常都遵循相同的模式。 源文件：收集输入文件 转译：让它们依次通过一个个对它们进行转换的插件 合并：把这些文件合到一起，创建一个整体构建文件 输出：设定文件的目标地址或移动输出文件 在前面那个例子中，sourcemaps是个特例，因为它需要两次pipe：第一次是配置，最后一次是输出文件。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——串行化/并行化流程控制","slug":"Node——串行化-并行化流程控制","date":"2020-04-01T03:15:11.000Z","updated":"2020-04-01T04:05:56.067Z","comments":true,"path":"2020/04/01/Node——串行化-并行化流程控制/","link":"","permalink":"http://delaprada.com/2020/04/01/Node%E2%80%94%E2%80%94%E4%B8%B2%E8%A1%8C%E5%8C%96-%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"异步逻辑的顺序化在异步程序的执行过程中，有些任务可能会随时发生，跟程序中的其他部分在做什么没关系，什么时候做这些任务都不会出问题。但有些任务只能在某些特定的任务之前或之后做。 让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类：串行和并行。 串行任务：需要一个接着一个执行的任务 并行任务：不需要一个接着一个执行的任务。这些任务彼此之间开始和结束时间并不重要，但在后续逻辑执行前它们应该全部执行完成。 实现串行化流程控制为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组起到队列的作用：完成一个任务后按顺序从数组中取出下一个。 实例做一个小程序，让它从一个随机选择的RSS预订源中获取一篇文章的标题和URL，并显示出来。RSS预订源列表放在一个文本文件中。 例如： 123&#x2F;&#x2F;rss_feeds.txthttp:&#x2F;&#x2F;www.read.org.cn&#x2F;feedhttps:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;feed&#x2F;blog.xml 这个rss_feeds.txt放在文件夹sequence中。 从npm存储库中下载两个辅助模块。在sequence文件目录下，terminal中输入： 123npm init -ynpm install --save request@2.60.0npm install --save htmlparser@1.7.7 request模块是个经过简化的HTTP客户端，你可以用它获取RSS数据。htmlparser模块能把原始的RSS数据转换成JavaScript数据结构。 然后再目录下创建index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const fs=require('fs');const request=require('request');const htmlparser=require('htmlparser');const configFilename='./rss_feeds.txt';//确保包含RSS预订源URL列表的文件存在function checkForRSSFile()&#123; fs.exists(configFilename,(exists)=&gt;&#123; if(!exists)&#123; return next(new Error(`Missing RSS file:$&#123;configFilename&#125;`)); &#125; next(null,configFilename); &#125;)&#125;//读取并解析包含预订源URL的文件function readRSSFile(configFilename)&#123; fs.readFile(configFilename,(err,feedList)=&gt;&#123; if(err)&#123; return next(err); &#125; feedList=feedList.toString().replace(/^\\s+|\\s+$/g,'').split('\\n'); //从预订源URL数组中随机选择一个预订源URL const random=Math.floor(Math.random()*feedList.length); next(null,feedList[random]); &#125;)&#125;//向选定的预订源发送HTTP请求以获取数据function downloadRSSFeed(feedUrl)&#123; request(&#123;uri:feedUrl&#125;,(err,res,body)=&gt;&#123; if(err) return next(err); if(res.statusCode!==200)&#123; return next(new Error('Abnormal response status code')); &#125; next(null,body); &#125;)&#125;//将预订源数据解析到一个条目数组中function parseRSSFeed(rss)&#123; const handler=new htmlparser.RssHandler(); const parser=new htmlparser.Parser(handler); parser.parseComplete(rss); if(!handler.dom.items.length)&#123; return next(new Error('No RSS items found')); &#125; const item=handler.dom.items.shift(); //如果有数据，显示第一个预订源条目的标题和URL console.log(item.title); console.log(item.link);&#125;//把所有要做的任务按执行顺序添加到一个数组中const tasks=[ checkForRSSFile, readRSSFile, downloadRSSFeed, parseRSSFeed];//负责执行任务的next函数function next(err,result)&#123; if(err)&#123; throw err; &#125; const currentTask=tasks.shift(); //从任务数组中取出下个任务 if(currentTask)&#123; currentTask(result); &#125;&#125;next(); //开始执行 串行化执行的实现是通过一个数组tasks去承载要执行的任务。首先通过tasks.shift()方法从tasks数组中取出第一个任务checkForRSSFile，在执行这个任务的时候，它内部又调用了next方法，使得我们能够执行下一个任务，以此类推。这个负责执行任务的next函数会多次执行。 执行node index.js，输出结果： 12《聪明人用方格笔记术》“黄金三分法”http:&#x2F;&#x2F;www.read.org.cn&#x2F;html&#x2F;2438-cong-ming-ren-yong-fang-ge-bi-ji-shu-huang-jin-san-fen-fa.html 实现并行化流程控制为了让异步任务并行执行，仍然是要把任务放在数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续逻辑。 这里的例子就做一个简单的程序，读取几个文本文件的内容，并输出单词在整个文件中出现的次数。我们会用异步的readFile函数读取文本文件的内容，所以几个文件的读取可以并行执行。 这是目录组成： 1.txt： 1do you love me 2.txt： 1yes i do love you word_count.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const fs=require('fs');const tasks=[];const wordCounts=&#123;&#125;;const filesDir='../text';let completedTasks=0;function checkIfComplete()&#123; completedTasks++; if(completedTasks===tasks.length)&#123; for(let index in wordCounts)&#123; console.log(`$&#123;index&#125;:$&#123;wordCounts[index]&#125;`); &#125; &#125;&#125;function addWordCount(word)&#123; wordCounts[word]=(wordCounts[word])?wordCounts[word]+1:1;&#125;function countWordsInText(text)&#123; const words=text.toString().toLowerCase().split(/\\W+/).sort(); words.filter(word=&gt;word).forEach(word=&gt;addWordCount(word));&#125;fs.readdir(filesDir,(err,files)=&gt;&#123; if(err)&#123; throw err; &#125; files.forEach(file=&gt;&#123; //task函数声明，是立即执行的，获取filename const task=(file=&gt;&#123; return ()=&gt;&#123; fs.readFile(file,(err,text)=&gt;&#123; if(err)&#123; throw err; &#125; countWordsInText(text); checkIfComplete(); &#125;) &#125; &#125;)(`$&#123;filesDir&#125;/$&#123;file&#125;`); //将当前tast push到tasks数组中 tasks.push(task); &#125;) //开始并行执行所有任务 tasks.forEach(task=&gt;task());&#125;) 执行node word_count.js： 123456do:2i:1love:2yes:1you:2me:1","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"虚拟DOM","slug":"虚拟DOM","date":"2020-03-31T08:37:58.000Z","updated":"2020-03-31T09:24:53.071Z","comments":true,"path":"2020/03/31/虚拟DOM/","link":"","permalink":"http://delaprada.com/2020/03/31/%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"昨天面试的时候，面试官问到虚拟DOM的原理，被问到的时候，就把自己之前的理解说了一通，因为之前面试的时候也被问到过，觉得应该没问题。后来面试官质问了一下：“虚拟DOM最终也是使用DOM API去操作DOM，它的性能就一定会更好么 ? ” 然后就懵了….后来在网上搜了些资料，又有了些新的见解。 虚拟DOM的含义虚拟DOM是使用JS去模拟真实的DOM。DOM树上的结构、属性信息我们都可以使用JavaScript对象表示出来： 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;, ]&#125; 上面对应的HTML写法是： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 用JS操作真实DOM的操作：状态变更-&gt;重新渲染整个视图的方式，可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：虚拟DOM是局部更新的。虽然视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，减少了不必要的调用DOM API去操作DOM的操作。 算法实现步骤一：用JS对象模拟真实DOM用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js 123456789function Element (tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children&#125;module.exports = function (tagName, props, children) &#123; return new Element(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element') //模块化导入Element函数var ul = el('ul', &#123;id: 'list'&#125;, [ el('li', &#123;class: 'item'&#125;, ['Item 1']), el('li', &#123;class: 'item'&#125;, ['Item 2']), el('li', &#123;class: 'item'&#125;, ['Item 3'])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的&lt;ul&gt;： 1234567891011121314151617181920Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) &#123; // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的&lt;ul&gt;的DOM结构： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 步骤二：比较两棵虚拟DOM树的差异当我们要做出修改的时候，首先是要创建一个新的结点，然后使用diff算法去对比新旧节点的不同，这种对比只会在同层级进行，不会跨层进行，此处是使用深度优先遍历算法，然后将差异记录在patches对象当中。 同层级比较的话算法复杂度更低，降到O(n)。 深度优先遍历，记录差异： 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是0，那么： 1patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 差异类型： 上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;] 如果给div新增了属性id为container，就记录下： 123456789patches[0] &#x3D; [&#123; type: REPALCE, node: newNode &#x2F;&#x2F; el(&#39;section&#39;, props, children)&#125;, &#123; type: PROPS, props: &#123; id: &quot;container&quot; &#125;&#125;] 如果是文本节点，如上面的文本节点2，就记录下： 1234patches[2] = [&#123; type: TEXT, content: \"Virtual DOM2\"&#125;] 那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这就涉及到两个列表的对比算法，其实可以抽象出来是最小编辑距离问题（动态规划思想）。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： 1234patches[0] = [&#123; type: REORDER, moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]&#125;] 步骤三：把差异应用到真正的DOM树上因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。 使用patch方法将对象patches当中记录的更改应用到真实DOM上。 123456789101112131415161718192021function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点 var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; if (currentPatches) &#123; applyPatches(node, currentPatches) // 对当前节点进行DOM操作 &#125;&#125; applyPatches，根据不同类型的差异对当前节点进行 DOM 操作： 1234567891011121314151617181920function applyPatches (node, currentPatches) &#123; currentPatches.forEach(function (currentPatch) &#123; switch (currentPatch.type) &#123; case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 总结虚拟DOM的优缺点优点： 很多 DOM API 的读写都涉及页面布局的“重新计算”，以确保返回值的准确，涉及样式、结构的还会触发页面“重新绘制”，更耗性能。 综上，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。 虚拟DOM实际上最终还是会调用DOM API，但它能够减少不必要的DOM API调用。虚拟DOM遵循“在JS中缓存必要数据，计算界面更新时的阶段数据差异，只提交最终差集”的基本思路。 缺点： 使用JS去模拟真实DOM，会占用一定内存 diff算法，有计算方面的额外开销 参考： &lt;https://www.zhihu.com/search?type=content&amp;q=%E8%99%9A%E6%8B%9Fdom&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"使用JSONP实现跨域","slug":"使用JSONP实现跨域","date":"2020-03-29T07:23:53.000Z","updated":"2020-03-30T07:11:36.322Z","comments":true,"path":"2020/03/29/使用JSONP实现跨域/","link":"","permalink":"http://delaprada.com/2020/03/29/%E4%BD%BF%E7%94%A8JSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"同源策略 同源策略是浏览器的一个安全功能 同源指的是：协议，域名，端口号都相同 同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源 同源策略限制的内容有： cookie、localStorage等存储性内容 DOM节点 AJAX请求发送后，非同源会被浏览器拦截 但是有三个标签时允许跨域加载资源的： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 这就是JSONP的来源 JSONP实现跨域基本思想：网页通过添加一个&lt;script&gt;元素（因为src属性），向服务器请求json数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。但只支持GET请求。 实践代码： 创建一个JSONP文件夹，在其中添加template.html以及server.js。 template.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;jsonp testing&lt;/p&gt;&lt;/body&gt;&lt;script&gt; function jsonp(&#123;url,params,callback&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let script=document.createElement('script'); params=JSON.parse(JSON.stringify(params)); let arrs=[]; for(let key in params)&#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; arrs.push(`callback=$&#123;callback&#125;`); script.src=`$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;`; document.body.appendChild(script); window[callback]=function(data)&#123; resolve(data); document.body.removeChild(script); &#125; &#125;) &#125; jsonp(&#123; url:'http://localhost:3000/say', params:&#123; wd:'I love you' &#125;, callback:'show' &#125;).then(data=&gt;&#123; console.log(data); &#125;)&lt;/script&gt;&lt;/html&gt; server.js 123456789101112131415161718var express = require('express');var router = express.Router();var app = express();router.get('/say',function(req,res,next) &#123; //要响应回去的数据 let data = &#123; username : 'zs', password : 123456 &#125; let &#123;wd , callback&#125; = req.query; console.log(wd); console.log(callback); // 调用回调函数 , 并响应 res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`);&#125;)app.use(router);app.listen(3000); 上述代码实现的就是我们的html文档，使用jsonp方法向http://localhost:3000/say发起请求。当服务器监听到请求之后，将响应的数据放在指定名字的回调函数中传回来，然后调用callback回调函数执行resolve(data)。因为jsonp函数返回的是一个Promise对象，所以之后可以调用.then执行后续的console.log操作。 结果： 如果是AJAX请求： 12345678var xhr=new XMLHttpRequest();xhr.onReadyStateChange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; alert(xhr.responseText); &#125;&#125;xhr.open('get','http://localhost:3000/say',true);xhr.send(); 就会报跨域的错误：","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"乱序数组的三种方法","slug":"乱序数组的三种方法","date":"2020-03-28T05:27:18.000Z","updated":"2020-03-30T01:49:58.115Z","comments":true,"path":"2020/03/28/乱序数组的三种方法/","link":"","permalink":"http://delaprada.com/2020/03/28/%E4%B9%B1%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"今天面试的时候被问到实现乱序数组的最简便的方法，自己只知道使用Math.random()和结果数组的笨方法…总结一下。 sort()方法数组的sort()方法是按照return的值的正负来去做排序判定，所以实现的思路可以是使得返回的值随机正负。 12345function randArr(arr)&#123; return arr.sort(()=&gt;&#123; return (Math.random()-0.5); &#125;)&#125; Math.random()是生成0.0（包含）~1.0（不包含）之间的随机数。 但这么做是一个伪排序。参考：https://zhuanlan.zhihu.com/p/33260052 有大神做过测试，进行10000次乱序操作后，元素大概率停留在自己的初始位置上。 洗牌算法思路是： 找到数组的最后一个元素 从数组开头到最后一个元素之间，找到随机的一个数 交换两个元素的位置 此时最后一个元素已经是乱序后的结果 指向最后一个元素的索引前移 直到指向索引为0 1234567891011//洗牌算法function randArr3(arr)&#123; var length=arr.length; var r=length; var rand=0; while(r)&#123; rand=Math.floor(Math.random()*(r--)); [arr[r],arr[rand]]=[arr[rand],arr[r]]; &#125; return arr;&#125; Math.random()+结果数组12345678910function randArr2(arr)&#123; var res=[]; var len=arr.length; for(var i=0;i&lt;len;++i)&#123; var index=Math.floor(Math.random()*arr.length); res.push(arr[index]); arr.splice(index,1); &#125; return res;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"每日一题——单词的压缩编码","slug":"每日一题——单词的压缩编码","date":"2020-03-28T01:18:31.000Z","updated":"2020-03-28T01:25:53.258Z","comments":true,"path":"2020/03/28/每日一题——单词的压缩编码/","link":"","permalink":"http://delaprada.com/2020/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/","excerpt":"","text":"单词的压缩编码给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。 例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。 对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。 那么成功对给定单词列表进行编码的最小字符串长度是多少呢？ 示例： 123输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]输出: 10说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。 提示： 1231 &lt;&#x3D; words.length &lt;&#x3D; 20001 &lt;&#x3D; words[i].length &lt;&#x3D; 7每个单词都是小写字母 。 思路： 首先要先读懂题意，如果是单词之间的覆盖，只能是后缀覆盖，而不能是中间覆盖；其次，不一定是相邻的单词之间会出现覆盖，有可能像[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;, &quot;atime&quot;]跨着来覆盖。 所以我们先按单词的长度进行降序排列，这样先将最大的添加到结果字符串中，后续判断较小的单词只需要使用indexOf方法，就能够判断是否在结果字符串中。 需要注意的是，单词之间的覆盖只能是后缀覆盖，所以使用indexOf判断的时候要加上“#”。 题解： 123456789101112131415161718/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var minimumLengthEncoding = function(words) &#123; words.sort(function(a,b)&#123; return b.length-a.length; &#125;) var res=\"\"; res+=words[0]+\"#\"; for(var i=1;i&lt;words.length;++i)&#123; //加上#号就控制必须是后缀部分 if(res.indexOf(words[i]+\"#\")===-1)&#123; res+=words[i]+\"#\"; &#125; &#125; return res.length;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——合并区间","slug":"每日一题——合并区间","date":"2020-03-26T07:16:28.000Z","updated":"2020-03-26T07:22:58.815Z","comments":true,"path":"2020/03/26/每日一题——合并区间/","link":"","permalink":"http://delaprada.com/2020/03/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","excerpt":"","text":"合并区间给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路： 将每个区间的第一个数字放入start数组中，将每个区间的第二个数字放入end数组中，对start数组和end数组进行排序。判断start[i+1]和end[i]的大小，如果前者小，则说明区间有覆盖，i++；如果前者大，说明区间没有覆盖，可以将这个结果push进结果数组res中，同时j=i+1（j最开始为0）。 题解： 123456789101112131415161718192021222324252627282930/** * @param &#123;number[][]&#125; intervals * @return &#123;number[][]&#125; */var merge = function(intervals) &#123; var start=[]; var end=[]; var res=[]; for(var i=0;i&lt;intervals.length;++i)&#123; start.push(intervals[i][0]); end.push(intervals[i][1]); &#125; start.sort(function(a,b)&#123; return a-b; &#125;) end.sort(function(a,b)&#123; return a-b; &#125;) for(var n=0,m=0;n&lt;intervals.length;++n)&#123; if(n==intervals.length-1||start[n+1]&gt;end[n])&#123; res.push([start[m],end[n]]); m=n+1; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——编辑距离","slug":"每日一题——编辑距离","date":"2020-03-25T02:15:59.000Z","updated":"2020-03-25T02:44:32.174Z","comments":true,"path":"2020/03/25/每日一题——编辑距离/","link":"","permalink":"http://delaprada.com/2020/03/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"编辑距离给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符 示例 1: 123456输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 示例 2: 12345678输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;) 思路： 动态规划的思想。 如果word1[i]===word2[j]，dp[i][j]=dp[i-1][j-1]，也就是说word1的第i个单词和word2的第j个单词相同的话，那word1前i个单词要变为word2前j个单词的编辑次数就会等于word1前i-1和单词变为word2前j-1个单词的编辑次数。 如果word1[i]!=word2[j]，那dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 dp[i-1][j-1]表示替换操作，也就是将word1[i]替换为word2[j]，那dp[i][j]就等于dp[i-1][j-1]+1，也就是将word1前i-1个单词变为word2前j-1个单词所要执行的编辑次数+1（一次替换操作）。 dp[i-1][j]表示删除操作，就是将word1前i-1个字符变为word2前j个字符所要执行的操作+1（一次删除操作，即将word1的第i个字符删掉） dp[i][j-1]表示插入操作，就是将word1前i个字符变为word2前j-1个字符所要执行的操作+1（一次插入操作，在word1插入一个和word2第j个字符一样的字符） 题解： 12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;number&#125; */var minDistance = function(word1, word2) &#123; var dp=[]; var len1=word1.length; var len2=word2.length; for(var i=0;i&lt;=len1;++i)&#123; dp[i]=new Array(); &#125; for(var j=0;j&lt;=len1;++j)&#123; dp[j][0]=j; &#125; for(var k=0;k&lt;=len2;++k)&#123; dp[0][k]=k; &#125; for(var n=1;n&lt;=len1;++n)&#123; for(var m=1;m&lt;=len2;++m)&#123; //这里表示的是word1[n]==word2[m],但是因为n和m是从1开始取的,所以比较的时候要-1 if(word1[n-1]==word2[m-1])&#123; dp[n][m]=dp[n-1][m-1]; &#125; else&#123; dp[n][m]=Math.min(dp[n-1][m-1],dp[n][m-1],dp[n-1][m])+1; &#125; &#125; &#125; return dp[len1][len2];&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——按摩师","slug":"每日一题——按摩师","date":"2020-03-24T08:57:23.000Z","updated":"2020-03-24T08:58:20.779Z","comments":true,"path":"2020/03/24/每日一题——按摩师/","link":"","permalink":"http://delaprada.com/2020/03/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%8C%89%E6%91%A9%E5%B8%88/","excerpt":"","text":"面试题 17.16. 按摩师一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1： 123输入： [1,2,3,1]输出： 4解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。 示例 2： 123输入： [2,7,9,3,1]输出： 12解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。 示例 3： 123输入： [2,1,4,5,3,1,1,3]输出： 12解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。 思路： 动态规划的思想。但是这题和最大上升子序列的动态规划思想不同。这题与背包问题都是要求一个对于整体来说最大的和，但是最大上升子序列是求一个最长的上升子序列，之前的数要比当前的数小才能做一次计算，和是否相邻无关，所以最大上升子序列还需要在内层加多一层循环。 题解： 最初想的方案： 内层多了一个循环。 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var massage = function(nums) &#123; var F=[]; if(nums.length==1)&#123; return nums[0]; &#125; for(var m=0;m&lt;nums.length;++m)&#123; F[m]=0; &#125; F[0]=nums[0]; F[1]=nums[1]; for(var i=2;i&lt;nums.length;++i)&#123; for(var j=0;j&lt;=i-2;++j)&#123; F[i]=Math.max(F[j]+nums[i],F[i]); &#125; &#125; var max=0; for(var t=0;t&lt;F.length;++t)&#123; if(F[t]&gt;max)&#123; max=F[t]; &#125; &#125; return max;&#125;; 后来看评论优化的题解： dp思想：F[i]=Math.max(F[i-1],F[i-2]+nums[i]); 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var massage = function(nums) &#123; var F=[]; if(nums.length==0)&#123; return 0; &#125; if(nums.length==1)&#123; return nums[0]; &#125; for(var m=0;m&lt;nums.length;++m)&#123; F[m]=0; &#125; F[0]=nums[0]; F[1]=Math.max(nums[0],nums[1]); for(var i=2;i&lt;nums.length;++i)&#123; F[i]=Math.max(F[i-1],F[i-2]+nums[i]); &#125; return F[nums.length-1];&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"由instanceof原生实现理解__proto__和prototype的区别","slug":"由instanceof原生实现理解-proto-和prototype的区别","date":"2020-03-24T08:04:15.000Z","updated":"2020-03-24T08:55:41.494Z","comments":true,"path":"2020/03/24/由instanceof原生实现理解-proto-和prototype的区别/","link":"","permalink":"http://delaprada.com/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前几天面试的时候被问到instanceof的原生实现，当时对__proto__和prototype的区别理解不是很透彻，一直记得的是几个月前在网上的某篇博客上看到的结论：“__proto__：和prototype其实是一个东西，prototype是官方所定义的属性，__proto__是浏览器自己对prototype所做的实现。”后来仔细再查了些文章发现似乎并不是这样。 __proto__和prototype的区别原型prototype原型的定义：每个js对象（除了null）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 比如我们定义一个构造函数Person： 123function Person(name)&#123; this.name=name;&#125; 这样我们就创建了一个对象（function也是对象），那这个Person构造函数是有它的prototype的。这个Person prototype的构造函数constructor就是这个Person构造函数。我们还可以在这个Person prototype上去定义一些共享的属性和方法。 1234567function Person(name)&#123; this.name=name;&#125;Person.prototype.name=\"Alice\";Person.prototype.sayHello=function()&#123; console.log(\"Hello \"+this.name);&#125; 这样写就在Person prototype上定义了公用的属性name和sayHello。 现在创建两个对象实例： 12345var person1=new Person();var person2=new Person();person1.name=\"Emma\";console.log(person1.name); //Emmaconsole.log(person2.name); //Alice 我们为这个person1定义了它的实例属性name为”Emma”，那person2没有定义它的实例属性，所以它会沿着原型链去找它的原型去找是否有这个属性，因为Person.prototype里定义了name属性，所以输出Alice。 如果Person.prototype中没有定义name属性，那person2.name输出的是undefined，构造函数里的this.name是不起作用的。 __proto__ 以上这幅图大致可以说明__proto__和prototype的关系。 现在来说一下我们使用new去创建一个构造函数实例的时候做了些什么： new的原生实现： 123456function new(Parent,...args)&#123; var obj=&#123;&#125;; obj.__proto__=Parent.prototype; var res=Parent.apply(obj,args); return typeof res==\"object\"?res:obj;&#125; 我们使用new创建一个实例的时候，我们将这个实例的__proto__指向构造函数的原型。 __proto__和prototype并不是一样的： constructor1234function Person()&#123;&#125;Person.prototype.constructor===Person; //true 这个由上图可以看出。 12345function Person()&#123;&#125;var person1=new Person();person1.constructor===Person; //true 但是person1是没有constructor属性的，而是通过原型链去找到Person.prototype上的constructor属性。 Object.prototypeObject.prototype是没有原型的，Object.prototype就是尽头。 instanceof的原生实现instanceof在MDN当中的定义就是object instanceof constructor，判断这个constructor的prototype是否在object的原型链上。object原型链上的原型我们可以通过__proto__来去获取。 12345678910111213function myinstanceof(left,right)&#123; var leftval=left.__proto__; //实例用__proto__ var rightval=right.prototype; //构造函数用prototype while(true)&#123; if(leftval==null)&#123; return false; //Object.prototype.__proto__为null &#125; if(leftval==rightval)&#123; return true; &#125; leftval=leftval.__proto__; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Promise实现任务顺序执行&并行执行&发起ajax请求","slug":"Promise实现任务顺序执行和并行执行","date":"2020-03-21T13:46:14.000Z","updated":"2020-03-24T01:17:01.763Z","comments":true,"path":"2020/03/21/Promise实现任务顺序执行和并行执行/","link":"","permalink":"http://delaprada.com/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/","excerpt":"","text":"Promise实现任务并行执行使用Promise.all方法： 123456789101112var p1=new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;)p1.then(result=&gt;result);var p2=new Promise((resolve,reject)=&gt;&#123; resolve('hi');&#125;)p1.then(result=&gt;result);var p=Promise.all([p1,p2]);p.then(result=&gt;console.log(result)); Promise实现任务顺序执行在.then里要return一个new Promise，这样后续才能继续使用.then执行后续操作： 1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) 输出： Promise封装ajax请求123456789101112131415161718192021222324252627282930function myHttpClient(method,url,data)&#123; return new Promise(function(resolve,reject)&#123; var xhr; if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125; else&#123; xhr=new ActiveXObject('Microsoft XMLHttp'); &#125; var method=method||'GET'; var data=data||null; xhr.open(method,url,true); xhr.onReadyStateChange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;=300)||xhr.status==304)&#123; resolve(xhr.responseText); &#125; else&#123; reject(new Error(xhr.statusText)); &#125; &#125; &#125; xhr.send(data); &#125;)&#125;myHttpClient('GET',url,null).then(function(data)&#123; console.log(data);&#125;,function(error)&#123; console.log(error);&#125;) 思想就是：将整个使用XMLHttpRequest去发起异步网络请求的操作封装在new Promise当中，执行函数返回一个Promise，那后续可以使用.then来执行后续的操作。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"设置display:none对DOM树和渲染树的影响","slug":"设置display-none对DOM树和渲染树的影响","date":"2020-03-21T01:50:17.000Z","updated":"2020-03-30T03:38:27.569Z","comments":true,"path":"2020/03/21/设置display-none对DOM树和渲染树的影响/","link":"","permalink":"http://delaprada.com/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"原本的样式12345678910111213141516171819&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .main&#123; width:100px; height:100px; background-color: lightyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"main\"&gt; display属性testing &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置display:none对渲染树的影响在原本的style中添加上display:none： 12345678&lt;style&gt; .main&#123; width:100px; height:100px; background-color: lightyellow; display:none; &#125;&lt;/style&gt; 页面上没有显示任何东西： 所以设置display:none是会将节点从渲染树中摘除的。 设置display:none对DOM树的影响我们在刚才的代码中添加上一段js代码： 1234&lt;script&gt; var node=document.getElementsByClassName(\"main\")[0]; console.log(node.innerText);&lt;/script&gt; 控制台输出： 说明DOM树中该节点并没有消失，否则不会获取到DOM上的信息。 设置display:none对CSS规则树的影响我们在div当中添加style样式： 123&lt;div class=\"main\" style=\"width:100px\"&gt; display属性testing&lt;/div&gt; 在script中添加： 1console.log(node.style.width); 控制台输出： 说明CSS规则树中该节点的样式没有消失。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"每日一题——水壶问题","slug":"每日一题——水壶问题","date":"2020-03-21T00:37:01.000Z","updated":"2020-03-21T00:43:46.398Z","comments":true,"path":"2020/03/21/每日一题——水壶问题/","link":"","permalink":"http://delaprada.com/2020/03/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/","excerpt":"","text":"有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: (From the famous *”Die Hard”* example) 12输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4输出: True 示例 2: 12输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5输出: False 思路： 当x=3,y=5,z=4的时候怎么倒出4L水： 首先装满x，将x中的3L水倒入y中， 然后再装满x，将x的水倒入y中，此时只能倒2L，那x中就剩下1L水 将y中的水倒掉，将x中的1L水倒入 x再装满3L水，倒入y中，此时y就有4L水 它的思路就是：x和y的最大公约数是否能够被z整除。与此同时要考虑，x和y加起来的大小是否比z要小，如果小的话就不可能装得下。还要考虑，两个壶为0的情况，因为mod操作是不能mod0的。 题解： 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @param &#123;number&#125; z * @return &#123;boolean&#125; */var canMeasureWater = function(x, y, z) &#123; var temp; if(x&gt;y)&#123; temp=x; x=y; y=temp; &#125; if(x+y&lt;z)&#123; return false; &#125; while(x!=0)&#123; temp=y; y=x; x=temp%x; &#125; if(y==0&amp;&amp;z==0)&#123; return true; &#125; else if(y==0&amp;&amp;z!=0)&#123; return false; &#125; else&#123; if(z%y==0)&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——矩阵重叠","slug":"每日一题——矩阵重叠","date":"2020-03-18T01:28:56.000Z","updated":"2020-03-18T01:31:05.226Z","comments":true,"path":"2020/03/18/每日一题——矩阵重叠/","link":"","permalink":"http://delaprada.com/2020/03/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/","excerpt":"","text":"矩形重叠矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 12输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]输出：true 示例 2： 12输入：rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]输出：false 说明： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。矩形中的所有坐标都处于 -10^9 和 10^9 之间。 思路： 两个矩形，我们只需要关注它们离彼此最近的两个点。两个矩阵只要靠左边矩形的右上角的x比右边矩形左下角的x要小（小于等于）的话，就不会重叠；或者是，靠左边矩形的右下角的y比右边矩形右上角y要大（大于等于）的话，也不会重叠。因为rec1和rec2的顺序不一定就是rec1在左，rec2在右，所以要考虑反过来情况。 题解： 12345678/** * @param &#123;number[]&#125; rec1 * @param &#123;number[]&#125; rec2 * @return &#123;boolean&#125; */var isRectangleOverlap = function(rec1, rec2) &#123; return !(rec1[2]&lt;=rec2[0]||rec2[2]&lt;=rec1[0]||rec1[1]&gt;=rec2[3]||rec2[1]&gt;=rec1[3]);&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——岛屿的最大面积","slug":"每日一题——岛屿的最大面积","date":"2020-03-15T01:13:59.000Z","updated":"2020-03-15T01:20:00.660Z","comments":true,"path":"2020/03/15/每日一题——岛屿的最大面积/","link":"","permalink":"http://delaprada.com/2020/03/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"岛屿的最大面积给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 思路：和腐烂的橘子的思想类似，使用广度优先遍历，然后queue来实现（JS中用普通数组，使用shift来获取列头元素，不要写错成pop()，c++中队列的pop()和JS中普通数组的shift()才是对应的）。而且要另外维护一个flag数组，用来记录每个数组中的元素是否已经判断过了，如果判断过了的话，就要将flag变为true，下一次不用再去判断。 用JS声明二维数组的方式： 12345678var a = new Array();for(var i=0;i&lt;3;i++)&#123; //一维长度为3 a[i] = new Array(); for(var j=0;j&lt;5;j++)&#123; //二维长度为5 a[i][j] = i+j; &#125;&#125; 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var maxAreaOfIsland = function(grid) &#123; var q=[]; var res=0; var count=0; var step=[[-1,0],[1,0],[0,1],[0,-1]]; //用来进行广度遍历 var flag=new Array(); for(var n=0;n&lt;grid.length;++n)&#123; flag[n]=new Array(); for(var m=0;m&lt;grid[0].length;++m)&#123; flag[n][m]=false; &#125; &#125; for(var i=0;i&lt;grid.length;++i)&#123; for(var j=0;j&lt;grid[0].length;++j)&#123; if(grid[i][j]==1&amp;&amp;flag[i][j]==false)&#123; count++; q.push([i,j]); flag[i][j]=true; while(q.length!==0)&#123; var temp=q.shift(); for(var k=0;k&lt;step.length;++k)&#123; var x=temp[0]+step[k][0]; var y=temp[1]+step[k][1]; if(x&gt;=0&amp;&amp;x&lt;grid.length&amp;&amp;y&gt;=0&amp;&amp;y&lt;grid[0].length)&#123; if(grid[x][y]==1&amp;&amp;flag[x][y]==false)&#123; q.push([x,y]); flag[x][y]=true; count++; &#125; &#125; &#125; &#125; if(count&gt;res)&#123; res=count; &#125; count=0; &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——最大上升子序列","slug":"最大上升子序列","date":"2020-03-14T03:11:50.000Z","updated":"2020-03-14T03:13:45.148Z","comments":true,"path":"2020/03/14/最大上升子序列/","link":"","permalink":"http://delaprada.com/2020/03/14/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 思路： 动态规划的思想。先初始化每个元素的最大上升子序列长度为1。当前元素的最大上升子序列数应为在它前面比该元素小的元素的最大上升子序列数的最大值+1。 题解： 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var lengthOfLIS = function(nums) &#123; if(nums.length==0)&#123; return 0; &#125; var dp=[]; for(var i=0;i&lt;nums.length;++i)&#123; dp[i]=1; &#125; for(var j=0;j&lt;nums.length;++j)&#123; for(var k=0;k&lt;j;++k)&#123; if(nums[j]&gt;nums[k])&#123; dp[j]=Math.max(dp[k]+1,dp[j]); &#125; &#125; &#125; var res=1; for(var p=0;p&lt;nums.length;++p)&#123; if(dp[p]&gt;res)&#123; res=dp[p]; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"如何理解异步","slug":"如何理解异步","date":"2020-03-13T02:59:49.000Z","updated":"2020-03-13T03:03:10.481Z","comments":true,"path":"2020/03/13/如何理解异步/","link":"","permalink":"http://delaprada.com/2020/03/13/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/","excerpt":"","text":"什么是异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。 例如： 1234setTimeout(function()&#123; XXX;&#125;,1000)console.log(\"XXX\"); setTimeout就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。setTimeout是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行setTimeout任务的第二部分，执行XXX。 如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。 异步编程的解决方案回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。callback的意思就是“重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 PromisePromise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。 Promise的话任务也是分为两个部分，new Promise作为第一部分立即执行，然后将执行权交给其他任务，当执行完毕后才会执行event queue当中的回调函数。 Promise的最大问题是代码冗余：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 （其他代码部分属于一个协程，中间的yield部分属于另一个协程） 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 执行gen（）的时候，它执行了var url = &#39;https://api.github.com/users/github&#39;;操作，因为遇到了yield，所以交出了当前异步任务的执行权。执行.next()方法的时候才会执行fetch(url)操作，fetch(url)任务执行完毕之后，才会将执行权交还给异步任务，去执行异步任务的第二部分。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"每日一题——零钱兑换","slug":"每日一题——零钱兑换","date":"2020-03-08T00:33:18.000Z","updated":"2020-03-08T00:38:37.811Z","comments":true,"path":"2020/03/08/每日一题——零钱兑换/","link":"","permalink":"http://delaprada.com/2020/03/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","excerpt":"","text":"零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11输出: 3 解释: 11 &#x3D; 5 + 5 + 1 示例 2: 12输入: coins &#x3D; [2], amount &#x3D; 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 思路：动态规划的思想，每种硬币都找到当前自身的最优解，从而求出结果为amount时的最优解。在初始化的时候，要为每种金额的硬币声明一个初始的解，这个解应该是个比amount要大的值（因为解最大为amount）。这样我们在做结果判断的时候就可以知道，如果当前解是amount+1就说明没有组合能组成总金额。 题解： 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; coins * @param &#123;number&#125; amount * @return &#123;number&#125; */var coinChange = function(coins, amount) &#123; coins.sort(function(a,b)&#123; return a-b; &#125;) console.log(coins); var F=[]; for(var i=0;i&lt;=amount;++i)&#123; F[i]=amount+1; &#125; F[0]=0; for(var j=0;j&lt;=amount;++j)&#123; for(var k=0;k&lt;coins.length;++k)&#123; if(j&lt;coins[k])&#123; break; &#125; else&#123; F[j]=Math.min(F[j-coins[k]]+1,F[j]); //注意此处是F[j] &#125; &#125; &#125; return F[amount]!==amount+1?F[amount]:-1;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——腐烂的橘子","slug":"每日一题——腐烂的橘子","date":"2020-03-04T01:47:21.000Z","updated":"2020-03-04T07:26:47.849Z","comments":true,"path":"2020/03/04/每日一题——腐烂的橘子/","link":"","permalink":"http://delaprada.com/2020/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","excerpt":"","text":"在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 123456789101112输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。示例 3：输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1231 &lt;&#x3D; grid.length &lt;&#x3D; 101 &lt;&#x3D; grid[0].length &lt;&#x3D; 10grid&#96;[i][j]&#96; 仅为 0、1 或 2 思路： 广度优先搜索。广度优先搜索的话一般会使用队列的思想，深度优先搜索使用栈的思想。最主要还有如何去控制节点去上下左右遍历，所以我们要设置一个locs数组为：[[0,-1],[0,1],[1,0],[-1,0]]，在遍历每个队列元素时，都让它去和locs数组的每个元素进行相加减，得到这个元素上下左右的元素，将为1的元素（即新鲜橙子），变为2（即腐烂橙子）。因为我们要计算时间，但又不能将循环次数用来计时，所以我们将时间和节点的x，y坐标一齐作为一个元素进入队列。 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var orangesRotting = function(grid) &#123; var row=grid.length; var col=grid[0].length; var queue=[]; var locs=[[0,-1],[0,1],[1,0],[-1,0]]; var time=0; var x,y; for(var i=0;i&lt;row;++i)&#123; for(var j=0;j&lt;col;++j)&#123; if(grid[i][j]==2)&#123; queue.push([i,j,time]); &#125; &#125; &#125; while(queue.length!==0)&#123; //这是queue！！不要写成stack,先进先出是用shift [x,y,time]=queue.shift(); for(var t=0;t&lt;locs.length;++t)&#123; var new_x=x+locs[t][0]; var new_y=y+locs[t][1]; if(new_x&gt;=0&amp;&amp;new_x&lt;row&amp;&amp;new_y&gt;=0&amp;&amp;new_y&lt;col)&#123; if(grid[new_x][new_y]===1)&#123; queue.push([new_x,new_y,time+1]); grid[new_x][new_y]=2; &#125; &#125; &#125; &#125; for(var p=0;p&lt;row;++p)&#123; for(var q=0;q&lt;col;++q)&#123; if(grid[p][q]==1)&#123; return -1; &#125; &#125; &#125; return time;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——版本号比较 随机生成字符串 类型比较","slug":"每日一题——版本号比较-随机生成字符串","date":"2020-03-03T09:01:38.000Z","updated":"2020-03-03T14:14:37.536Z","comments":true,"path":"2020/03/03/每日一题——版本号比较-随机生成字符串/","link":"","permalink":"http://delaprada.com/2020/03/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"版本号比较比较版本号 （类似1.0.1/1.2.0/1.2/0.1）实现一个方法，用于比较两个版本号（version1、version2）如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则x.y.z，xyz均为大于等于0的整数，至少有x位 123456789101112131415161718192021222324252627282930313233function compare(str1,str2)&#123; str1=str1.split(\".\"); str2=str2.split(\".\"); str1=str1.map(Number); str2=str2.map(Number); var len; var len1=str1.length; var len2=str2.length; if(len1&gt;len2)&#123; len=len2; &#125; else&#123; len=len1; &#125; for(var i=0;i&lt;len;++i)&#123; if(str1[i]&gt;str2[i])&#123; return 1; &#125; else if(str1[i]&lt;str2[i])&#123; return -1; &#125; &#125; if(len1===len2)&#123; return 0; &#125; else if(len1&gt;len2)&#123; return 1; &#125; else&#123; return -1; &#125;&#125;console.log(compare('1.0.1','1.0')); 随机生成字符串随机生成字符串实现一个随机符串生成函数 randomStr()，要求如下：生成的随机的字符串应该以字母开头，并包含 [a-z][0-9] 这些字符。生成的字符串长度为 8。生成的字符串不能够在程序运行的生命周期中存在重复的情形。 1234567891011121314function randomString(len,chars)&#123; var res=''; for(var i=0;i&lt;len;++i)&#123; //因为Math.random()包括0但不包括1，所以可以直接乘上chars.length if(i==0)&#123; res+=chars[Math.floor(Math.random()*26)]; &#125; else&#123; res+=chars[Math.floor(Math.random()*chars.length)]; &#125; &#125; return res;&#125;console.log(randomString(8,'abcdefghijklmnopqrstuvwxyz0123456789')); 隐式类型转换下面代码中 a 在什么情况下会打印 1？1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 题解： 123456789var a=&#123; i:1, toString()&#123; return this.i++; &#125;&#125;if(a==1&amp;&amp;a==2&amp;&amp;a==3)&#123; console.log(1);&#125;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"易混淆JS题目——this指向 闭包","slug":"易混淆JS题目——this指向-闭包","date":"2020-02-18T02:23:00.000Z","updated":"2020-02-18T02:24:06.154Z","comments":true,"path":"2020/02/18/易混淆JS题目——this指向-闭包/","link":"","permalink":"http://delaprada.com/2020/02/18/%E6%98%93%E6%B7%B7%E6%B7%86JS%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94this%E6%8C%87%E5%90%91-%E9%97%AD%E5%8C%85/","excerpt":"","text":"Q：代码运行结果 1234567var a = function () &#123; this.b = 3; &#125;var c = new a();a.prototype.b = 9;var b = 7;a();console.log(b);console.log(c.b); 解： 整个代码在变量提升之后可以写为： 123456789101112var a;var c;var b;a=function()&#123; this.b=3;&#125;c=new a();a.prototype.b=9;b=7;a();console.log(b);console.log(c.b); 注意：函数声明的时候还没有执行！不要弄混了。当执行c=new a()的时候，会将函数a内部的this指向c，所以c.b此时就是3。a.prototype.b=9没有什么影响。b=7;表示将全局变量b赋值为7。此后执行了函数a()，要注意在默认情况下，函数中this的指向是指向全局作用域的，所以执行函数a()的话是把全局变量b的值变为3。所以输出的是3 3。 Q：以最小的改动解决以下代码的错误（可以使用es6） 123456789101112131415const obj = &#123;name: \" jsCoder\",skill: [\"es6\", \"react\", \"angular\"],say: function () &#123; for(var i = 0, len = this.skill.length; i&lt; len; i++)&#123; setTimeout(function()&#123; console.log('No.' + i + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i); &#125;&#125;&#125;;obj.say(); 解： 第一点：for循环当中有个异步函数，而且异步函数根据for循环i的值依次输出No.1，No.2，No.3，这样的话for循环中i必须使用let去声明，因为使用let才能让异步函数记住每一轮i的值，得到相应的输出结果。 第二点：在对象函数say中，有一个异步函数，它使用了this。源代码的意图是想让这个this表示对象obj，但是对象的方法say的this指向的是obj，但是这个方法内部的函数（使用了闭包）是指向全局变量的！这么写是得不到想要的结果的。所以要将setTimeout函数改为箭头函数，因为箭头函数它会继承上一层作用域的this，所以它会继承say函数的this，就会指向obj了。 修改后的代码为： 12345678910111213141516const obj = &#123; name: \" jsCoder\", skill: [\"es6\", \"react\", \"angular\"], say: function () &#123; for(let i = 0,len=this.skill.length; i&lt;len; i++)&#123; //闭包！！ setTimeout(()=&gt;&#123; console.log('No.' + (i+1) + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i+1); &#125; &#125;&#125;;obj.say(); Q：repeat 实现，使用JS实现一个repeat方法，调用这个 repeatedFunc(“helloworld”)，会alert4次 helloworld, 每次间隔3秒 1234function repeat(func, times, wait) &#123;&#125;const repeatFunc = repeat(alert, 4, 3000)repearFunc(\"helloworld\"); 解： 这种问题一般要结合闭包来实现。 1234567891011121314function repeat(func, times, wait)&#123; var count=0; var timer=null; return function()&#123; var args=[].slice.call(arguments); timer=setInterval(function()&#123; if(count==(times-1))&#123; clearTimeout(timer); &#125; func(args.join(\"\")); count++; &#125;,wait) &#125;&#125; 题目中说，调用repeatedFunc(&quot;helloworld&quot;)会有相关的结果，所以它应该是在函数中还有一个函数的，所以应该有个闭包。通过闭包可以记住count的值。注意clearTimeout要写在setInterval函数当中，这个和防抖节流不同，因为它只执行了一次函数，它是通过setInterval函数的循环才会输出多次结果，所以要写在里面才能够判断count的值是否已经到达输出次数。 Q：实现每隔1s输出一个数组的元素及其索引 解： 这题和上一题的思路类似，但是它没有需要说要调用的时候再去执行，那就不需要写return functionf(){}了。因为setInterval函数已经是output函数的内部函数，有闭包能够记住count的值了。 123456789101112131415function output(arr) &#123; var length = arr.length; var count = 0; var timer = null; timer = setInterval(function() &#123; if (count == length - 1) &#123; clearTimeout(timer); &#125; console.log(arr[count]); console.log(count); count++; &#125;, 1000);&#125;output([1, 2, 3, 4, 5]);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Vue之计算属性的应用","slug":"Vue之计算属性的应用","date":"2020-02-17T02:52:19.000Z","updated":"2020-02-17T02:54:22.665Z","comments":true,"path":"2020/02/17/Vue之计算属性的应用/","link":"","permalink":"http://delaprada.com/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"昨天面试的时候被问到了Vue计算属性相关的代码题，又是一脸懵逼呀…赶紧来总结一下。 面试官先出了第一道题，点击div时输出是什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 输出是3。 首先，computed中的属性都是以函数的形式声明的，看看官网的例子： 结果是： 123Original message: &quot;Hello&quot;Computed reversed message: &quot;olleH&quot; computed属性它所依赖的数据是data当中的，是要使用this来去获取的。所以计算属性c中的this.b和this.a其实是data当中的属性值。执行点击事件之后，b是会发生变化的，所以在计算属性c中输出this.b是会发生变化的，所以在控制台会输出3。因为计算属性creturn的是this.a，所以的值是不变的，是1。 接着面试官又出了第二道题，此时又输出什么？（其实面试官人真的好好，他的表述是此时会输出么？他这么问的话我就会倾向于回答不会输出） 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; if(false)&#123; console.log(this.b); return this.a; &#125; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 答案是不输出。此时c连渲染都不会发生。 最后面试官又问了第三道题，此时会输出什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;absdflj&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 此时这个计算属性并没有写在页面上，所以是不会监听c的值，此时控制台没有输出，页面显示的是：absdflj。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"JavaScript之变量提升","slug":"JavaScript之变量提升","date":"2020-02-17T01:58:59.000Z","updated":"2020-02-17T02:32:12.967Z","comments":true,"path":"2020/02/17/JavaScript之变量提升/","link":"","permalink":"http://delaprada.com/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"今天面试的时候被问到了变量提升的问题，一脸懵逼，掌握得不够熟练，写篇博客来总结一下。 JS代码解析规则 第一步为解释：先扫描所有的JS代码，把所有声明提升到顶端。 第二步为执行：执行就是操作一类的。 变量提升例一： 12console.log(a); //undefinedvar a=10; 因为有变量提升，上面的代码相当于： 123var a;console.log(a);a=10; 函数提升函数声明的两种方式 函数声明式 1function bar()&#123; &#125; 函数字面量式 1var bar=function()&#123; &#125; 注意：函数字面量式的提升和变量提升一样，都是只提升声明，不提升赋值，比如上面代码中函数字面量式，只会把var bar提升上去，但是函数声明式是会将整个函数体都提升上去。 例二： 1234foo(); //aaafunction foo()&#123; console.log(\"aaa\");&#125; 因为存在函数声明提升，函数声明提升会直接把整个函数提升到执行环境的最顶端。相当于： 1234function foo()&#123; console.log(\"aaa\");&#125;foo(); 注意：变量提升只提升变量名，而函数提升是会提升整个函数体。函数提升在变量提升之前。 例三： 1234foo(); //foo is not a functionvar foo = function()&#123; console.log(\"aaa\");&#125; 因为进行了变量提升（函数字面量式），上面的代码相当于： 12345var foo;foo();foo=function()&#123; console.log(\"aaa\");&#125; JS解析在遇到foo()时会默认当做函数来解析，所以会输出foo is not a function。 例四： 1234567console.log(foo);var foo=10;console.log(foo);function foo()&#123; console.log(10);&#125;console.log(foo); 输出： 上面的代码相当于： 12345678function foo()&#123; console.log(10);&#125;var foo;console.log(foo); //foo()&#123;console.log(10);&#125;foo=10;console.log(foo); //10console.log(foo); //10 第一个console.log(foo)之所以输出函数体，是因为var foo只是声明（提升了的声明），并没有赋值，所以它会调用上面的函数体。 面试题先看一道经典面试题： 123456789console.log(v1);var v1 = 100;function foo() &#123; console.log(v1); var v1 = 200; console.log(v1);&#125;foo();console.log(v1); 输出是： 1234&#x2F;&#x2F;undefined&#x2F;&#x2F;undefined&#x2F;&#x2F;200&#x2F;&#x2F;100 上面的代码相当于： 1234567891011var v1;console.log(v1); //undefinedv1=100;function foo()&#123; var v1; console.log(v1); //undefined v1=200; console.log(v1); //200&#125;foo();console.log(v1); //100 注意，如果内部没有声明v1的时候，函数才会到全局作用域去查找变量的赋值。但是如果函数作用域内部定义了的话，就不会到全局作用域去找。参照作用域链的定义。 看一道字节面试时候的题目： 1234567891011var a = 'byte'function foo() &#123; if (a === undefined) &#123; var a = 'dance' &#125; else &#123; a = 'bytedance' &#125; return a;&#125;console.log(foo());console.log(a); 输出为： 12&#x2F;&#x2F;dance&#x2F;&#x2F;byte 上面代码实际效果是： 1234567891011121314function foo()&#123; var a; if(a===undefined)&#123; a='dance'; &#125; else&#123; a='bytedance'; &#125; return a;&#125;var a;a='byte';console.log(foo());console.log(a); 在当前作用域有对变量进行声明的时候，是不会去上一级作用域去寻找变量的声明的。 因为console.log(a)在当前函数作用域找到了var a;，即a的定义，所以它不会去全局作用域去找a的声明（及值）。 上面的代码也是这个道理，a===undefined会找到当前函数作用域的var a;的定义，所以a的值为undefined。 参考：https://blog.csdn.net/qq_39712029/article/details/80951958 ​ https://blog.csdn.net/Demo_18/article/details/78493489","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Math.floor()和~~运算符的异同","slug":"Math-floor-和-的异同","date":"2020-02-10T03:14:06.000Z","updated":"2020-02-10T03:30:38.297Z","comments":true,"path":"2020/02/10/Math-floor-和-的异同/","link":"","permalink":"http://delaprada.com/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"今天在用JavaScript实现大数相加的时候，发现网上的解法当中有使用~~运算符，之前没有见过。在网上一查，说是Math.floor()的更好的一种表示方法，运行速度更快。但是将大数相加的代码中的~~换成Math.floor()发觉得不到正确的答案，所以想来分析一下异同。 ~和~~~运算符用于将整数变为-(N+1)。 例如： 1234~2 &#x3D;&#x3D;&#x3D; -3; &#x2F;&#x2F;true~1 &#x3D;&#x3D;&#x3D; -2; &#x2F;&#x2F;true~0 &#x3D;&#x3D;&#x3D; -1; &#x2F;&#x2F;true~-1 &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;true ~~运算符~~是Math.floor()的一个替代，相同的操作但是更快。可以使用它将任何浮点数转换为整数（下取整）。 例如： 123~~2 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~2.4 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~3.9 &#x3D;&#x3D;&#x3D; Math.floor(3); &#x2F;&#x2F;true, 3 ~~和Math.floor()在性能上的不同： # Browser Math.floor() Bitwise double NOT ~~ #1 Firefox 7.0.1 42ms 29ms #2 Firefox 7.0.1 44ms 28ms #3 Chrome 15 63ms 64ms #4 Chrome 15 63ms 68ms #5 IE8 265ms 192ms #6 IE8 324ms 190ms 大数相加在大数相加时，使用~~能够的到正确的结果： 但是使用Math.floor()时，结果是： 主要是因为当a数组已经pop完毕之后，再对a执行pop操作时，输出的是undefined。而~~操作undefined和Math.floor()操作undefined是会得出不同的结果的： 所以才会导致上面的结果。 参考：http://rocha.la/JavaScript-bitwise-operators-in-practice","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2020-02-04T10:17:33.000Z","updated":"2020-02-17T10:17:45.311Z","comments":true,"path":"2020/02/04/浏览器缓存/","link":"","permalink":"http://delaprada.com/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"缓存过程分析： 浏览器每次发起请求，都会先在浏览器缓存中查找请求的结果以及缓存标识 如果没有该请求的缓存结果和缓存标识的话，浏览器会向服务器发起http请求，服务器返回该请求结果和缓存规则 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强缓存和协商缓存浏览器缓存分为：强缓存和协商缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源。可以通过设置两种http header实现：Expires和Cache-Control。 Expires是http/1的产物。它用来指定资源到期的时间，Expires是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间之前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 1Expires: Thu, 10 Nov 2017 08:45:11 GMT 这个字段设置时有两个缺点： 由于是绝对时间，用户可能会将客户端本地的时间修改，而导致浏览器判断缓存失效，重新请求该资源。 写法太复杂，表示时间的字符串多个空格，少个字母都会导致非法属性从而失效 Cache-control是http/1.1的产物。和Expires的差别在于，Expires是绝对时间，Cache-control表示的是相对时间 1Cache-control: max-age=2592000 Cache-control字段常用的值： max-age：即最大有效时间 must-revalidate：如果超过了max-age的时间，浏览器必须向服务器发送请求，验证资源是否还有效 no-cache：不是不缓存的意思！表示可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用。 no-store：彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取 public：所有内容都可以被缓存（包括客户端和代理服务器，如CDN） private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。 自从http/1.1开始，Expires逐渐被Cache-control取代。Cache-control是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且Cache-control的可配置性比较强大。 强缓存判断是否缓存的依据来自于是否超出某个时间或者时间段，而不关心服务器端文件是否已经更新，这可能导致加载文件不是服务器端最新的内容。那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存：是由服务器来确定缓存资源是否可用，所以客户端与服务器端需要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 主要有以下两种标识： Last-Modified和If-Modified-Since： Last-Modified：浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加Last-Modified的header，值是这个资源在服务器端的最后修改时间。 If-Modified-Since：浏览器下一次请求这个资源，浏览器检测有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值。服务器再次收到这个资源的请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，可以直接从缓存读取。如果服务器端这个资源在If-Modified-Since之后被修改了，说明文件有更新，返回新的资源文件和200。 Etag和If-None-Match: Etag和If-None-Match返回的是一个校验码。Etag可以保证每一个资源是唯一的，资源变化都会导致Etag变化。 当浏览器第一次请求资源的时候，服务器会在响应报文中添加Etag（表示资源的标签）。当浏览器再次发起请求的时候，请求报文中会添加If-None-Match字段，其值是上一次响应报文中Etag的值。服务器收到请求报文的时候，会检查If-None-Match的值与当前资源Etag的值是否匹配。如果匹配，也就是资源没有被修改，返回304；如果不匹配，也就是服务器端资源被修改了，返回200，并返回新的资源。 为什么有了Last-Modified和If-Modified-Since还要Etag和If-None-Match呢？ 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用 某些文件修改非常频繁，比如在秒以下级别的时间内进行修改（比如1s内修改了N次），If-Modified-Since能检查到的粒度只能是秒级别的，这种修改无法判断。 协商缓存生效：返回304和Not Modified。即服务器端资源并没有更新，可以继续使用浏览器缓存中的结果。 协商缓存失败，返回200和请求结果。即服务器端资源更新了，获取服务器端的返回结果，并把请求结果和缓存标识存入浏览器缓存中 总结缓存机制： 强制缓存优先于协商缓存进行 若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match) 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。 Last-Modified/If-Modified-Since 和 Etag/If-None-Match的主要区别就是一个是通过时间判断资源是否已被更改，一个是通过Etag来判断。Etag/If-None-Match相比于Last-Modified/If-Modified-Since来说更好。 摘自：https://www.cnblogs.com/yayaxuping/p/9707471.html ​ https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器渲染过程","slug":"浏览器渲染过程","date":"2020-01-31T01:50:01.000Z","updated":"2020-02-18T03:29:31.895Z","comments":true,"path":"2020/01/31/浏览器渲染过程/","link":"","permalink":"http://delaprada.com/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","excerpt":"","text":"浏览器渲染的过程主要包括以下5步 浏览器将获取的HTML文档解析为DOM树 处理CSS标记，构成CSS规则树 将DOM树和CSS规则树合并为渲染树（rendering tree），生成渲染树 渲染树布局，确定每个节点对象在页面上的确切大小和位置 将渲染树的各个节点绘制到屏幕上 具体流程构建DOM树当浏览器接受到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。注意：DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。 构建CSS规则树浏览器解析CSS文件并生成CSS规则树。注意：CSS解析可以与DOM解析同时执行，但与script的执行互斥。 构建渲染树（Render Tree）通过DOM树和CSS规则树，浏览器可以通过它们构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。 渲染树生成后，还不能渲染到屏幕上。因为渲染到屏幕上需要得到各个节点的位置信息，这就需要布局的处理。 渲染树布局布局阶段从渲染树的根节点开始遍历，渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。浏览器通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。 渲染树绘制将渲染树绘制到浏览器上。 主流的一些浏览器排版（渲染）引擎 浏览器 排版引擎 Chrome Opera Blink Firefox Gecko IE Trident Safari WebKit 渲染阻塞渲染阻塞的原因：由于JavaScript可以操作DOM来修改DOM结构，可以操作CSS规则树来修改节点样式，这就导致浏览器在遇到&lt;script&gt;标签时，DOM构建将暂停，直到脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。 现在可以通过在&lt;script&gt;标签上增加属性defer或者async，解决上述问题。这两个属性使得script标签不会阻塞DOM的渲染，能够异步加载script脚本，不阻塞DOM渲染。 defer如果script标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行） 使用方法： asyncasync的设置，会使得script脚本异步加载。async的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。 用图表来展示： 文档渲染 应该为 文档解析 普通的script文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载。 资源的下载是在解析过程中进行的，虽说script1脚本会很快的加载完毕，但是他前边的script2并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待script2执行完毕后再执行。当这两个脚本都执行完毕后，才会继续解析页面。 defer文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。 asyncasync脚本会在加载完毕后执行。async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的。 浏览器的回流与重绘回流：对于整个网页重新渲染一遍。 会导致回流的操作有： 页面首次渲染 浏览器窗口大小发生变化 元素尺寸或位置发生变化 元素内容发生变化（文字数量或图片大小等） 元素字体大小变化 添加或删除可见的DOM元素 激活css伪类（例如:hover） 重绘：浏览器只需要对某个元素进行重新绘制即可 会导致重绘的操作有： 修改color/background-color/visibility 由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流操作一定会伴随重绘，重绘却不一定伴随回流。 那么如何针对回流和重绘写出性能更好的代码呢？ CSS： 避免使用table布局 尽可能在DOM树的最末端改变class 避免设置多层内联样式 将动画效果应用到position属性为absolute或fixed的元素上 避免使用css表达式（例如：calc()） JavaScript 避免频繁操作样式 避免频繁操作DOM。创建一个documentFragment，在它上面应用所有的DOM操作，最后再把它添加到文档中 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 DOM CSS JS之间的关系 CSS是不会阻塞DOM的解析的，JS是会阻塞DOM的解析的 CSS是会阻塞DOM的渲染的。如果没有这个策略的话，页面首先会呈现一个原始的模样，待CSS下载完后又变成另一个模样，这样会导致用户体验变差而且渲染是有成本的。 JS是会等待CSS加载完才会执行的（如果CSS文件在JS文件之前声明的话，那JS需要等待CSS文件加载完毕后才会执行）。 原因：因为JS有时需要查询（获取）元素的一些样式，这些样式是定义在CSS文件里的，所以CSS加载完之后再去执行JS会更好一些。 所以&lt;script&gt;最好放在底部，&lt;link&gt;最好放在头部，是因为JS会阻塞DOM树的解析，CSS不会阻塞DOM树的解析。 如果头部同时有&lt;script&gt;和&lt;link&gt;的情况下，最好将&lt;script&gt;放在&lt;link&gt;上面，是因为JS会等待CSS加载完毕后才会执行，但是放在头部的JS一般不会对样式进行查询修改，所以放在前面没有太大影响（比如说引入VUE的CDN的js代码就会在头部，但是和CSS样式是无关的） 参考： https://www.cnblogs.com/jiasm/p/7683930.html https://www.jianshu.com/p/e6252dc9be32","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"什么是哈希hash","slug":"什么是哈希hash","date":"2020-01-29T10:55:11.000Z","updated":"2020-01-30T09:36:28.293Z","comments":true,"path":"2020/01/29/什么是哈希hash/","link":"","permalink":"http://delaprada.com/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/","excerpt":"","text":"哈希Hash什么是Hash通过一些计算，把关键码值映射到数组中的位置来访问记录，这个过程称为散列（hash）。 重要组成： hash函数：把关键码值映射到位置的函数称为散列函数。用h表示。 hash表：存放记录的数组称为散列表。用HT表示。 槽（slot）：散列表中的一个位置称为一个槽。 设计hash表的目标是：使得对于任何关键码值K和某个散列函数h，i=h(K)是表中满足0&lt;=h(K)&lt;M（M为HT中槽的数目）的一个槽，并且记录在HT[i]存储的关键码值与K相等。 冲突解决在实际情况中，我们根据散列方法组织的数据库必须把存储的记录存放在不大的散列表中，以避免浪费过多的空间。这样的话，有可能有多个关键码值计算出来的h(K)是一样的，但又不能同时放在同一个槽中，此时就要使用冲突解决策略。 冲突解决策略冲突解决策略一般分为两类： 开散列方法（open hashing；也称为单链方法） 闭散列方法（closed hashing；也称为开地址方法） 开散列方法开散列方法的最简单形式把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放在这个槽的链表内。 闭散列方法闭散列方法把所有记录直接存储到散列表中。每条关键码值标记为kR，记录R有一个基槽，就是h(kR)，即由散列函数计算出来的槽。如果要插入一条记录R，而另一条记录已经占据了R的基槽，那么就把R存储在表的其他槽内。 桶式散列 一种实现闭散列的方法是把散列表中的槽分成多个桶(bucket)。把散列表中的M个槽分成B个桶，每个桶中包含M/B个槽。 散列函数把每一条记录分配到某个桶的第一个槽中。 如果这个槽已经被占用，那么就顺序地沿着桶查找，直到找到一个空槽。 如果一个桶全部被占满了，那么就把这条记录存储在表后具有无限容量的溢出桶（overflow bucket）中。 线性探查最常用的散列方法。当发生冲突时，从当前基槽开始往后查找，有空位则将记录放进去。例如，2037原本应放在7的槽中，但是7已经被占用，所以往后查找空位，8是空的，于是将2037放进去。 但是这种方法会导致基本聚集。例如在上例中，下一条记录放到第2个槽的概率就是6/10了，因为取模后值为7,8,9,0,1,2都会放到第2个槽中。在理想情况下，表中的每个空槽都应该有相同的机会接受到下一个要插入的记录。 改进的冲突解决方法如何避免基本聚集呢？ 一种可能的改进方式是仍然使用线性探查，但是跳过一些槽，而且每次跳过常数c个而不是1个槽。这会生成探查函数：P(K,i)=ci。 例如，如果常数c是2的话：如果基槽被占用的话，第一次会找基槽+2的位置，看是否被占用，如果被占用了，第二次会找基槽+4的位置，如果还是被占用，则找基槽+6的位置，以此类推。即从基槽开始的偏移量将会为2,4,6。 另一种方法是使用二次探查函数（对于某些常数c1,c2,c3）：p(K,i)=c1i&lt;sup&gt;2&lt;/sup&gt;+c2i+c3。一个最简单的变体就是p(K,i)=i&lt;sup&gt;2&lt;/sup&gt;。 例如，对于一个长度M=101的散列表，假定对于关键码k1和k2，h(k1)=30，h(k2)=29。k1的探查序列为30,31,34,39；k2的探查序列为29,30,33,38。这样，尽管k2会在第二步探查k1的基槽，这两个关键码的探查序列此后就立即分开了。 双散列方法即由两个散列函数，一个散列函数用于计算基槽，另一个散列函数用于确定线性探查中的常数。即线性探查此时的形式为：p(K,i)=i*h2(K)。 例如，假定散列表的长度是M=101，有3个关键码k1，k2，k3，h(k1)=30，h(k2)=28，h(k3)=30，h2(k1)=2，h2(k2)=5，h2(k3)=5。那么k1的探查序列为：30,32,34,36等；k2的探查序列为：28,33,38,43等；k3的探查序列为：30,35,40,45等。这样关键码之间就不会共享同一段探查序列了。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"事件绑定 事件监听 事件委托","slug":"事件绑定-事件监听-事件委托","date":"2020-01-18T08:58:07.000Z","updated":"2020-02-05T12:49:30.054Z","comments":true,"path":"2020/01/18/事件绑定-事件监听-事件委托/","link":"","permalink":"http://delaprada.com/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件绑定为了让JavaScript对用户的操作作出响应，首先要对DOM元素绑定事件处理函数。 三种常用的绑定事件的方法： 在DOM元素中直接绑定 在JavaScript代码中绑定 绑定事件监听函数 在DOM元素中直接绑定我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。 123456&lt;input type=\"button\" value=\"click me\" onclick=\"hello()\"&gt;&lt;script&gt;function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 在JavaScript代码中绑定事件在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 123456&lt;input type=\"button\" value=\"click me\" id=\"btn\"&gt;&lt;script&gt;document.getElementById(\"btn\").onclick = function()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 使用事件监听绑定事件绑定事件的另一种方法是用 addEventListener() 或 attachEvent()来绑定事件监听函数。 事件监听的优点： 可以绑定多个事件 常规的事件绑定（例如onclick）只执行最后绑定的事件，会产生事件覆盖。 12345678910&lt;input type=\"button\" value=\"click me\" id=\"btn3\"&gt;&lt;script&gt;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function()&#123; alert(\"hello 1\"); //不执行&#125;btn3.onclick = function()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 使用addEventListener的话两个事件都会执行： 123456789101112&lt;input type=\"button\" value=\"click me\" id=\"btn4\"&gt;&lt;script&gt;var btn4 = document.getElementById(\"btn4\");btn4.addEventListener(\"click\",hello1);btn4.addEventListener(\"click\",hello2);function hello1()&#123; alert(\"hello 1\"); //执行&#125;function hello2()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 关于事件监听，有3个事件阶段（事件流包括三个状态）：捕获阶段，目标阶段，冒泡阶段。这三个阶段也叫作事件流。 事件捕获当一个事件触发后，从window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点，都会触发对应事件。 事件冒泡当事件到达目标节点后，会沿着捕获阶段路线原路返回。同样，所有经过的节点，都会触发对应的事件。 通过栗子来理解两个事件机制： 假设有body和body节点下的div1均有绑定了一个点击事件。 效果： 当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件 当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件（默认是false，在事件冒泡阶段执行） useCapture：用于指定事件是否在捕获或冒泡阶段执行 12345678910111213141516171819//当useCapture为默认false时,为事件冒泡&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印div1 打印body 1234567891011121314151617//当useCapture为true时,为事件捕获&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;,true) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印body 打印div1 事件委托利用冒泡原理，把事件加到父元素或祖先元素上，触发执行效果。 12345678910111213141516171819202122&lt;script&gt; window.onload = function()&#123; let div = document.getElementById('div'); div.addEventListener('click',function(e)&#123; console.log(e.target) &#125;) let div3 = document.createElement('div'); div3.setAttribute('class','div3') div3.innerHTML = 'div3'; div.appendChild(div3) &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=\"div\"&gt; &lt;div class=\"div1\"&gt;div1&lt;/div&gt; &lt;div class=\"div2\"&gt;div2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 虽然没有给div1和div2添加点击事件，但是无论是点击div1还是div2都会打印当前节点（console.log(e.target)）。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。 举个栗子： 分别点击div1、div2、div3： 无论后代新增了多少个节点，一样具有点击事件的功能。但是如果是传统的事件绑定的话无法对动态添加的元素而动态地添加事件。 事件委托的优点 提高性能：每一个函数都会占用内存空间。只需要添加一个事件处理程序代理所有事件，所占用的内存空间更少。 动态监听：使用事件委托可以自动绑定动态添加的元素。即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。 参考：https://www.cnblogs.com/soyxiaobi/p/9498357.html ​ http://blog.xieliqun.com/2016/08/12/event-delegate/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"分析parseInt()","slug":"分析parseInt","date":"2020-01-18T03:56:24.000Z","updated":"2020-01-18T07:05:51.564Z","comments":true,"path":"2020/01/18/分析parseInt/","link":"","permalink":"http://delaprada.com/2020/01/18/%E5%88%86%E6%9E%90parseInt/","excerpt":"","text":"parseInt()公式1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 parseInt(071)和parseInt(&quot;071&quot;)的区别parseInt(&quot;071&quot;)就是简单将字符串转换为数字： 如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。 以0开头也是转换为十进制。也有说转换为十六进制或者八进制，但是在chrome中实践是十进制。 parseInt(071)就是将071用八进制进行转换： 判断[‘1’,’2’,’3’].map(parseInt)的输出你可能觉得会是[1,2,3]，但实际上是[1,NaN,NaN]。我们来仔细分析一下： map的函数格式 1map((item, index, thisArr) &#x3D;&gt; ( newArr )) 参数解析： item: callback 的第一个参数，数组中正在处理的当前元素 index: callback 的第二个参数，数组中正在处理的当前元素的索引 thisArr: callback 的第三个参数，map 方法被调用的数组 parseInt的格式 上面讲到： 1parseInt(string, radix) 通过上述对 map 和 parseInt 函数的分析可以知道，执行方法时，map给parseInt传递了三个参数: 1parseInt(item, index, thisArr) 因此，索引index会传入parseInt函数当做基数radix。 其中第三个参数会被 parseInt 忽略，因此会依次执行： 123456parseInt('1', 0)// radix 为 0，默认以十进制解析字符串，返回 1parseInt('2', 1)// radix 为 1，不在 2 ~ 36 之间，返回 NaNparseInt('3', 2)// radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN 参考：https://www.cnblogs.com/wx1993/p/8417817.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2020-01-17T02:31:56.000Z","updated":"2020-01-17T02:35:23.204Z","comments":true,"path":"2020/01/17/防抖与节流/","link":"","permalink":"http://delaprada.com/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖和节流如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖（debounce）和节流（throttle）的方式来减少调用频率，同时又不影响实际效果。 防抖含义：当持续触发事件时，一定时间段内没有在触发事件，事件处理函数才会执行一次；如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 代码实现： 123456789101112131415function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 防抖是通过闭包实现的，所以timeout是会被缓存的。如果在频繁触发事件之后的一段时间内，又再次触发了事件，那就会使用clearTimeout清除setTimout设置的timout，重新计时。 具体完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125; &#125; // 处理函数 function handle() &#123; console.log(Math.random()); &#125; // 滚动事件 window.addEventListener('scroll', debounce(handle, 1000)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;防抖演示1&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示2&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示3&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示4&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示5&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示6&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示7&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示8&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示9&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示10&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示11&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示12&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示13&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示14&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示15&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示16&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在网页运行的时候我们会看到，当在滚动页面操作停止后1s，控制台会有输出。这就是防抖。 节流当持续触发事件时，保证每隔一定时间段内只调用一次事件处理函数。 用定时器实现节流： 1234567891011121314151617var throttle=function(func,delay)&#123; var timer=null; return function()&#123; var context=this; var args=arguments; if(!timer)&#123; timer=setTimeout(function()&#123; func.apply(context,args); timer=null; &#125;,delay); &#125; &#125;&#125;function handle()&#123; console.log(Math.random());&#125;window.addEventListener('scroll',throttle(handle,1000)); 节流也是通过闭包实现的。所以会把timer缓存起来，但是由于每次执行setTimeout函数时都设置timer为null，所以每次调用都可以执行if语句当中的内容。同时，下一次滚动事件不会影响上一次的事件处理函数，所以不会重新计时。 将节流代码放入上个例子的具体实现中会发现，执行滚动页面操作后，都会以同一频率在控制台中输出值。 参考：https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"https SSL/TLS握手过程","slug":"https-SSL-TLS握手过程","date":"2020-01-16T13:00:04.000Z","updated":"2020-01-16T13:05:07.058Z","comments":true,"path":"2020/01/16/https-SSL-TLS握手过程/","link":"","permalink":"http://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/","excerpt":"","text":"SSL/TLS 握手过程详解http协议是明文传输，不确认通信方，不保证传输数据完整的协议。它带来了三大风险： （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。 （2） 篡改风险（tampering）：第三方可以修改通信内容。 （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 http协议是明文传输，在安全性方面比较差。https协议使用了SSL/TLS协议来进行加密。SSL/TLS握手是为了安全地协商出一份对称加密的秘钥。 SSL/TLS握手过程 Client Hello 握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。 Server Hello 第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。 注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Hello Done Server Hello Done通知客户端Server Hello过程结束。 Certificate Verify 客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。 https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的 Client Key Exchange 上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。 至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。 为什么要使用三个随机数？ 这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。 最重要理解前六步 Change Cipher Spec（Client） 这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。 Encrypted Handshake Message(Client) 这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。 Change Cipher Spec(Server) 这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server) 这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data 到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html ​ https://juejin.im/post/584b76d3a22b9d0058d5036f","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CSS 圣杯布局和双飞翼布局","slug":"CSS-圣杯布局和双飞翼布局","date":"2020-01-15T08:49:17.000Z","updated":"2020-01-15T12:46:08.385Z","comments":true,"path":"2020/01/15/CSS-圣杯布局和双飞翼布局/","link":"","permalink":"http://delaprada.com/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"CSS 圣杯布局和双飞翼布局两个常见的前端布局。圣杯布局和双飞翼布局作为经典的三栏式布局是面试中的常客。两种布局达到效果上基本相同，都是两边两栏宽度固定，中间栏宽度自适应。在HTML结构上中间栏在最前面保证了最先渲染中间提升性能（因为这两种布局都比较老，我认为在现代浏览器中这点儿性能优化效果并不是很大），并且兼容性良好。两种布局的实现方法前半部分相同，后半部分的实现各有利弊，下面会简单介绍两者的区别。 圣杯布局代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; background-color: skyblue; height:60px; line-height:60px; /*文字水平垂直居中*/ &#125; .container&#123; overflow:hidden; /*因为内部都是浮动元素，所以要设置overflow来撑起父元素*/ padding:0 100px; /*左右内边距为100px*/ &#125; .main&#123; width:100%; background-color: peachpuff; height:100px; line-height: 100px; float:left; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; float:left; margin-left:-100%; /*让left前移一行*/ position:relative; left:-100px; &#125; .right&#123; background-color: pink; width:100px; height:100px; line-height:100px; float:left; margin-left:-100px; /*right只需要前移right的宽度即可*/ position:relative; /*container设置了padding,所以要相对定位移动才能将left和right移动到对应的位置*/ right:-100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 设置父元素container为overflow:hidden，撑起父元素，子元素main、left、right均设为float:left，浮动起来。效果如下： 为了让main模块自适应，将其设为100% 为了让left和right模块跑上去，设置left模块的margin:-100%，可以理解为：负的话就是向上前进，正值的话就是直接的间隔；right模块就设置为margin:-100px，大小为right模块的宽度 为了使main模块往里收，设置.container{ padding: 0 100px}，即设置左右内边距。 利用相对定位移动left和right 双飞翼布局代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; height:60px; background-color: skyblue; line-height:60px; &#125; .container&#123; overflow:hidden; &#125; .main&#123; width:100%; height:100px; line-height:100px; float:left; background-color: peachpuff; &#125; .inner-main&#123; margin-left:100px; /*通过在main内部再设置一个div来进行左右模块的间隔布局*/ margin-right:100px; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; margin-left:-100%; float:left; &#125; .right&#123; background-color: yellow; width:100px; height:100px; line-height:100px; margin-left:-100px; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"inner-main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算。 圣杯布局和双飞翼布局的主要区别： 圣杯布局是设置container的padding属性以及left和right模块的position:relative，left:-100px或right:-100px 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算 参考：https://segmentfault.com/a/1190000004579886","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"JavaScript模块化编程","slug":"JavaScript模块化编程","date":"2020-01-14T15:10:50.000Z","updated":"2020-01-14T15:11:30.414Z","comments":true,"path":"2020/01/14/JavaScript模块化编程/","link":"","permalink":"http://delaprada.com/2020/01/14/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/","excerpt":"","text":"模块化编程目录： AMD CMD commom.js ES6 Module AMDAMD是依赖前置，提前执行。AMD一开始是CommonJS规范中的一个草案，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。 AMD的基本语法通过define来定义一个模块，使用require可以导入定义的模块。 用define定义无依赖的模块： 12345//a.js//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数define(function()&#123; return 1;&#125;) 用define定义有依赖的模块： 1234567define([\"alpha\"], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 用require进行模块加载： 123require(['math'], function(math) &#123; math.add(2, 3);&#125;); AMD的特点对于依赖的模块，AMD推崇依赖前置，提前执行。也就是定义模块和加载模块都要在一开始就把依赖写好。例如define函数当中的[&quot;alpha&quot;]，就是定义模块当中的依赖；require函数当中的[&quot;math&quot;]是加载模块当中的依赖。 CMDCMD是依赖就近，延迟执行。 1234567891011121314151617181920212223//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;); //CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); CMD是在用到了某个模块的时候再去require，类似按需加载。 CMD的特点对于依赖的模块，CMD推崇依赖就近，延迟执行。也就是说，只有到require时依赖模块才执行。 摘自：https://segmentfault.com/a/1190000004873947 CommonJS基本用法 通过module.exports或者exports来输出模块 通过require来导入模块 1234567891011121314151617181920//a.jsmodule.exports = function () &#123; console.log(\"hello world\")&#125;//b.jsvar a = require('./a');a();//\"hello world\"//或者//a2.jsexports.num = 1;exports.obj = &#123;xx: 2&#125;;//b2.jsvar a2 = require('./a2');console.log(a2);//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125; CommonJS的特点 所有代码都运行在模块作用域，不会污染全局作用域 模块都是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果。如果想要再次执行，可清楚缓存 require返回的值是被输出的值的拷贝，模块内部的变化不会影响这个值 ES6 Module基本用法： export或export default来输出模块 import来导入模块 （export default就是能够为导入的模块自定义名称，这样就不用知道模块在原本的js文件当中的名字，按名字导入了） 1234567891011//a.jsvar name = 'lin';var age = 13;var job = 'ninja';export &#123; name, age, job&#125;;//b.jsimport &#123; name, age, job&#125; from './a.js';console.log(name, age, job);// lin 13 ninja 12345678//a2.jsexport default function () &#123; console.log('default ');&#125;//b2.jsimport customName from './a2.js';customName(); // 'default' ES6 Module的特点（对比CommonJS） CommonJS模块是运行时加载，ES6 Module是编译时输出接口； CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口（对应名字单独加载，加载这个模块想=需要的）； CommonJS输出是值的拷贝，ES6 Module输出的是值的引用，被输出模块的内部的改变会影响引用的改变； CommonJS this指向当前模块，ES6 Module this指向undefined; 参考：https://juejin.im/post/5db95e3a6fb9a020704bcd8d","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"异步以及异步编程解决方案","slug":"Generator函数-async函数","date":"2020-01-14T12:43:59.000Z","updated":"2020-04-02T01:03:23.205Z","comments":true,"path":"2020/01/14/Generator函数-async函数/","link":"","permalink":"http://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/","excerpt":"","text":"什么是异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。 例如： 1234setTimeout(function()&#123; XXX;&#125;,1000)console.log(\"XXX\"); setTimeout就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。setTimeout是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行setTimeout任务的第二部分，执行XXX。 如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。 异步编程方案异步编程也有多种解决方案，其演变过程是：回调函数—》Promise—》Generator—》async/await，每个演变都解决了之前的一些痛点。 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。callback的意思就是“重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 也就是说在执行readFile的时候，执行权交给了主线程执行栈的同步任务，同步任务执行完毕后才会执行这个readFile的回调。 回调函数的缺点回调函数会导致回调地狱。 比如现在有多个异步任务，且任务有依赖关系（一个任务需要拿到另一个任务成功后的结果才能开始执行）的时候，回调的方式写出来的代码就会像这样： 1234567891011getData1(data1 =&gt; &#123; getData2(data1, data2 =&gt; &#123; getData3(data2, data3 =&gt; &#123; getData4(data3, data4 =&gt; &#123; getData5(data4, data5 =&gt; &#123; // 终于取到data5了 &#125;) &#125;) &#125;) &#125;)&#125;) 这种多层嵌套的结构就是回调地狱，这种情况下代码的可读性很差。 Promise因此就出现了Promise。Promise的关键点就是将回调函数的嵌套改为了链式调用。 我们使用new Promise去创建一个Promise实例，这个Promise实例会传入一个函数作为参数，函数又有两个函数作为参数，分别是：resolve、reject。 执行resolve函数，Promise实例的状态会变为fulfilled，后续就会去执行.then回调函数 执行reject函数，Promise实例的状态会变为rejected，后续就会去执行.catch回调函数，或者.then的第二个回调函数。 3种状态Promise实例有三种状态： pending（进行中） fulfilled（已成功） rejected（已失败） fulfilled和rejected有可以说是已成功和已失败，这两种状态又归为已完成状态 resolve和reject调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调。resolve和reject两种函数只会执行一种，执行了其中一个之后就不会执行另一个了。 基本结构123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; //做一些事情 //然后在某些条件下resolve，或者reject（以下代码） if(/* 条件随便写 */)&#123; resolve() &#125; else&#123; reject() &#125;&#125;)p.then(()=&gt;&#123; //如果p的状态被resolve了，就进入这里&#125;,()=&gt;&#123; //如果p的状态被reject&#125;) 简单来说，这种.then.then.then的编码方式，就是Promise。 它的异步体现在，new Promise部分是立即执行的，那执行完毕后，就会将执行权交给主线程执行栈的同步任务，同步任务执行完毕后才会去执行.then回调。这里涉及JavaScript事件执行机制Eventloop。 Promise实现多任务顺序执行1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) 需要注意的是：每个.then中要返回一个new Promise对象，把任务放在Promise中，后续才能继续使用.then去执行后续操作。 Promise实现多任务并行（即A、B任务都执行完毕了才能执行C任务）：123456789101112var p1=new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;)p1.then(result=&gt;result);var p2=new Promise((resolve,reject)=&gt;&#123; resolve('hi');&#125;)p1.then(result=&gt;result);var p=Promise.all([p1,p2]);p.then(result=&gt;console.log(result)); 这里主要用到Promise.all这种结构。Promise.all([p1,p2])接受一个数组作为参数，数组的元素都是Promise实例，只有当数组中所有Promise实例的状态都变为fulfilled的时候，这个Promise.all的实例才会变为fulfilled，才能执行后续的.then操作。 和Promise.all相关的还有Promise.race，那Promise.race实例的状态是等于其参数中第一个执行完毕的Promise实例的状态，它有可能是rejected，也有可能是fulfilled。 Promise的缺点Promise的最大问题是代码冗余：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 GeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案,Generator就能够解决上述Promise代码冗余的问题。它能够以一种类似同步的写法来执行一些异步操作。 形式上Generator函数是一个普通函数，有两个特征：1）function关键字与函数名之间有个星号； 2）函数内部使用yield表达式，定义不同的内部状态 执行Generator函数会返回一个遍历器对象 调用Generator函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象 必须调用遍历器对象的next方法，使得指针移向下一个状态，输出返回的结果 Generator函数的写法1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 异步应用因为yield能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序。 例如有两个异步的函数 A 和 B, 并且 B 的参数是 A 的返回值，也就是说，如果 A 没有执行结束，我们不能执行 B。 那这时候我们写一段伪代码： 12345function* effect() &#123; const &#123; param &#125; = yield A(); const &#123; result &#125; = yield B(param); console.table(result);&#125; 这时候我们如果需要得到 result 那么我们就需要: 123const iterator = effect()iterator.next()iterator.next() co库可以用来每次执行A()/b()的请求结束之后，都会自动执行next()方法。 使用Generator去实现Promise的任务顺序执行：我们再回顾一下Promise版本： 1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) Generator版本： 123456789101112131415161718192021function f1() &#123; setTimeout(function() &#123; g.next(\"one\"); //将参数传给data1 &#125;, 3000);&#125;function f2(data1) &#123; console.log(\"接收到了\" + data1); setTimeout(function()&#123; g.next(\"two\"); //将参数传给data2 &#125;,3000)&#125;function* mygenerator() &#123; var data1 = yield f1(); var data2=yield f2(data1); console.log(data2);&#125;var g = mygenerator();g.next(); 看起来就很像同步操作。 这里需要注意的是：执行yield f1()的时候是不会将返回的结果返回给data1的。next方法可以接受参数，这是向 Generator 函数体内输入数据。 第二个next的时候传入参数，就能被变量data1就能够接收到。 而且不能在f1中直接调用g.next()，要在异步函数内调用（这里还不是很懂为什么…）。 执行顺序如下： 再看个栗子理解： 12345678910111213function* G() &#123; const a = yield 100 console.log('a', a) // a aaa const b = yield 200 console.log('b', b) // b bbb const c = yield 300 console.log('c', c) // c ccc&#125;const g = G()g.next() // value: 100, done: falseg.next('aaa') // a aaa value: 200, done: false g.next('bbb') // b bbb value: 300, done: falseg.next('ccc') //c ccc value: undefined, done: true 捕获错误12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw('出错了');// 出错了 使用try...catch。 async和awaitasync函数就是Generator的语法糖。 形式上的不同： async函数将Generator函数的星号（*）替换成async 将yield替换成await async函数对Generator函数的改进体现在以下3点： 内置执行器 也就是说async函数的执行，和普通函数一样，只需要一行就可以。不用像Generator函数需要调用next方法才能真正执行。 例如对于一个async函数来说： 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 调用时只需要： 1asyncReadFile(); 更好的语义 async和await比起星号和yield，语义更加清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 返回值是Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 async函数基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 先执行了第一个await后的getStockSymbol(name)函数；得到了股票的名称symbol后，将symbol传给第二个await后面的getStockPrice(symbol)作为参数；最后返回股票价格stockPrice。 async/await错误处理try/catch 使用try将await语句包含起来，如果await后的语句执行错误，则错误会被catch捕获： 123456789run();async function run() &#123; try &#123; await Promise.reject(new Error(\"Oops!\")); &#125; catch (error) &#123; error.message; // \"Oops!\" &#125;&#125; 123456789101112run();async function run() &#123; const v = null; try &#123; await Promise.resolve(\"foo\"); v.thisWillThrow; &#125; catch (error) &#123; // \"TypeError: Cannot read property 'thisWillThrow' of null\" error.message; &#125;&#125; 参考：https://blog.fundebug.com/2019/07/24/async-await-error-handling-in-js/ ​ https://segmentfault.com/a/1190000012767617 执行顺序问题1234567891011121314async function async1()&#123; console.log('async1 start'); await async2(); console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start');async1();console.log('script end')// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end 当async函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了async函数体。 1234567891011121314151617181920async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 执行顺序为： 执行async1的时候遇到await先去执行async2，然后跳出了函数体，去执行后续的代码，然后再回到当前async1函数当中执行await后续语句。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"函数柯里化","slug":"函数柯里化","date":"2020-01-14T06:27:55.000Z","updated":"2020-02-18T07:59:41.485Z","comments":true,"path":"2020/01/14/函数柯里化/","link":"","permalink":"http://delaprada.com/2020/01/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"函数柯里化柯里化的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 看一个栗子： 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 我们定义了一个add函数，它接受一个参数并返回一个新的函数。调用了add之后，返回的函数就通过闭包的方式记住了add的第一个参数。 因为一次性地调用它有点繁琐，所以使用一个特殊的curry帮助函数使得这类函数的定义和调用更加容易。 一些柯里函数实例： 12345var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;); 12345match(/\\s+/g, \"hello world\");// [ ' ' ]match(/\\s+/g)(\"hello world\");// [ ' ' ] 以上两种方法都可以执行。第二种方法是比较常见的柯里化方法。先传递一部分参数（题目中为正则表达式）来调用函数，然后返回一个函数（题目中为str.match()来处理剩下的函数）。（题目中是匹配空格） 以上的形式可以更加具体化： 12345var hasSpaces = match(/\\s+/g);// function(x) &#123; return x.match(/\\s+/g) &#125;hasSpaces(\"hello world\");// [ ' ' ] 这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 再举一个非常常见的例子： 如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入： 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下： 12check(/^1[34578]\\d&#123;9&#125;$/, '14900000088');check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, 'test@163.com'); 这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用： 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\\d&#123;9&#125;$/);var checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了： 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 再看一个前端面试中常考的题目： 1如何实现add(2)(3)(4) &#x3D; 9 函数柯里化解决这个问题： 12345678910111213141516171819let myAdd = (a, b, c) =&gt; a+b+c;function curry(fn, args)&#123; let len = fn.length; let _this = this; let _args = args || []; return function()&#123; let args = Array.prototype.slice.apply(arguments); args = Array.prototype.concat.call(_args, args); // 当接收到的参数小于fn所需参数个数时，继续接收参数 if(args.length &lt; len)&#123; return curry.call(_this, fn, args); &#125; return fn.apply(this, args); &#125;&#125;let add = curry(myAdd);console.log(add(2)(3)(4)); // 9console.loh(add(2,3)(4)); // 9console.log(add(2,3,4)); // 9 但是这个例子不具有普遍性。如果传入的参数不是3个的话不能这么用。 所以有了下面的进化之后的代码： 1234567891011121314151617181920212223function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() &#123; _args.push(...arguments); return _adder; &#125;; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder;&#125;add(1)(2)(3).toString() // 6add(1, 2, 3)(4).toString() // 10add(1)(2)(3)(4)(5).toString() // 15add(2, 6)(1).toString() // 9 参考的博客说隐式转换的原因是因为函数进行计算的时候会变为字符串，但理解了代码之后觉得并不是这么回事。每次调用函数的时候执行的是这个语句体： 1234var _adder = function() &#123; _args.push(...arguments); return _adder;&#125;; 这个语句体实际上是用于将所有传入的实参放进数组args中。最后执行toString方法的时候是将数组args的每个元素通过reduce函数求和，返回求和的值。单纯执行_adder函数和执行toString()函数做的事情是不一样的。 看到一个面试题目： 实现一个sum函数使得sum(1, 2, 3).valueOf()和sum(1)(2)(3).valueOf()执行输出的结果都等于6 。 解法和上面一致，只需要把toString()改为valueOf()就可以了。 1234567891011121314151617var sum=function()&#123; var args=[].slice.call(arguments); var _adder=function()&#123; args.push(...arguments); return _adder; &#125; _adder.valueOf=function()&#123; return args.reduce(function(a,b)&#123; return a+b; &#125;); &#125; return _adder;&#125;console.log(sum(1,2,3).valueOf());console.log(sum(1)(2)(3).valueOf()); 为什么要进行隐式转化？ 因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果： 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果： 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 参考博客： https://www.jianshu.com/p/5e1899fe7d6b https://www.cnblogs.com/hmchen/p/11564394.html https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript this解析","slug":"JavaScript-this全面解析","date":"2020-01-13T03:12:48.000Z","updated":"2020-03-07T12:09:22.112Z","comments":true,"path":"2020/01/13/JavaScript-this全面解析/","link":"","permalink":"http://delaprada.com/2020/01/13/JavaScript-this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","excerpt":"","text":"为什么要使用thisthis提供了一种更优雅的方式来隐式“传递”一个对象引用。 看下面的例子： 没有使用this的情况下： 1234567891011121314151617var me=&#123; name:\"Kyle\"&#125;var you=&#123; name:\"Reader\"&#125;function identify(context)&#123; return context.name.toUpperCase();&#125;function speak(context)&#123; var greeting=\"Hello, I'm \"+identify(context); console.log(greeting);&#125;identify(you); //READERspeak(me); //hello, I'm KYLE 使用了this的情况： 123456789101112function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greeting=\"Hello, I'm \"+identify.call(this); console.log(greeting);&#125;identify.call(me); //KYLEidentify.call(you); //READERspeak.call(me); //Hello, I'm KYLEspeak.call(you); //Hello, I'm READER 表达上更加的简洁。如果不使用this的话，就需要给identify()和speak()显式传入一个上下文对象。 this绑定对象的规则我们可以顺序应用下面四条规则来判断this的绑定对象： 如果是由new调用，绑定到新创建的对象。 如果是由call或者apply、bind调用，绑定到指定的对象上。 如果是由上下文对象调用（即this是对象中的方法里使用的），绑定到那个上下文对象上。 如果是默认情况下，严格模式绑定到undefined，否则绑定到全局对象上。 但是ES6中的箭头函数并不会使用者四条标准的绑定规则。箭头函数会继承外层函数调用的this绑定。 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar=new foo(2);console.log(bar.a); //2 我们使用new来调用foo(…)时，会构造一个新对象并把它绑定到foo(…)调用中的this上。 显式绑定call、apply、bind1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2;&#125;;foo.call(obj); //2 call用来将函数foo中的this绑定到obj上。 隐式绑定（上下文对象调用）如果this所在的函数是对象中的方法的话，this就会指向这个对象。 12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;obj.foo(); //2 foo此时是obj对象的一个方法，所以this就会指向obj。 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用： 123456789101112function foo()&#123; console.log(this.a);&#125;var obj2=&#123; a:42, foo:foo&#125;;var obj1=&#123; a:2, obj2:obj2&#125;;obj1.obj2.foo(); //42 隐式丢失也是this隐式绑定中常见的问题： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;var bar=obj.foo; //函数别名！var a=\"oops, global\"; //a是全局对象的属性bar(); //“oops, global” 此时bar是obj.foo的一个引用，但实际上它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 回调函数丢失this绑定是也是非常常见的问题： 123456789101112function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn(); //调用位置&#125;var obj=&#123; a:2, foo:foo&#125;;var a=\"oops global\"; //全局对象属性doFoo(obj.foo); //\"oops global\" 函数doFoo传入了函数作为参数，并在doFoo中调用。我们可以把它看做将函数copy到了doFoo函数体中，调用的时候this指向的是全局作用域。 隐式丢失一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。 例一： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;var bar=obj.foo; //函数别名！把函数体赋值了var a=\"oops,global\"; //a是全局对象的属性bar(); \"oops, global\" bar实际上它引用的是foo函数本身。 例二： 123456789101112131415function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;var obj=&#123; a:2, foo:foo&#125;var a=\"oops, global\"; //a是全局对象的属性doFoo(obj.foo); //\"oops, global\" 参数传递实际上是一种隐式赋值，因此我们传入函数时也会被隐式赋值。 例三： 123456789function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo: foo&#125;var a=\"oops, global\";setTimeout(obj.foo,100); //\"oops, global\" 回调函数丢失this绑定是非常常见的！ 栗子： 123456789var obj = &#123; id: \"a\", cool: function coolFn() &#123; console.log( this.id ); &#125;&#125;;var id = \"b\"obj.cool(); // asetTimeout( obj.cool, 100 ); // b 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); //2 在这个例子中，函数调用应用了this的默认绑定，this指向全局对象。 如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，this会绑定到undefined。 123456function foo()&#123; \"use strict\"; console.log(this.a);&#125;var a=2;foo(); //TypeError: this is undefined 箭头函数中的this箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。 12345678910111213function foo()&#123; return (a)=&gt;&#123; console.log(this.a); &#125;&#125;var obj1=&#123; a:2&#125;;var obj2=&#123; a:3&#125;;var bar=foo.call(obj1);bar.call(obj2); //2,不是3！ foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，所以bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。 再看一个例子： 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 foo调用时传入的是什么对象，this就指向谁。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21（严格模式则输出undefined）。 如果foo函数内部是普通函数的话： 由此可以看出，foo函数的this是指向call传入的对象{id:42}，但是foo函数内部的setTimeout函数中的this是指向全局的。 参考书籍：《你不知道的JavaScript》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript基本知识","slug":"JavaScript基本知识","date":"2019-12-30T02:14:24.000Z","updated":"2019-12-30T02:30:31.762Z","comments":true,"path":"2019/12/30/JavaScript基本知识/","link":"","permalink":"http://delaprada.com/2019/12/30/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScriptES6和JavaScript的关系ES6的全称为ECMAScript 6.0，是JavaScript语言下一代的标准，是使得JavaScript可以用来编写复杂的大型应用程序，称为企业级开发语言。ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript前言JavaScript是世界上最流行的脚本语言，是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 JavaScript引入 用直接包含js代码 把js代码放到一个单独的.js文件，在html中通过引入这个文件，这么做更有利于代码维护 JavaScript基本语法 JavaScript的语法和Java类似，每个语句以；结束 JavaScript严格区分大小写 JavaScript的数据类型基本数据类型：Number, String, Boolean, null, undefined, Symbol（ES6中新添加的类型，一种实例是唯一且不可改变的数据类型） NumberJavaScript不区分整数和浮点数，统一用Number表示。可以表示 整数 浮点数 科学计数法 负数 NaN（表示Not a Number，当无法计算结果时用NaN表示） Infinity（表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity） String字符串是以单引号或双引号括起来的文本。 模板字符串要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!';alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串获取字符串长度： 12var s = 'Hello, world!';s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' 字符串常用方法：注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： toUpperCase： toUpperCase()把一个字符串全部变为大写： 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' toLowerCase： toLowerCase()把一个字符串全部变为小写： 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' substring: substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' Booleantrue或者false 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值，要特别注意比较运算符==和===： ==比较：它会自动转换数据类型再比较，很多时候会得到很奇怪的结果 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN===NaN //false 唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN) //true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true null和undefined null表示一个“空”的值、表示“无”的对象，转为数值是为0；undefined是一个表示“无”的原始值，转为数值是NaN，当声明的变量还未被初始化时，变量的默认值为undefined。 Null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 Undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义，典型用法是： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值属性，该属性的值为undefined 函数没有返回值时，默认返回undefined null表示”没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象 作为对象原型链的终点 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： 1[1, 2, 3.14, &#39;Hello&#39;, null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过Array()函数实现： 1new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即truearr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined 要取得Array的长度，直接访问length属性： 12var arr = [1, 2, 3.14, 'Hello', null, true];arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： 123var arr = ['A', 'B', 'C'];arr[1] = 99;arr; // arr现在变为['A', 99, 'C'] (注意此处与String的不同，String是不可变的) 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串&#39;30&#39;是不同的元素。 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 对象JavaScript的对象是一组由键-值组成的无序集合，用一个{...}表示一个对象，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为&#39;Bob&#39;，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用&#39;&#39;括起来： 1234var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School'&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用&#39;&#39;括起来。访问这个属性也无法使用.操作符，必须用[&#39;xxx&#39;]来访问： 123xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红' 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： 1234567891011var xiaoming = &#123; name: '小明'&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符： 12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： 1'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefinedvar $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值truevar t &#x3D; null; &#x2F;&#x2F; t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如： 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言（例如int） 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 循环for…infor循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 12345678910var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // 'name', 'age', 'city' &#125;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for ... in对Array的循环得到的是String而不是Number。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for...in和for...of的区别： for in 循环的是对象的属性（普通数组的属性就是index） for of 循环的是迭代器中的每一个元素 用for ... of循环遍历集合，用法如下： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 你可能会有疑问，for ... of循环和for ... in循环有何区别？ 当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125; for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 12345678'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身： 1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： 1234var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; console.log(element);&#125;); 参考基本数据类型和引用数据类型的区别：https://www.cnblogs.com/c2016c/articles/9328725.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"hexo常用指令及美化博客页面","slug":"hexo常用指令及美化博客页面","date":"2019-12-26T09:54:44.000Z","updated":"2020-01-15T12:46:56.095Z","comments":true,"path":"2019/12/26/hexo常用指令及美化博客页面/","link":"","permalink":"http://delaprada.com/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"hexo常用命令Hexo的命令总体来说比较简单，安装成功之后只需要记住常用的四种即可。在当前blog文件夹根目录下右键点击git bash： hexo s：server启动服务器 hexo clean：clean清除缓存文件（db.json）和已生成的静态文件（public） hexo generate或hexo g：generate生成静态文件 hexo deploy或hexo d：deploy部署网站，部署网站前需预先生成静态文件 一般更改完后执行三条指令：hexo clean，hexo generate，hexo deploy即可（按顺序） 如果要进行文件压缩，在hexo generate指令后，执行gulp指令。 参考https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/ hexo各种美化新建page1hexo new &quot;文章名称&quot; 会在source文件夹下_post中新建文件夹和.md文件 侧栏增加标签和分类页面创建标签页面 创建标签页面 1hexo new page tags 基本设置 123title: tagsdate: 2017-12-02 21:01:24type: &quot;tags&quot; 创建分类页面 创建分类页面 1hexo new page categories 基本设置 123title: categoriesdate: 2017-12-02 21:01:24type: &quot;categories&quot; 文章中插入图片 将图片放置在页面对应的文件夹中 在文章中引入： 1&#123;% asset_img 图片名称 %&#125; 设置站点图标 先在images文件夹下放入你的图标 在主题配置页面_config.yml中搜索favicon，找到以下位置，并将路径修改为你的图标： 部署之后就可以看到效果了，查看效果：http://delaprada.com 设置头像 在images文件夹中放入你的头像图片 在主题配置页面中修改avatar为你的图片地址： 首页文章不显示全文只显示摘要修改/themes/next/_config.yml主题配置文件中： 1234567scroll_to_more: true #如果文章有摘要,会自动滚动到摘要下面save_scroll: true #通过cookies来缓存阅读进度excerpt_description: true #自动摘录描述作为序言auto_excerpt: #设置阅读全文 enable: true length: 150 #摘要次数read_more_btn: true #阅读全文按钮 修改文章底部的带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;（如果想换成其他图标可到font-awesome中文网查看） 在每篇文章末尾统一添加“本文结束”标记在\\themes\\next\\layout\\_macro中新建passage-end-tag.swig，并加入以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=\"text-align:center;color: #ccc;font-size:15px;\"&gt;-------本&amp;nbsp;文&amp;nbsp; 结&amp;nbsp;束&amp;nbsp;&amp;nbsp;&lt;i class=\"fa fa-heart\" aria-hidden=\"true\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;感 &amp;nbsp;谢&amp;nbsp;您&amp;nbsp;的&amp;nbsp;阅&amp;nbsp;读-------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body标签之后，post-footer标签之前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &#39;passage-end-tag.swig&#39; %&#125; &#123;% endif %&#125;&lt;&#x2F;div&gt; 修改网页背景颜色和侧栏上方brand的颜色打开themes/next/layout/source/css/_custom/custom.styl，加入以下代码： 12345678910111213141516171819202122&#x2F;&#x2F;修改网页背景颜色body &#123; background-color: #F0F8FF&#125;#footer a &#123; color:#eee;&#125;&#x2F;&#x2F; 修改网站头部颜色.headband &#123; height: 3px; background: #ADD8E6;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #ADD8E6;&#125;.site-title &#123; color: #fff;&#125; 侧边栏社交设置和友情链接修改主题配置页面：themes/next/_config.yml： 12345678910111213141516171819202122232425262728293031site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: CSDN: https://blog.csdn.net/weixin_41973410 || copyright GitHub: https://github.com/delaprada || githubsocial_icons: #这里是上面社交链接的对应图标 enable: true CSDN: copyright Github: github icons_only: false transition: true# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.#github_banner: https://github.com/Fitz1318 || Follow me on GitHub# Blog rolls #这里时设置一些相关链接 我这里设置了一些推荐阅读的网站#links_icon: linklinks_title: 实用网站#links_layout: blocklinks_layout: inlinelinks: W3Cschool: http://www.w3school.com.cn/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"hexo categories和tags页面不显示解决办法","slug":"hexo-categories和tags页面不显示解决办法","date":"2019-12-25T02:53:13.000Z","updated":"2019-12-26T09:55:44.357Z","comments":true,"path":"2019/12/25/hexo-categories和tags页面不显示解决办法/","link":"","permalink":"http://delaprada.com/2019/12/25/hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"官网也有给出具体步骤，但是有坑Hexo官网教程 第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ：12cd hexo //根目录hexo new page categories //tags和这个操作一致 第二步 找到新建的页面，添加type新建的页面一般在source/categories/index.md中，添加以下内容： 1234title: categoriesdate: 2019-12-25 09:15:45type: \"categories\"layout: \"categories\" 第三步 给你的页面添加分类找到你的页面，在页面上方添加如下内容 123456title: 利用gitpages+hexo搭建自己的博客date: 2019-12-25 09:12:55categories:- Hexotags:- 前端 但此时部署到github上后，打开网页点击分类和标签页面还是出现404！ 第四步 解决方案实属官方坑人系列！！主题配置文件_config.yml中的menu：把 / 后面的空格全部去掉（刚开始的时候默认后面是加了空格导致点击页面出现404）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"利用gitpages+hexo搭建自己的博客","slug":"利用gitpages+hexo搭建自己的博客","date":"2019-12-25T01:12:55.000Z","updated":"2020-01-15T12:50:57.057Z","comments":true,"path":"2019/12/25/利用gitpages+hexo搭建自己的博客/","link":"","permalink":"http://delaprada.com/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言从开始开始着手搭建到完成大概花了一个下午的时间，采坑不少，在此记录一下 第一步 准备工作node.js下载好，github有已注册的账号在github中新建一个repository，命名为：你的github名称.github.io（下面是我的仓库名称）： （有些博客直接让我们fork它们的项目，个人感觉这么做不太好，很多东西自己动手做一遍更好） 第二步 安装HexoHexo就是一个博客框架，官网上也有安装教程Hexo官网 step1：windows系统鼠标右键git bash，输入两个安装指令： 12npm install hexo-cli -g &#x2F;&#x2F;用于安装hexonpm install hexo-deployer-git --save &#x2F;&#x2F;用于安装hexo部署到git page的deployer step2：创建hexo文件夹hexo安装完成之后，在电脑中新建一个hexo文件夹： 右键点击git bash，输入两个命令： 12hexo initnpm install &#x2F;&#x2F;安装所有package.json里的包 执行完成后，hexo文件夹中会多出一些文件： 如果想看本地效果的话，执行以下指令： 12hexo generate &#x2F;&#x2F;自动将md文件生成静态html，css文件hexo server &#x2F;&#x2F;启动本地hexo服务器（localhost:4000） 打开 localhost:4000就可以看到页面啦： （页面会不太一样，我的配了一下主题） 第三步 了解hexo文件夹中的_config.ymlhexo文件夹中比较重要的文件是：_config.yml： 它是一个全局配置文件，包括和github上传链接都在这里配置，例如title之类的： 第四步 本地上传到githubstep1：执行命令，安装deploy.git插件 1npm install hexo-deployer-git --save step2：在主题配置文件_config.yml中修改仓库地址，在_config.yml最下面一行（注意每个冒号后面都有一个空格） step3：配置提交github认证方式执行指令： 1hexo d 直接提交到github仓库中，如果没有认证github和本地的关系，会提示输入用户名和密码 此时打开github的项目会发现原本是空的项目现在有了刚刚上传的文件 第五步 添加域名在阿里云中购买了一个.com的域名（加优惠一年23块，虽然比其他贵一些但是觉得.com好听一些(#^ . ^#)） step1：cmd ping一下github.io获得真实ip地址 step2：然后再域名操作栏点击解析，添加记录 注意要两个都要添加（之前一开始只添加了www不知道为啥就显示不出来） step3：去hexo文件夹的source目录下新建名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www step4：然后部署 1231. hexo clean2. hexo generate3. hexo deploy （每次做出更改建议都部署一遍） step5：点击设置，拉到下面，在custom domain中输入你的域名。如果上面的信息不是显示Your site is published at https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证 输入域名，成功：","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]}]}