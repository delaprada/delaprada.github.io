{"meta":{"title":"Alice's  wonderland","subtitle":"","description":"Goals determine what you going to be!","author":"Alice","url":"http://delaprada.com","root":"/"},"pages":[{"title":"categories","date":"2019-12-25T01:15:45.000Z","updated":"2019-12-26T12:39:38.305Z","comments":false,"path":"categories/index.html","permalink":"http://delaprada.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-25T01:50:31.000Z","updated":"2019-12-26T12:39:54.263Z","comments":false,"path":"tags/index.html","permalink":"http://delaprada.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React hooks: useRef, useImperativeHandle","slug":"React-hooks-useRef-useImperativeHandle","date":"2020-12-14T03:07:00.000Z","updated":"2020-12-14T03:28:11.198Z","comments":true,"path":"2020/12/14/React-hooks-useRef-useImperativeHandle/","link":"","permalink":"http://delaprada.com/2020/12/14/React-hooks-useRef-useImperativeHandle/","excerpt":"","text":"useRefuseRef最为传统的用法就是存储一个DOM节点的引用。当这个DOM节点更新时，这个引用也会更新。我们可以通过current属性来访问DOM节点。 123const domRef = useRef()useEffect(() =&gt; &#123; doSomething(domRef.current) // access the DOM node here&#125;, [])return &lt;div ref=&#123;domRef&#125;&gt;&lt;Components /&gt;&lt;/div&gt; 还有一种常用的用法是在父子组件中使用，通过结合useRef和forwardRef方法，父组件能够访问子组件内部的DOM节点。 Refs允许某些组件接收ref，并向下传递给子组件。比如在下面这个实例中，FancyButton使用React.forwardRef来传递给它的ref，然后转发到它渲染的DOM button，此时在父组件中就可以使用ref.current来访问button的DOM节点： 123456789const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;));// 你可以直接获取 DOM button 的 ref：const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;; 上述代码的逐步解释： 通过调用React.createRef创建了一个React ref并将其赋值给ref变量 通过制定ref为JSX属性，将其向下传递给&lt;FancyButton ref={ref}&gt; React传递ref给forwardRef内函数(props, ref) =&gt; ...，作为其第二个参数 向下转发该ref参数到&lt;button ref={ref}&gt;，将其指定为JSX属性 当ref挂载完毕，ref.current将指向&lt;button&gt;DOM节点 注意： 第二个参数ref只在使用React.forwardRef定义组件时存在。常规函数和class组件不接收ref参数，且props中也不存在ref。所以用forwardRef定义组件是一个比较特殊的用法。 如果想要在高阶组件中使用ref，需要多一步透传，见官网例子 useImperativeHandleuseImperativeHandle方法可以让我们通过ref将一些变量和函数从子组件传递给父组件。父组件可以选择使用它或者将这个ref又传递给另一个子组件。 我们都知道，React是单向数据流的，数据是从父组件通过props传递到子组件的，所以useImperativeHandle和forwardRef相结合实现信息从子组件传递给父组件，这是一个比较新颖的用法。 12345678910111213141516171819202122232425262728293031import &#123; useState, useRef, forwardRef, useImperativeHandle &#125; from \"react\";const ChildOne = forwardRef((props, ref) =&gt; &#123; const [ count, setCount ] = useState(0); useImperativeHandle(ref, () =&gt; (&#123; count, &#125;)); const updateCount = () =&gt; &#123; setCount((c) =&gt; c + 1); console.log(count + 1); &#125;; return &lt;button onClick=&#123;updateCount&#125;&gt;Increment&lt;/button&gt;;&#125;);const ChildTwo = forwardRef((props, ref) =&gt; &#123; const checkCount = () =&gt; console.log(\"-&gt;\", ref.current.count); return &lt;button onClick=&#123;checkCount&#125;&gt;Count&lt;/button&gt;;&#125;);const Parent = () =&gt; &#123; const ref = useRef(); return ( &lt;div&gt; &lt;ChildOne ref=&#123;ref&#125; /&gt; &lt;ChildTwo ref=&#123;ref&#125; /&gt; &lt;/div&gt; )&#125; 在上面的代码中，我们在Parent中初始化ref，然后传递给两个子组件。 子组件1有自己的state，使用useState hook来控制，同时它有一个updateCount方法来增加count数量。 然后子组件1通过useImperativeHandle这个hook让父组件能够访问count，useImperativeHandle方法接受ref作为参数，然后返回一个包含count变量的对象。 现在父组件能够访问count，并传递给子组件2。当点击子组件2时，输出ref.current.count。 这是一个信息流从子组件传递到父组件，再从父组件传递给子组件的例子。与此同时，我们可以注意到，因为我们使用了useRef，所以父组件是没有发生任何的重新渲染（re-render）。 对useRef和useImperative简单实践的代码地址：https://github.com/delaprada/Refs-practice 参考： https://react.docschina.org/docs/forwarding-refs.html https://medium.com/@binyamin/react-hooks-useref-useimperativehandle-uselayouteffect-ede6f40f393e","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"http知识汇总","slug":"http知识汇总","date":"2020-12-07T11:45:35.000Z","updated":"2020-12-08T02:26:52.016Z","comments":true,"path":"2020/12/07/http知识汇总/","link":"","permalink":"http://delaprada.com/2020/12/07/http%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"http协议 http协议是Web的应用层协议，定义了Web客户端向服务器请求页面的方式；以及服务器向客户端传送Web页面的方式。 它使用tcp作为它的运输层协议。 无状态协议，因为http服务器不保存关于客户的任何信息。 不安全，不会对传输的数据进行加密。 Q：http协议为无状态协议，如何记住用户的状态？ A：无状态协议的好处是快速，但是有时我想要记住用户的状态（比如：登录状态）。此时我们可以使用cookie或者session记录用户的浏览状态信息，用户身份信息。 http请求/响应报文请求报文 由4个部分组成：请求行、请求头、空行、请求体 请求行由3个字段组成：请求方法、URL字段、HTTP协议版本字段 请求方法有：GET、HEAD、POST、PUT、DELETE 空行：告诉服务器请求头部到此为止 请求体：如果请求方法是GET，则为空；如果请求方法是POST，此处放置要提交的数据 上面是POST方法，它的请求行URL段中一般是没有参数的，参数放在了报文体中。而GET方法的参数直接置于请求行URL中，报文体则为空。 响应报文 由3个部分组成：响应行、响应头、响应体 响应行：由协议版本、状态码、状态描述构成 http状态码1XX 通知 2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务端错误 100（”continue”）该状态码说明服务器收到了请求的初始部分，并且请客户端继续发送。 例如：客户端有一个较大的文件需要上传并保存，但是客户端不知道服务器是否愿意接受这个文件，所以希望在消耗网络资源进行传输之前，先询问一下服务器的意愿。 实际操作为客户端发送一条特殊的请求报文，报文的头部应包含： 1Expect: 100-continue 如果服务器愿意接受，就会返回100 continue状态码。 200（”OK”）一切正常 204 （无内容）服务器成功处理了请求，但没有返回任何内容。 对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑使用状态码204来作为返回信息，从而省掉多余的数据传输。 206（部分内容）这种响应是在客户端表明自己只需要目标url上的部分资源的时候返回的，这种情况经常发生在客户端继续请求一个未完成的下载时使用。 301（Move Permanently）永久性转移。将跳转到新的url地址，原本请求的资源已经不可以再访问了。 302（Move Temporarily）暂时性转移。将跳转到新的url地址，原本请求的资源仍然可以被访问。 304（”Not Modified”）和浏览器缓存相关。表明服务器端资源未发生改变，可以继续使用浏览器缓存中的资源。请求的时候一般结合last-modified/if-modified-since和Etag/if-none-match使用。 400（”Bad Request”）请求不能被服务器理解。 401（”unauthorized”）请求没有http认证的认证信息。 403（”Forbidden”）请求被服务器拒绝。 404（”Not Found”）请求的资源不在服务器端。 500（”Internet Server Error”）服务器方面的问题。 502（”Bad Gateway”）作为网关或者代理的服务器向上游服务器发起请求时，从上游服务器接收到无效响应。 504（”Gateway Timeout”）作为网关或者代理的服务器向上游服务器发起请求时，未能及时从上游服务器接收到响应。 301和302的区别共同点：301和302状态码都表示重定向，也就是说浏览器在拿到服务器返回的这个状态码之后会自动跳转到一个新的url地址。 区别：301表示旧地址已经被永久地移除了，这个资源不可以访问了。 ​ 302表示旧地址的资源还在，可以访问，这个重定向只是临时地从旧地址转到新地址。 302 303 307的区别302当客户端向服务器发出POST请求后，收到服务器的302状态码，那么是不能自动向新的URL发送请求，必须跟用户确认是否该重发，因为第二次POST请求时，环境可能已经发生变化（POST方法不是幂等的，POST操作会不符合用户预期）。 也就是说：如果客户端发出非GET, HEAD请求后(比如POST请求)，收到302状态码，是不能够自动地向新的URL发送重复请求，除非得到用户的确认。 303会直接将上述的POST请求重定向为GET请求 307不会将POST转为GET，而是会询问用户是否应该在新的URL上发起POST请求 http方法 请求方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。OPTIONS方法请求web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法 8 patch 对已知资源进行局部更新 如何理解patch局部更新资源假设我们有一个UserInfo，里面有userId， userName， userGender等10个字段。可你的编辑功能因为需求，在某个特别的页面里只能修改userName，这时候的更新怎么做？ 人们通常(为徒省事)把一个包含了修改后userName的完整userInfo对象传给后端，做完整更新。但仔细想想，这种做法感觉有点二，而且真心浪费带宽(纯技术上讲，你不关心带宽那是你土豪)。 于是patch诞生，只传一个userName到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段。 而put虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象，理论上说，如果你用了put，但却没有提供完整的UserInfo，那么缺了的那些字段应该被清空。 参考：https://segmentfault.com/q/1010000005685904/ http缺陷 通信使用明文（不加密），内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 通信使用明文可能会被窃听 如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。 不验证通信方的身份，可能遭遇伪装 在http协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。 摘自：https://blog.csdn.net/wangxp423/article/details/80033225 https http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，设计了SSL（Secure Sockets Layer）/ TLS（Transport Layer Security）协议用于对http协议传输的数据进行加密，从而诞生了https。 因此，https很安全。此外，https同时也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。 SSL/TLS握手过程 Client Hello 握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。 Server Hello 第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。 注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Hello Done Server Hello Done通知客户端Server Hello过程结束。 Certificate Verify 客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。 https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的 Client Key Exchange 上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。 至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。 为什么要使用三个随机数？ 这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。 最重要理解前六步 Change Cipher Spec（Client） 这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。 Encrypted Handshake Message(Client) 这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。 Change Cipher Spec(Server) 这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server) 这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data 到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html https://juejin.im/post/584b76d3a22b9d0058d5036f http1.0/1.1/2.0的区别http1.0 http协议老的标准是http1.0。为了提高系统的效率，http1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个tcp连接，服务器完成请求处理后立即断开tcp连接，服务器不跟踪每个客户也不记录过去的请求。连接无法复用。 客户端和服务器端每次建立和关闭连接是一个相对比较费时的过程，并且会严重影响客户端和服务器的性能。 http1.1 为了克服http1.0的这个缺陷，http1.1支持持久连接，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟。 同时，http1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分每次请求的内容。 http1.1还克服了http1.0的性能问题。http1.1通过增加更多的请求头和响应头来改进和扩充http1.0的功能。 http1.x的缺陷 Head-Of-Line Blocking：一旦队首的请求处理太慢，就会阻塞后面请求的处理。 在HTTP/1.x中，由于服务器必须按接受请求的顺序发送响应的规则限制，假设浏览器在一个（tcp）连接上发送了两个请求，那么服务器必须等第一个请求响应完毕才能发送第二个请求的响应。 连接无法复用：连接无法复用会导致每次请求都会经历三次握手和慢启动。 HTTP1.1虽然加入了keep-alive可以复用一部分连接，但在一些情况下仍然需要建立多个连接来避免任务阻塞问题（Head-Of-Line Blocking），比如通过并发连接和域名分片增加任务队列，这样就不至于一个队伍的任务阻塞其他所有任务。因为此时需要建立多个连接，所以一定程度上会消耗资源，给服务器性能带来性能压力。 协议开销大：HTTP/1.x中header内容过大（每次请求header基本不怎么变化），增加了传输的成本。 安全因素：HTTP/1.x中传输的内容都是明文，客户端和服务端双方无法验证身份。 http2.0http2.0比之前的协议在性能上有很大的提升： 多路复用：允许在一个连接上发送多个请求，响应多个请求。 每个请求和它所对应的响应会在一个stream中 一个连接中可以有多个stream 每个stream高度独立，阻塞的stream不会影响其他stream的处理，所以可以避免Head-Of-Line Blocking。 二进制分帧：用二进制的格式去定义报文。 http1.1的解析是基于文本的，基本文本协议的格式存在天然的缺陷。因为文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。 http2.0和http1.1报文格式区别： 首部压缩 如上图所示，第2个请求的Header只有:path不一样，因此压缩空间非常可观。 Headers压缩的算法HPACK本身似乎很复杂(其实也不难)，但是算法思想其实非常简单的，假设我们在浏览器发起100个请求，它们的user-agent是不会变的，那我们为什么需要重复传输这个长长的字符串呢？用dictionary记录一次不就行了！ 服务端推送：服务端可以主动推送一些客户端之后可能会请求的资源。 如何升级到http2.0 参考FunDebug文章：https://blog.fundebug.com/2019/10/28/speedup-fundebug-by-using-http2/ 我们使用了Nginx作为前端页面与后端接口的反向代理服务器(Reverse Proxy)，只需要修改一下Nginx配置文件就可以升级HTTP/2了，非常简单。 注意，在 Nginx 上 开启 HTTP/2 需要 Nginx 1.9.5 以上版本（包括1.9.5），并且需要 OpenSSL 1.0.2 以上版本(包括1.0.2)。使用nginx -V命令可以查看Nginx的版本信息： 123456nginx -Vnginx version: nginx&#x2F;1.12.1built by gcc 6.3.0 20170516 (Debian 6.3.0-18)built with OpenSSL 1.1.0f 25 May 2017TLS SNI support enabledconfigure arguments: --prefix&#x3D;&#x2F;etc&#x2F;nginx --sbin3-path&#x3D;&#x2F;usr&#x2F;sbin&#x2F;nginx --modules-path&#x3D;&#x2F;usr&#x2F;lib&#x2F;nginx&#x2F;modules --conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.pid --lock-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx.lock --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;client_temp --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;proxy_temp --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;fastcgi_temp --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;uwsgi_temp --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;cache&#x2F;nginx&#x2F;scgi_temp --user&#x3D;nginx --group&#x3D;nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt&#x3D;&#39;-g -O2 -fdebug-prefix-map&#x3D;&#x2F;data&#x2F;builder&#x2F;debuild&#x2F;nginx-1.12.1&#x2F;debian&#x2F;debuild-base&#x2F;nginx-1.12.1&#x3D;. -specs&#x3D;&#x2F;usr&#x2F;share&#x2F;dpkg&#x2F;no-pie-compile.specs -fstack-protector-strong -Wformat -Werror&#x3D;format-security -Wp,-D_FORTIFY_SOURCE&#x3D;2 -fPIC&#39; --with-ld-opt&#x3D;&#39;-specs&#x3D;&#x2F;usr&#x2F;share&#x2F;dpkg&#x2F;no-pie-link.specs -Wl,-z,relro -Wl,-z,now -Wl,--as-needed -pie&#39; 可知，我们使用的Nginx版本为1.12.1，OpenSSL版本为1.1.0f，符合要求。 还有一点，虽然HTTP/2标准并没有要求加密，但是所有浏览器都要求HTTP/2必须加密，这样的话，只有HTTPS才能升级HTTP/2。 如果你还没用过HTTPS的话，不妨看看我的博客：教你快速撸一个免费HTTPS证书，其实也很简单。 一切前提没问题的话(Nginx&gt;=1.9.5，OpenSSL&gt;=1.0.2，HTTPS)，只需要修改1行配置，在listen指令后面添加http2： 12345server&#123; listen 443 ssl http2; server_name www.fundebug.com;&#125; 重启Nginx，升级HTTP/2就成功了，可以使用curl命令检查： 12345678910111213curl -sI https:&#x2F;&#x2F;www.fundebug.comHTTP&#x2F;2 200server: nginx&#x2F;1.12.1date: Mon, 07 Oct 2019 00:12:53 GMTcontent-type: text&#x2F;html; charset&#x3D;UTF-8content-length: 4892x-powered-by: Expressaccept-ranges: bytescache-control: public, max-age&#x3D;0last-modified: Sun, 06 Oct 2019 23:07:25 GMTetag: W&#x2F;&quot;131c-16da353dbc8&quot;vary: Accept-Encodingstrict-transport-security: max-age&#x3D;15768001 curl指令：用来请求web服务器。它的名字就是客户端（client）的URL工具的意思。 参考：https://www.ruanyifeng.com/blog/2019/09/curl-reference.html 如何查看当前网站使用哪种协议打开chrome的devTool（f12），选择network项： 如果没有的话在Status一栏，点击右键，选择protocol项即可：","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"什么是跨域以及跨域解决方案","slug":"什么是跨域以及跨域解决方案","date":"2020-12-06T08:30:16.000Z","updated":"2020-12-06T12:37:20.993Z","comments":true,"path":"2020/12/06/什么是跨域以及跨域解决方案/","link":"","permalink":"http://delaprada.com/2020/12/06/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"在介绍跨域前，先介绍浏览器的一个重要的安全策略——同源策略。 在文中，web 端地址为 localhost:8000 服务端地址为 localhost:8080 同源策略 同源策略是浏览器的一个安全功能，它是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器很容易受到XSS和CSFR等攻击。 同源指的是：协议，域名，端口号都相同 同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源 跨域什么是跨域跨域是指一个源下的文档或脚本试图去请求另一个源下的资源。 常见的跨域场景： 1234567891011121314151617181920URL 说明 是否允许通信http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同文件或路径 允许http:&#x2F;&#x2F;www.domain.com&#x2F;lab&#x2F;c.jshttp:&#x2F;&#x2F;www.domain.com:8000&#x2F;a.jshttp:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同端口 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttps:&#x2F;&#x2F;www.domain.com&#x2F;b.js 同一域名，不同协议 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;192.168.4.12&#x2F;b.js 域名和域名对应相同ip 不允许 http:&#x2F;&#x2F;www.domain.com&#x2F;a.jshttp:&#x2F;&#x2F;x.domain.com&#x2F;b.js 主域相同，子域不同 不允许http:&#x2F;&#x2F;domain.com&#x2F;c.js http:&#x2F;&#x2F;www.domain1.com&#x2F;a.jshttp:&#x2F;&#x2F;www.domain2.com&#x2F;b.js 不同域名 不允许 为什么会出现跨域归结于前后端分离这种架构设计和开发模式。前端开发人员只需负责将页面设计做好，后端开发人员只需将后端逻辑写好，这样降低了前端和后端程序员的门槛，也提升了开发效率。那在开发过程中，前后端需要进行联调，才能对各种功能进行测试。但在前后端分离的模式下，前后端的域名是不一致的，此时浏览器向服务器发起请求的时候就会发生跨域的问题。 为什么需要跨域限制不同源的请求比如用户登录a网站，同时新开tab打开了b网站，如果不限制同源，b可以像a网站发起任何请求，会让不法分子有机可趁。 限制dom操作如果现在有一个和百度很类似的网站叫：www.baidu1.com。我们先登录一下百度，然后访问这个www.baidu1.com。如果可以进行dom操作（例如：document.cookie）的话，大家的信息在这些钓鱼网站上会被轻松获取。 跨域解决方案 CORS跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin（domain）上的web应用被准许访问来自不同源服务器上的指定的资源。当这个web应用向一个与之不同域、协议或端口号的服务器请求资源的时候，就会发起一个跨域请求。 CORS中的请求分为两种：简单请求和非简单请求。 简单请求，例如请求方法为HEAD，GET，POST；非简单请求，例如：PUT，DELETE。 浏览器对这两种请求的处理是不一样的。 简单请求 如果浏览器发现这次跨域请求是简单请求，就自动在头信息中添加一个Origin字段。Origin字段用来说明，本次请求来自哪个源。服务器会根据这个值决定是否同意这次请求。 如果服务器同意这次请求的话，就会在响应报文加入头字段Access-Control-Allow-Origin。它的值要么是请求时Origin字段的值，要么是一个*，表示接收任意域名的请求。 非简单请求 预检请求：浏览器如果发现此次请求是一个非简单请求的话，就自动发出一个预检请求。预检请求用的请求方法是OPTIONS，表示这个请求是用来询问服务器，当前网页所在域名是否在服务器的许可名单之中，以及可以使用哪些HTTP头字段。在这个报文中还会带有Access-Control-Request-Method字段，表示CORS请求中使用的http方法是什么，比如PUT；还有Access-Control-Request-Headers，指定浏览器CORS请求会额外发送的头信息字段。 预检请求的回应：服务器在收到预检请求之后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨域请求，就可以做出回应。回应的关键字段也是Access-Control-Allow-Origin。 想要携带cookie需要满足3个条件： 客户端设置withCredentials属性为true，例如在axios中的设置方式为：axios.defaults.withCredentials = true 服务器端添加Access-Control-Allow-Credentials: true 服务器端配置的Access-Control-Allow-Origin为非* Node的跨域解决例子原生方式1234567891011121314app.use(async (ctx, next) =&gt; &#123; ctx.set(\"Access-Control-Allow-Origin\", ctx.headers.origin); ctx.set(\"Access-Control-Allow-Credentials\", true); ctx.set(\"Access-Control-Request-Method\", \"PUT,POST,GET,DELETE,OPTIONS\"); ctx.set( \"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, cc\" ); if (ctx.method === \"OPTIONS\") &#123; ctx.status = 204; return; &#125; await next();&#125;); 第三方中间件123const cors = require(\"koa-cors\");app.use(cors()); Node正向代理代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点（代理服务器）同域。 代理前： 代理后： cli工具中的代理Webpack（4.x）在webpack中可以配置proxy来快速获得接口代理的能力。 1234567891011121314151617181920212223242526const path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123; entry: &#123; index: \"./index.js\" &#125;, output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") &#125;, devServer: &#123; port: 8000, proxy: &#123; \"/api\": &#123; target: \"http://localhost:8080\" &#125; &#125; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: \"index.html\", template: \"webpack.html\" &#125;) ]&#125;; 修改前端接口请求方式，改为不带域名。（因为现在是同域请求了）： 1234567891011121314&lt;button id=\"getlist\"&gt;获取列表&lt;/button&gt;&lt;button id=\"login\"&gt;登录&lt;/button&gt;&lt;script src=\"https://cdn.bootcss.com/axios/0.19.2/axios.min.js\"&gt;&lt;/script&gt;&lt;script&gt; axios.defaults.withCredentials = true; getlist.onclick = () =&gt; &#123; axios.get(\"/api/corslist\").then(res =&gt; &#123; console.log(res.data); &#125;); &#125;; login.onclick = () =&gt; &#123; axios.post(\"/api/login\"); &#125;;&lt;/script&gt; 因为前端现在是向webpack的devServer发起请求，所以不需要带域名(也就是http://localhost:8080)，devServer会自动转发给目标服务器地址http://localhost:8080。 Vue-cli 2.x123456789// config/index.js...proxyTable: &#123; '/api': &#123; target: 'http://localhost:8080', &#125;&#125;,... Vue-cli 3.x12345678910// vue.config.js 如果没有就新建// config/index.js...proxyTable: &#123; '/api': &#123; target: 'http://localhost:8080', &#125;&#125;,... Parcel（2.x）123456// .proxyrc&#123; \"/api\": &#123; \"target\": \"http://localhost:8080\" &#125;&#125; 以上配置方式虽多，但都是有着共同的底层包http-proxy-middleware。里面需要用到的各种websocket，rewrite等功能，直接看这个库的配置即可。搜索技巧就是，想要那个框架直接google xxx proxy即可，官网有配置答案。 Nginx反向代理Nginx则是通过反向代理的方式，这里需要自定义一个域名。这里就是保证我当前域，能获取到静态资源和接口，不关心是怎么获取的。 nginx安装教程：https://blog.csdn.net/diaojw090/article/details/89135073 配置hosts：127.0.0.1 local.test 配置nginx： 12345678910server &#123; listen 80; server_name local.test; location /api &#123; proxy_pass http://localhost:8080; &#125; location / &#123; proxy_pass http://localhost:8000; &#125;&#125; 启动nginx：sudo nginx 重启nginx：sudo nginx -s reload 前端代码： 1234567891011&lt;script&gt; axios.defaults.withCredentials = true; getlist.onclick = () =&gt; &#123; axios.get(\"/api/corslist\").then(res =&gt; &#123; console.log(res.data); &#125;); &#125;; login.onclick = () =&gt; &#123; axios.post(\"/api/login\"); &#125;;&lt;/script&gt; 后端代码： 1234567891011&lt;script&gt; axios.defaults.withCredentials = true; getlist.onclick = () =&gt; &#123; axios.get(\"/api/corslist\").then(res =&gt; &#123; console.log(res.data); &#125;); &#125;; login.onclick = () =&gt; &#123; axios.post(\"/api/login\"); &#125;;&lt;/script&gt; 疑惑：为什么客户端访问nginx反向代理服务器不会跨域，domain都不一样。。 用nginx反向代理解决跨域 参考：https://blog.csdn.net/qq_34020571/article/details/80597136 第一步：配置nginx.config 1234567891011121314151617181920212223242526272829server &#123; listen 8000; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root E:/h5; #h5项目路径 &#125; location /urm &#123; #代理的接口路径 proxy_pass http://192.168.1.111:9003/urm; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header 'Access-Control-Allow-Origin' '*'; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; &#125; location = /favicon.ico &#123; log_not_found off; access_log off; &#125; &#125; 第二步：启动后端服务器，启动nginx 第三步：修改前端ajax访问的url 从http://192.168.1.111:9003/urm —&gt; http://192.168.1.111:8000/urm 第四步：访问前端项目 http://192.168.1.111:8000/agent/merchant_manage.html 正向代理和反向代理的区别 参考链接：https://blog.csdn.net/m13666368773/article/details/8060481 正向代理：客户端知道服务端，通过代理端连接服务端。代理端代理的是服务端。 反向代理：所谓反向，是对正向而言的。服务端知道客户端，客户端不知道服务端，通过代理端连接服务端。代理端代理客户端。代理对象恰好相反，故名为反向代理。 JSONPJSONP主要是利用了script标签没有跨域限制的特性来完成的。 使用限制仅支持GET方法，如果想要使用完整的REST接口，请使用CORS或者其他代理方式。 流程解析 前端定义回调函数（例如 jsonpCallback=function(){....}） 通过params形式包装请求参数，并且声明执行函数（例如：cb=jsonpCallback） 后端获取前端声明的执行函数（jsonpCallback），并以带上参数和调用执行函数的方式传递给前端 使用示例后端实现： 12345678910111213const Koa = require(\"koa\");const fs = require(\"fs\");const app = new Koa();app.use(async (ctx, next) =&gt; &#123; if (ctx.path === \"/api/jsonp\") &#123; const &#123; cb, msg &#125; = ctx.query; ctx.body = `$&#123;cb&#125;($&#123;JSON.stringify(&#123; msg &#125;)&#125;)`; return; &#125;&#125;);app.listen(8080); 前端普通js示例： 123456789&lt;script type=\"text/javascript\"&gt; window.jsonpCallback = function(res) &#123; console.log(res); &#125;;&lt;/script&gt;&lt;script src=\"http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback\" type=\"text/javascript\"&gt;&lt;/script&gt; jQuery Ajax示例： 123456789101112131415&lt;script src=\"https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url: \"http://localhost:8080/api/jsonp\", dataType: \"jsonp\", type: \"get\", data: &#123; msg: \"hello\" &#125;, jsonp: \"cb\", success: function(data) &#123; console.log(data); &#125; &#125;);&lt;/script&gt; WebsocketWebSocket协议是html5一种新的协议。在WebSocket协议中，客户端和服务端都可以主动地推送消息，而且没有同源策略的限制，不存在跨域问题。协议的标识符为ws。像https一样如果加密的话就是wxs。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制。 前端部分： 123456789&lt;script&gt; let socket = new WebSocket(\"ws://localhost:8080\"); socket.onopen = function() &#123; socket.send(\"秋风的笔记\"); &#125;; socket.onmessage = function(e) &#123; console.log(e.data); &#125;;&lt;/script&gt; 后端部分： 1234567const WebSocket = require(\"ws\");const server = new WebSocket.Server(&#123; port: 8080 &#125;);server.on(\"connection\", function(socket) &#123; socket.on(\"message\", function(data) &#123; socket.send(data); &#125;);&#125;); 本节内容代码：https://github.com/hua1995116/node-demo/tree/master/node-cors 参考： https://segmentfault.com/a/1190000022398875 https://blog.csdn.net/m13666368773/article/details/8060481","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"Decorator用法与实践","slug":"Decorator用法与实践","date":"2020-12-01T06:19:07.000Z","updated":"2020-12-01T08:23:15.230Z","comments":true,"path":"2020/12/01/Decorator用法与实践/","link":"","permalink":"http://delaprada.com/2020/12/01/Decorator%E7%94%A8%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"今天看关注的公众号发了一篇关于Decorator在组件当中的应用，觉得比较新颖，因为之前看过的文章都是在类和类的方法里应用的。所以想趁此契机梳理一下Decorator知识。 Decorator特性可能在将来会发生改变，需等到定案之后再对其内容进行更新。 什么是Decorator装饰器装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类的方法。它体现了一种控制反转的设计思想，可以用来降低代码之间的耦合度，也称作依赖注入（常见的控制反转方法）。 装饰器是一种函数，写成@+函数名。它可以放在类和类方法定义的前面。 123456789@frozenclass Foo &#123; @configurable(false) @enumerable(true) method() &#123;&#125; @throttle(500) expensiveMethod() &#123;&#125;&#125; 代码中使用了四个装饰器，一个用在类本身，另外三个用在类方法。这是一种方便的手段来增加或修改类的功能。 类的装饰12345678@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable // true @testable就是一个装饰器，它修改了MyTestableClass这个类的的行为，为它添加了静态属性isTestable。testable函数的参数target就是MyTestableClass类本身。 装饰器函数的第一个参数就是所要修饰的目标类。如果觉得一个参数不够用，可以在装饰器外面再封装一层函数： 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable // false 注意：装饰器对类的行为的改变，是代码编译时发生的，而不是运行时。 前面的例子只是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作： 123456789function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable // true 方法的装饰1234567891011121314151617181920class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;function readonly(target, name, descriptor) &#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, 'name', descriptor);// 类似于Object.defineProperty(Person.prototype, 'name', descriptor); 装饰器第一个参数是类的原型对象，上例是Person.prototype，装饰器的本意是要“装饰”类的实例，但这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况target参数指的是类本身） 第二个参数是所要装饰的属性名 第三个参数是该属性的描述对象 @log装饰器，可以起到输出日志的作用（这个常常会使用到）： 12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor;&#125;const math = new Math();// passed parameters should get logged nowmath.add(2, 4); 如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行： 1234567891011121314function dec(id)&#123; console.log('evaluated', id); return (target, property, descriptor) =&gt; console.log('executed', id);&#125;class Example &#123; @dec(1) @dec(2) method()&#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 装饰器不能用于函数装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。 123456789var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125; 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样： 123456789101112var counter;var add;@addfunction foo() &#123;&#125;counter = 0;add = function () &#123; counter++;&#125;; Mixin在装饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，意在为一个对象之中混入另外一个对象的方法。 一般是通过Object.assign方法实现。 比如： 12345export function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; 使用上面这个装饰器，为类”混入”各种方法： 1234567891011import &#123; mixins &#125; from './mixins';const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // \"foo\" 如何体现依赖注入我们从代码中可以发现，如果我们想要为某个类添加一些方法，只需要在类的前面添加一个装饰器即可。在没有装饰器之前我们一般会怎么做呢？我们会定义一个抽象类，在其中定义继承这个抽象类的所有类共有的一些方法，这样的话子类和子类之间的耦合度会比较高。那装饰器这种模式就可以降低类与类之间的耦合度。 Decorator装饰器在前端组件中的应用Decorator（装饰器模式）属于结构型模式，是一种拓展对象额外功能的设计模式，别名wrapper。 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。 wrapper经常在前端搭建场景中遇到，当搭建平台加载一个组件时，希望拓展其基础能力，一般会使用wrapper层对组件进行嵌套，wrapper层就是在不改变API的情况下，对第三方组件进行加强。 不同于继承，组合可以在运行时进行，所以称之为“动态添加”，这里的“额外职责”泛指一切功能，比如在按钮点击时进行一些log日志的打印，在绘制text文本框时，额外绘制一个滚动条和边框等等。 “就增加功能来说，Decorator模式相比生成子类更加灵活” 这句话的含义是，组合比继承更灵活，当可拓展的功能很多时，继承方案会产生大量的子类，而组合可以提前写好处理函数，在需要时动态构造，显然是更灵活的。 结构图 ConcreteComponent指的是需要被装饰的组件，可以看到，装饰器Decorator与他都继承同一个类，这样能保证API的一致，才保证无论装饰多少层，始终符合Component类型。 装饰器如果有多种，就要将Decorator申明为抽象类，ConcreteDecoratorA、ConcreteDecoratorB分别实现它们，如果只有一种装饰器，可以退化到Decorator自身就是一种实现。 代码例子1234567891011121314151617181920class Component &#123; public onClick = () =&gt; &#123;&#125;&#125;class Decorator extends Component &#123; private _component constructor(component) &#123; this._component = component &#125; public onClick = () =&gt; &#123; log('打点') this._component.onClick(); &#125;&#125;const component = new Component()// 一个普通的点击component.onClick()const wrapperComponent = new Decorator(component)// 一个具有打点功能的点击wrapperComponent.onClick() 其实方法很简单，通过组合，我们得到一个能力更强的组件，而实现方式就是利用构造函数保存组件实例，并在复写函数时，增加一些增强实现。 弊端装饰器的问题也是组合的问题，过多的组合会导致： 组合过程的复杂，要生成过多的对象 包装器层次增多，会增加调试成本，我们比较难追溯到一个bug是在哪一层包装导致的 总结装饰器模式是非常常用的模式，Decorator是一个透明的包装，只要保证包装的透明性，就可以最大限度发挥装饰器模式的优势。 最后总结一个装饰器应用图： 关于兼容性由于是es7的新特性，需要配置babel才能支持装饰器。 配置方法： babel：7.X版本 依赖安装 12npm install --save-dev @babel/plugin-proposal-decorators npm install --save-dev @babel/plugin-proposal-class-properties 配置（一般在.babelrc或babel.config.js中进行配置） 123456&#123; \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], [\"@babel/plugin-proposal-class-properties\", &#123; \"loose\" : true &#125;] ]&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"ES11新增属性解析","slug":"ES11新增属性解析","date":"2020-11-25T02:45:59.000Z","updated":"2020-11-25T03:00:01.362Z","comments":true,"path":"2020/11/25/ES11新增属性解析/","link":"","permalink":"http://delaprada.com/2020/11/25/ES11%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E8%A7%A3%E6%9E%90/","excerpt":"","text":"ES11新增属性解析ES2020(ES11)引入了以下新特性（个人觉得比较实用的以粗体形式展示）： String的matchAll方法 动态导入语句import() import.meta export * as ns from &#39;module&#39; Promise.allSettled 新的数据类型BigInt GlobalThis Nullish coalescing Operator Optional Chaining matchAllmatchAll()方法返回一个包含所有匹配正则表达式的结果的迭代器。使用for...of遍历或者使用操作符...、Array.from将其转换成数组。 12345678910const reg = /[0-3]/g;const data = '2020'; console.log(data.matchAll(reg));//data.matchAll 的返回值是一个迭代器console.log([...data.matchAll(reg)]);/** * 0: [\"2\", index: 0, input: \"2020\", groups: undefined] * 1: [\"0\", index: 1, input: \"2020\", groups: undefined] * 2: [\"2\", index: 2, input: \"2020\", groups: undefined] * 3: [\"0\", index: 3, input: \"2020\", groups: undefined] */ Dynamic import标准用法的import导入的模块时静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。 在import()（也就是动态import）之前，当我们需要根据条件导入模块时，不得不使用require()。 如： 123if(XXX) &#123; const menu = require('./menu');&#125; 如今可以替换为： 123if(XXX) &#123; const menu = import('./menu');&#125; @babel/preset-env已经包含了@babel/plugin-syntax-dynamic-import，因此如果要使用import()语法，只需要配置@babel/preset-env即可。 提示：请不要滥用动态导入（只有在必要情况下采用）。静态框架能更好地初始化依赖，而且更有利于静态分析工具和tree shaking发挥作用。 另外，import()返回的是一个promise对象。例如： 1234// menu.jsexport default &#123; menu: 'menu'&#125; 12345678//index.jsif(true) &#123; let menu = import('./menu'); console.log(menu); //Promise &#123;&lt;pending&gt; menu.then(data =&gt; console.log(data));//Module &#123;default: &#123;menu: \"menu\"&#125;, __esModule: true, Symbol(Symbol.toStringTag): \"Module\"&#125;&#125; else &#123; &#125; export * as ns from ‘module’12//menu.jsexport * as ns from './info'; 可以理解为是将下面两条语句合并为一句： 12import * as ns from './info';export &#123; ns &#125;; 不过需要注意的是，export * as ns from &#39;./info&#39;并不会真正导入模块，因此在该模块（menu.js）中，我们是获取不到ns的。 Promise.allSettledPromise.all或者Promise.race有的时候并不能满足我们的需求。比如，我们需要在所有的promise都结束的时候做一些操作，而并不在乎它们是成功还是失败。在没有Promise.allSettled之前，我们需要自己去写实现。 Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。 12345678910111213const promise1 = Promise.resolve(100);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'info'));const promise3 = new Promise((resolve, reject) =&gt; setTimeout(resolve, 200, 'name'))Promise.allSettled([promise1, promise2, promise3]). then((results) =&gt; console.log(result));/* [ &#123; status: 'fulfilled', value: 100 &#125;, &#123; status: 'rejected', reason: 'info' &#125;, &#123; status: 'fulfilled', value: 'name' &#125; ]*/ BigIntBigInt是一种数字类型，它可以表示任意精度格式的整数。在此之前，JS中安全的最大数字是2^53-1，可在控制台输入Number.MAX_SAFE_INTEGER查看。超过这个值，JS没有办法精确表示。另外，大于或等于2的1024次方的数值，JS无法表示，会返回Infinity。 BigInt则解决了这两个问题。BigInt只用来表示整数，没有位数限制，任何位数的整数都可以精确表示。为了和Number类型进行区分，BigInt类型的数据必须添加后缀n。 1234567//Number类型在超过9009199254740991后，计算结果即出现问题const num1 = 90091992547409910;console.log(num1 + 1); //90091992547409900//BigInt 计算结果正确const num2 = 90091992547409910n;console.log(num2 + 1n); //90091992547409911n 还可以使用BigInt对象来初始化BigInt实例： 1console.log(BigInt(999)); // 999n 注意：没有 new 关键字！！！ 需要说明的是，BigInt和Number是两种数据类型，不能直接进行四则运算，不过可以进行比较操作： 123console.log(99n == 99); //trueconsole.log(99n === 99); //false console.log(99n + 1);//TypeError: Cannot mix BigInt and other types, use explicit conversionss GlobalThisJS中存在一个顶层对象，但是，顶层对象在各种实现里是不统一的。 从不同的JS环境中获取全局对象需要不同的语句。在Web中，可以通过window、self取得全局对象，但是在Web Workers中，只有self可以。在Node.js中，它们都无法获取，必须使用global。 在globalThis之前，我们需要这样去获取全局对象： 123456var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; ES2020中引入globalThis作为顶层对象，在任何环境中，都可以简单地通过globalThis拿到顶层对象。 Nullish coalescing OperatorES2020新增了一个运算符??。当左操作数为null或者undefined时，返回其右侧操作数，否则返回左侧操作数。 使用||操作符，当左侧的操作数为0、null、undefined、NaN、false、&#39;&#39;时，都会使用右侧的操作数。如果使用||来为某些变量设置默认值，可能会遇到意料之外的行为。 比如： 123const defaultValue = 100;let value = someValue || defaultValue;//当 someValue 转成 boolean 值为 false 时，value 的值都是 defaultValue 当someValue的值为0时，我们其实期望value值为0，但是它被错误分配成100。 ??操作符可以规避以上问题，它只有在左操作数为null或者是undefined时，才会返回右操作数。 Optional Chaining可选链操作符?.允许读取位于连接对象链深处的属性的值，而不必明确验证链中每一个引用是否有效。 例如，我们要访问info对象的animal的reptile的tortoise。但是我们不确定animal，reptile是否存在，因此我们需要这样写： 1const tortoise = info.animal &amp;&amp; info.animal.reptile &amp;&amp; info.animal.reptile.tortoise; 因为null.reptile或undefined.reptile会抛出错误：TypeError: Cannot read property &#39;reptile&#39; of undefined/null。如果我们需要访问的属性更深，那么这句代码会越来越长。 而有了可选链操作符?.，我们在访问reptile之前，不再需要校验info.animal的值。同样，在访问info.animal.reptile.tortoise之前，也不需要校验info.animal.reptile的值。 上面的代码简化为： 1const tortoise = info.animal?.reptile?.tortoise; JS在尝试访问info.animal.reptile之前，会隐式检查并确定info.animal的值不是null或undefined，如果其值是null或undefined，那么表达式短路计算直接返回undefined。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"使用better-scroll创建Scroll组件","slug":"使用better-scroll创建Scroll组件","date":"2020-04-19T06:39:24.000Z","updated":"2020-04-19T07:35:11.868Z","comments":true,"path":"2020/04/19/使用better-scroll创建Scroll组件/","link":"","permalink":"http://delaprada.com/2020/04/19/%E4%BD%BF%E7%94%A8better-scroll%E5%88%9B%E5%BB%BAScroll%E7%BB%84%E4%BB%B6/","excerpt":"","text":"在学习《React Hooks与Immutable数据流实战》这本书的时候，其中一章讲到了使用better scroll打造一个scroll组件，花了蛮长时间去理解里面使用到的各种的方法，比如：better scroll、forwardRef等，在此总结一下。 better-scroll better-scroll的基本原理：https://juejin.im/post/59300b2e2f301e006bcdd91c#heading-0 better-scroll 是一个移动端滚动的解决方案，它是基于 iscroll 的重写，它和 iscroll 的主要区别在这里。better-scroll 也很强大，不仅可以做普通的滚动列表，还可以做轮播图、picker 等等。 better-scroll的滚动原理浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵向滚动条；当页面内容的宽度超过视口宽度的时候，会出现横向滚动条。也就是当我们的视口展示不下内容的时候，会通过滚动条的方式让用户滚动屏幕看到剩余的内容。 那么对于 better-scroll 也是一样的道理，我们先来看一下 better-scroll 常见的 html 结构： 1234567&lt;div class=\"wrapper\"&gt; &lt;ul class=\"content\"&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt; 为了更加直观，我们再来看一张图： 绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。 那么，我们怎么初始化 better-scroll 呢，如果是上述 html 结构，那么初始化代码如下： 123import BScroll from &#39;better-scroll&#39;let wrapper &#x3D; document.querySelector(&#39;.wrapper&#39;)let scroll &#x3D; new BScroll(wrapper, &#123;&#125;)复制代码 better-scroll 对外暴露了一个 BScroll 的类，我们初始化只需要 new 一个类的实例即可。第一个参数就是我们 wrapper 的 DOM 对象，第二个是一些配置参数，具体参考 better-scroll 的文档。 better-scroll 的初始化时机很重要，因为它在初始化的时候，会计算父元素和子元素的高度和宽度，来决定是否可以纵向和横向滚动。因此，我们在初始化它的时候，必须确保父元素和子元素的内容已经正确渲染了。如果子元素或者父元素 DOM 结构发生改变的时候，必须重新调用 scroll.refresh() 方法重新计算来确保滚动效果的正常。所以同学们反馈的 better-scroll 不能滚动的原因多半是初始化 better-scroll 的时机不对，或者是当 DOM 结构发送变化的时候并没有重新计算 better-scroll。 创建一个scroll组件12&#x2F;&#x2F; 安装 better-scrollnpm install better-scroll@next --save 我们依然采用函数式组件的形式进行开发，不过作为一个通用组件，scroll 组件在业务中会被经常取到原生 DOM 对象，而函数式组件天生不具备被上层组件直接调用 ref 的条件，因此需要用 React 当中一些特殊的方式来处理，即使用 forwardRef 进行包裹。 forwardRef可以将子组件通过ref暴露给父组件，使得父组件可以通过ref获取到子组件的dom。 123const Scroll = forwardRef ((props, ref) =&gt; &#123; // 编写组件内容&#125;) 首先梳理一下这个组件需要接受哪些参数: 123456789101112Scroll.propTypes = &#123; direction: PropTypes.oneOf (['vertical', 'horizental']),// 滚动的方向 click: true,// 是否支持点击 refresh: PropTypes.bool,// 是否刷新 onScroll: PropTypes.func,// 滑动触发的回调函数 pullUp: PropTypes.func,// 上拉加载逻辑 pullDown: PropTypes.func,// 下拉加载逻辑 pullUpLoading: PropTypes.bool,// 是否显示上拉 loading 动画 pullDownLoading: PropTypes.bool,// 是否显示下拉 loading 动画 bounceTop: PropTypes.bool,// 是否支持向上吸顶 bounceBottom: PropTypes.bool// 是否支持向下吸底&#125;; 通过propTypes定义参数的类型。 目前归纳出了这些可能的参数，也正是后面的开发中所需要的，给他们赋默认值: 123456789101112Scroll.defaultProps = &#123; direction: \"vertical\", click: true, refresh: true, onScroll:null, pullUpLoading: false, pullDownLoading: false, pullUp: null, pullDown: null, bounceTop: true, bounceBottom: true&#125;; 通过defaultProps定义这些参数的默认值。 现在来写 scroll 组件的核心逻辑代码，首先声明如下 hooks 变量: 1234//better-scroll 实例对象const [bScroll, setBScroll] = useState ();//current 指向初始化 bs 实例需要的 DOM 元素 const scrollContaninerRef = useRef (); 从外面接受 props，解构赋值拿到这些参数: 12const &#123; direction, click, refresh, pullUpLoading, pullDownLoading, bounceTop, bounceBottom &#125; = props;const &#123; pullUp, pullDown, onScroll &#125; = props; 接下来创建 better-scroll: 12345678910111213141516useEffect (() =&gt; &#123; const scroll = new BScroll (scrollContaninerRef.current, &#123; scrollX: direction === \"horizental\", scrollY: direction === \"vertical\", probeType: 3, click: click, bounce:&#123; top: bounceTop, bottom: bounceBottom &#125; &#125;); setBScroll (scroll); return () =&gt; &#123; setBScroll (null); &#125;&#125;, []); 通过new BScroll创建一个scroll实例，第一个参数是父容器，也就是说scrollContainerRef所指向的DOM作为这个scroll组件的父容器。 setBScroll方法就是将创建出来的scroll实例赋值给bScroll。 return()=&gt;{...}就是在组件销毁的时候对effect进行清除 每次重新渲染都要刷新实例，防止无法滑动: 12345useEffect (() =&gt; &#123; if (refresh &amp;&amp; bScroll)&#123; bScroll.refresh (); &#125;&#125;); 给实例绑定 scroll 事件: 123456789useEffect (() =&gt; &#123; if (!bScroll || !onScroll) return; bScroll.on ('scroll', (scroll) =&gt; &#123; onScroll (scroll); &#125;) return () =&gt; &#123; bScroll.off ('scroll'); &#125;&#125;, [onScroll, bScroll]); 进行上拉到底的判断，调用上拉刷新的函数: 123456789101112useEffect (() =&gt; &#123; if (!bScroll || !pullUp) return; bScroll.on ('scrollEnd', () =&gt; &#123; // 判断是否滑动到了底部 if (bScroll.y &lt;= bScroll.maxScrollY + 100)&#123; pullUp (); &#125; &#125;); return () =&gt; &#123; bScroll.off ('scrollEnd'); &#125;&#125;, [pullUp, bScroll]); 进行下拉的判断，调用下拉刷新的函数: 123456789101112useEffect (() =&gt; &#123; if (!bScroll || !pullDown) return; bScroll.on ('touchEnd', (pos) =&gt; &#123; // 判断用户的下拉动作 if (pos.y &gt; 50) &#123; pullDown (); &#125; &#125;); return () =&gt; &#123; bScroll.off ('touchEnd'); &#125;&#125;, [pullDown, bScroll]); 现在已经完成了滑动事件，上拉下拉事件的判断，现在需要给外界暴露组件方法，假设这样的一个情景： 1234// 上层组件代码const scrollRef = useRef ();...&lt;Scroll ref=&#123;scrollRef&#125;&gt;&lt;/Scroll&gt; 想要通过这种调用方法的方式刷新 scroll 组件： 1scrollRef.current.refresh (); 这应该怎么办呢？ React Hooks 中的 useImperativeHandle 已经给了我们解决方案，我们这样做就好了: 12345678910111213141516// 一般和 forwardRef 一起使用，ref 已经在 forWardRef 中默认传入useImperativeHandle (ref, () =&gt; (&#123; // 给外界暴露 refresh 方法 refresh () &#123; if (bScroll) &#123; bScroll.refresh (); bScroll.scrollTo (0, 0); &#125; &#125;, // 给外界暴露 getBScroll 方法，提供 bs 实例 getBScroll () &#123; if (bScroll) &#123; return bScroll; &#125; &#125;&#125;)); 这样上层组件就可以通过ref获取到这些方法。比如有时候要执行刷新之类的操作的时候，就需要去调用refresh方法。 剩下的是 UI 的渲染工作: 12345return ( &lt;ScrollContainer ref=&#123;scrollContaninerRef&#125;&gt; &#123;props.children&#125; &lt;/ScrollContainer&gt;); scrollContainerRef所指向的dom就是这个ScrollContainer。 同时贴出样式部分的 js 代码: 12345const ScrollContainer = styled.div` width: 100%; height: 100%; overflow: hidden;` 将Scroll组件应用到Recommend.js中导入Scroll组件： 1import Scroll from '../../scroll.js'; 在return中应用： 12345678&lt;Content&gt; &lt;Scroll className=\"list\"&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerList&#125;&gt;&lt;/Slider&gt; &lt;RecommendList recommendList=&#123;recommendList&#125;&gt;&lt;/RecommendList&gt; &lt;/div&gt; &lt;/Scroll&gt;&lt;/Content&gt; 这里作者用了个Content，来去保证父组件高度固定，这里是我疑惑的一个点，按照better-scroll的官方文档的内容，我们执行 123456789new BScroll (scrollContaninerRef.current, &#123; scrollX: direction === \"horizental\", scrollY: direction === \"vertical\", probeType: 3, click: click, bounce:&#123; top: bounceTop, bottom: bounceBottom &#125;) 操作的时候，已经将scrollContainerRef.current作为父容器了。 后来我自己试了一下，将ScrollContainer的样式改为Content样式，把Content去掉，是可以有相同效果的，不过，推荐的界面会浮动到最上一层。此处，我再在样式表中添加z-index:-1就有相同效果了。 12345678910const ScrollContainer = styled.div` /* width: 100%; height: 100%; overflow: hidden; */ position: fixed; top: 90px; bottom: 0; width: 100%; z-index:-1;` Recommend/index.js： 123456789&lt;div&gt; &lt;Scroll onScroll=&#123;forceCheck&#125;&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerListJS&#125;&gt;&lt;/Slider&gt; &lt;RecommendList recommendList=&#123;recommendListJS&#125;&gt;&lt;/RecommendList&gt; &lt;/div&gt; &lt;/Scroll&gt; &#123;enterLoading?&lt;Loading&gt;&lt;/Loading&gt;:null&#125;&lt;/div&gt;","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"React+Redux 通过axios向接口获取数据的流程","slug":"React-Redux-通过axios向接口获取数据的流程","date":"2020-04-17T11:45:34.000Z","updated":"2020-04-17T12:34:39.946Z","comments":true,"path":"2020/04/17/React-Redux-通过axios向接口获取数据的流程/","link":"","permalink":"http://delaprada.com/2020/04/17/React-Redux-%E9%80%9A%E8%BF%87axios%E5%90%91%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/","excerpt":"","text":"最近在学习《React Hooks与Immutable数据流实战》小书，想把在React+Redux项目中用axios发起请求的配置流程记录下来，做个总结，加深一些印象。 启动服务器首先是将github上网易云音乐接口的node.js项目启动，在项目中都是向这个服务器去发起请求，获取接口数据。 12&#x2F;&#x2F;启动服务器指令node app.js 安装axios1npm install axios --save 现在在 src/api 目录下新建 config.js 文件，里面编写 axios 的配置: 12345678910111213141516171819import axios from 'axios';export const baseUrl = 'http://xxx自己填';//axios 的实例及拦截器配置const axiosInstance = axios.create (&#123; baseURL: baseUrl&#125;);axiosInstance.interceptors.response.use ( res =&gt; res.data, err =&gt; &#123; console.log (err, \"网络错误\"); &#125;);export &#123; axiosInstance&#125;; baseUrl的话就是服务器的基地址，比如http://localhost:3000，那请求的一些接口数据就会在这个baseUrl的不同路由下，比如banner数据会通过http://localhost:3000/banner接口获取。 axios.create：创建一个axios实例，可以添加一些基本配置。 官网解释： axios.create([config])12345const instance &#x3D; axios.create(&#123; baseURL: &#39;https:&#x2F;&#x2F;some-domain.com&#x2F;api&#x2F;&#39;, timeout: 1000, headers: &#123;&#39;X-Custom-Header&#39;: &#39;foobar&#39;&#125;&#125;); axiosInstance.interceptors.response.use 用于将公共的业务逻辑抽离出来。 然后在同一个目录下新建 request.js 用来封装不同的网络请求，内容如下: 123456789import &#123; axiosInstance &#125; from \"./config\";export const getBannerRequest = () =&gt; &#123; return axiosInstance.get ('/banner');&#125;export const getRecommendListRequest = () =&gt; &#123; return axiosInstance.get ('/personalized');&#125; 在request.js中封装一些向服务器发起请求的方法，注意返回的是promise对象。 redux层开发在 Recommend 目录下，新建 store 文件夹，然后新建以下文件： 1234actionCreators.js&#x2F;&#x2F; 执行一些request.js中封装好的方法，获取到接口数据，并通过dispatch更新store的内容constants.js &#x2F;&#x2F; 常量集合，存放不同 action 的 type 值index.js &#x2F;&#x2F; 用来导出 reducer，actionreducer.js &#x2F;&#x2F; 存放 initialState 和 reducer 函数 constants.js1234//定义action类型export const CHANGE_BANNER='recommend/CHANGE_BANNER';export const CHANGE_RECOMMEND_LIST='recommend/RECOMMEND_LIST'; reducer.js定义reducer函数，并初始化state: 123456789101112131415161718192021import * as actionTypes from './constants';import &#123;fromJS&#125; from 'immutable'; // 这里用到 fromJS 把 JS 数据结构转化成 immutable 数据结构import &#123;combineReducer&#125; from 'redux-immutable';const defaultState=fromJS(&#123; bannerList: [], recommendList: []&#125;)//定义reducer函数export default (state=defaultState, action)=&gt;&#123; switch(action.type)&#123; case actionTypes.CHANGE_BANNER: return state.set('bannerList', action.data); case actionTypes.CHANGE_RECOMMEND_LIST: return state.set('recommendList', action.data); default: return state; &#125;&#125; actionCreators.js执行request.js中的方法，通过axios从接口获取数据，然后通过dispatch方法，使用获取到的新数据去更新state。 12345678910111213141516171819202122232425262728293031323334import * as actionTypes from './constants';import &#123;fromJS&#125; from 'immutable';import &#123;getBannerRequest, getRecommendListRequest&#125; from '../../../api/request'export const changeBannerList=(data)=&gt;(&#123; type: actionTypes.CHANGE_BANNER, data: fromJS(data)&#125;);export const changeRecommendList=(data)=&gt;(&#123; type: actionTypes.CHANGE_RECOMMEND_LIST, data: fromJS(data)&#125;)export const getBannerList=()=&gt;&#123; return (dispatch)=&gt;&#123; getBannerRequest().then(data=&gt;&#123; //返回的数据格式为：&#123;banners: Array(8), code:200&#125; dispatch(changeBannerList(data.banners)); &#125;).catch(()=&gt;&#123; console.log(\"轮播图数据传输错误\"); &#125;) &#125;&#125;export const getRecommendList=()=&gt;&#123; return (dispatch)=&gt;&#123; getRecommendListRequest().then(data=&gt;&#123; dispatch(changeRecommendList(data.result)); &#125;).catch(()=&gt;&#123; console.log(\"推荐歌单数据传输错误\"); &#125;) &#125;&#125; index.js用于将相关变量导出： 12345//index.jsimport reducer from './reducer'import * as actionCreators from './actionCreators'export &#123; reducer, actionCreators &#125;; 组件连接Redux首先，需要将 recommend 下的 reducer 注册到全局 store，在 store/reducer.js 中，内容如下: 123456import &#123; combineReducers &#125; from 'redux-immutable';import &#123; reducer as recommendReducer &#125; from '../application/Recommend/store/index';export default combineReducers (&#123; recommend: recommendReducer,&#125;); 注册完成！ 现在在 Recommend/index.js 中，准备连接 Redux。组件代码更新如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; useEffect &#125; from 'react';import Slider from '../../components/slider/';import &#123; connect &#125; from \"react-redux\";import * as actionTypes from './store/actionCreators';import RecommendList from '../../components/list/';import Scroll from '../../baseUI/scroll/index';import &#123; Content &#125; from './style';function Recommend (props)&#123; const &#123; bannerList, recommendList &#125; = props; const &#123; getBannerDataDispatch, getRecommendListDataDispatch &#125; = props; useEffect (() =&gt; &#123; getBannerDataDispatch (); getRecommendListDataDispatch (); //eslint-disable-next-line &#125;, []); const bannerListJS = bannerList ? bannerList.toJS () : []; const recommendListJS = recommendList ? recommendList.toJS () :[]; return ( &lt;Content&gt; &lt;Scroll&gt; &lt;div&gt; &lt;Slider bannerList=&#123;bannerListJS&#125;&gt;&lt;/Slider&gt; &lt;RecommendList recommendList=&#123;recommendListJS&#125;&gt;&lt;/RecommendList&gt; &lt;/div&gt; &lt;/Scroll&gt; &lt;/Content&gt; );&#125;// 映射 Redux 全局的 state 到组件的 props 上const mapStateToProps = (state) =&gt; (&#123; // 不要在这里将数据 toJS // 不然每次 diff 比对 props 的时候都是不一样的引用，还是导致不必要的重渲染，属于滥用 immutable bannerList: state.getIn (['recommend', 'bannerList']), recommendList: state.getIn (['recommend', 'recommendList']),&#125;);// 映射 dispatch 到 props 上const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; getBannerDataDispatch () &#123; dispatch (actionTypes.getBannerList ()); &#125;, getRecommendListDataDispatch () &#123; dispatch (actionTypes.getRecommendList ()); &#125;, &#125;&#125;;// 将 ui 组件包装成容器组件export default connect (mapStateToProps, mapDispatchToProps)(React.memo (Recommend)); 通过connect高阶函数，将mapStateToProps、mapDispatchToProps的属性和方法整合起来，传入内嵌组件（Recommend），内嵌组件就可以通过props获取到数据。 mapStateToProps：获取store中的state，对数据进行初始化操作 mapDispatchToProps：声明一些数据更新、数据获取操作 在useEffect阶段执行getBannerDataDispatch (); getRecommendListDataDispatch ();操作。useEffect是Hook的API，用于完成副作用操作。它相当于class中的一些声明周期，在特定时期执行响应的操作。此处useEffect的第二个参数为[]，表示只在第一次执行，用来请求异步数据；如果第二个参数不为空数组，比如数组内有一些属性的话，则在这些属性发生变化的时候，useEffect才会执行。 Hook的API介绍详情： React官方文档 https://juejin.im/post/5e53d9116fb9a07c9070da44 启动1npm start 看到结果： 要注意的点： 12345678910export const getBannerList=()=&gt;&#123; return (dispatch)=&gt;&#123; getBannerRequest().then(data=&gt;&#123; //返回的数据格式为：&#123;banners: Array(8), code:200&#125; dispatch(changeBannerList(data.banners)); &#125;).catch(()=&gt;&#123; console.log(\"轮播图数据传输错误\"); &#125;) &#125;&#125; 要注意看接口返回的数据，比如getBannerRequest()获取到的数据是对象，那我们要使用data.banners才能获取到banner的内容，直接data是会出错的。","categories":[{"name":"React","slug":"React","permalink":"http://delaprada.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://delaprada.com/tags/React/"}]},{"title":"Node.js——Express和koa框架对比","slug":"Node-js——Express和koa框架对比","date":"2020-04-07T03:10:47.000Z","updated":"2020-04-07T06:08:19.023Z","comments":true,"path":"2020/04/07/Node-js——Express和koa框架对比/","link":"","permalink":"http://delaprada.com/2020/04/07/Node-js%E2%80%94%E2%80%94Express%E5%92%8Ckoa%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/","excerpt":"","text":"此文参考：阿里技术协会《Node.js框架之express与koa对比分析》 https://yq.aliyun.com/articles/3062","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——事件循环","slug":"Node——事件循环","date":"2020-04-07T00:51:23.000Z","updated":"2020-04-07T02:23:07.020Z","comments":true,"path":"2020/04/07/Node——事件循环/","link":"","permalink":"http://delaprada.com/2020/04/07/Node%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"异步IO异步IO是指操作系统提供的IO（数据进出）能力，比如键盘输入，对应到显示器上会有专门的数据输出接口，这就是我们生活中可见的IO能力；这个接口在向下会进入到操作系统这个层面，在操作系统中，会提供诸多的能力，比如：磁盘的读写，DNS的查询，数据库的连接啊，网络请求的处理，等等。 在不同的操作系统层面，表现的不一致。有的是异步非阻塞的；有的是同步的阻塞的，无论如何，我们都可以看做是上层应用于下层系统之间的数据交互；上层依赖于下层，但是反过来，上层也可以对下层提供的这些能力进行改造。如果这种操作是异步的，非阻塞的，那么这种就是异步非阻塞的异步IO模型；如果是同步的阻塞的，那么就是同步IO模型。 koa就是一个上层的web服务框架，全部由JavaScript实现，他有操作系统之间的交互，全部通过nodejs来实现；如nodejs的 readFile就是一个异步非阻塞的接口，readFileSync就是一个同步阻塞接口。 事件循环事件循环是指Node.js执行非阻塞I/O操作，尽管JavaScript是单线程的,但由于大多数内核都是多线程的，node.js会尽可能将操作装载到系统内核。因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便node.js可以将相应的回调添加到轮询队列中以最终执行。 Node.js是单线程执行的，同时它又是基于事件驱动和非阻塞IO编程模型。这就使得我们不用等待异步操作结果返回，就可以继续往下执行代码。当异步事件触发之后，就会通知主线程，主线程执行相应事件的回调。 Node.js架构分析说道 Nodejs 架构, 首先要知道Nodejs 与 V8 和 libUV 的关系和作用: V8: 执行 JS 的引擎. 也就是翻译 JS. 包括我们熟悉的编译优化, 垃圾回收等等. libUV: 提供 async I/O, 提供消息循环. 可见, 是操作系统 API 层的一个抽象层. JavaScript引擎是一种专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器中。 V8：是Google开发的JavaScript引擎，用于Google Chrome和Chromium。V8能够即时编译JavaScript，使得JavaScript代码能够高效运行。 以往我们在执行c++的时候，会先进行编译工作，变为可执行文件后，再执行这个可执行文件。这个编译工作是由编译器完成的。 解释器就提供了一种边编译边运行的动态运行方法，而也正因为通过解释器运行的代码是边编译边运行的，所以运行的速度比静态编译的那种慢很多。 所以程序运行的方式分为静态编译和动态编译。 回到Node.js架构，Node.js如何组织它们呢？ Node.js通过一层C++ Binding，把JavaScript传给V8，V8解析后交给libUV发起异步IO，并等待消息循环调度。所以，Node.js实现异步机制的核心便是libUV。 Node.js启动过程可以分为以下步骤： 1、调用platformInit方法 ，初始化 nodejs 的运行环境。 2、调用 performance_node_start 方法，对 nodejs 进行性能统计。 3、openssl设置的判断。 4、调用v8_platform.Initialize，初始化 libuv 线程池。 5、调用 V8::Initialize，初始化 V8 环境。 6、创建一个nodejs运行实例。 7、启动上一步创建好的实例。 8、开始执行js文件，同步代码执行完毕后，进入事件循环。 9、在没有任何可监听的事件时，销毁 nodejs 实例，程序执行完毕。 以上是Node.js执行一个JavaScript文件的全过程，事件循环是在第八个步骤中。 Nodejs 完全是单线程的. 从进程启动后, 由主线程加载我们的 js 文件(下图中 main.js), 然后进入消息循环. 可见对于 js 程序而言, 完整运行在单线程之中。 事件循环Node.js中事件循环分为6个阶段： timers：执行setTimeout() 和 setInterval()中到期的回调。 I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行 idle, prepare：仅内部使用 poll：最为重要的阶段，执行I/O 回调，在适当的条件下会阻塞在这个阶段 check：执行setImmediate的回调 close callbacks：执行close事件的回调，例如socket.on(&quot;close&quot;,func) 重点关注timers、poll、check三个阶段 步骤： node的初始化 初始化node环境 执行同步任务（例如console.log） 执行process.nextTick回调 执行microtasks（Promise.then） 进入event-loop 进入timers阶段 检查timer队列是否有到期的timer回调，如果有，将到期的timer回调按照timerID升序执行 检查是否有process.nextTick任务，如果有，全部执行 检查是否有microtask，如果有，全部执行 退出该阶段 进入IO callback阶段 检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段。 检查是否有 process.nextTick 任务，如果有，全部执行。 检查是否有microtask，如果有，全部执行。 退出该阶段。 进入idle、prepare阶段： 这两个阶段与我们编程关系不大，暂且按下不表。 进入poll阶段 首先检查是否存在尚未完成的回调，如果存在，分两种情况： 如果有可用回调（可用回调包含：到期的定时器、一些IO事件等），执行所有可用回调。 检查是否有process.nextTick回调，如果有，全部执行 检查是否有 microtaks，如果有，全部执行。 退出该阶段。 如果没有可用回调 检查是否有setImmediate回调，如果有，退出poll阶段。如果没有，阻塞在此阶段，等待新的事件通知。 如果不存在尚未完成的回调，退出poll。 进入check阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 check 阶段 进入closing阶段 如果有immediate回调，则执行所有immediate回调。 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出 closing 阶段 在事件循环的每个子阶段退出之前都会按顺序执行如下过程： 检查是否有 process.nextTick 回调，如果有，全部执行。 检查是否有 microtaks，如果有，全部执行。 退出当前阶段。 常见问题process.nextTick和Promise这个队列先保证所有的 process.nextTick 回调, 然后将所有的 Promise 回调追加在后面. 最终在每个 Phase 结束的时候一次性拿出来执行。 setTimeout(..., 0)vs. setImmediate 到底谁快?1234// index.jssetImmediate(() =&gt; console.log(2))setTimeout(() =&gt; console.log(1),0) 答案：可能是1 2，也可能是2 1。 首先我们在初始化阶段会将setImmediate添加到check phase中，将setTimeout添加到timer phase中。 如果进入timer phase的时间 &gt; 消息循环保存的时间（即将以上两个回调添加到它们各自的phase的时间） 那在进入timer phase的时候setTimeout的回调已经在里面了，就可以立即执行，然后到check phase的时候再执行setImmediate的回调。此时输出1 2。 如果进入timer phase的时间 &lt; 消息循环保存的时间（即将以上两个回调添加到它们各自的phase的时间） 那在进入timer phase的时候setTimeout的回调还不在里面，那就会先执行check phase中的setImmediate，然后在下一轮循环中再执行timer phase中的setTimeout。此时输出2 1。 如果把代码改为如下，则一定会得到稳定输出： 12345require('fs').readFile('my-file-path.txt', () =&gt; &#123; setImmediate(() =&gt; console.log(2)) setTimeout(() =&gt; console.log(1))&#125;);// 2 1 因为消息在poll phase才会将setImmediate进入check phase，将setTimeout进入timer phase，那poll阶段后就回到check阶段，所以会输出2 1。 判断输出顺序12345678910111213141516171819setImmediate(() =&gt; &#123; console.log('setImmediate1'); setTimeout(() =&gt; &#123; console.log('setTimeout1') &#125;, 0);&#125;);Promise.resolve().then(res=&gt;&#123; console.log('then');&#125;)setTimeout(() =&gt; &#123; process.nextTick(() =&gt; &#123; console.log('nextTick'); &#125;); console.log('setTimeout2'); setImmediate(() =&gt; &#123; console.log('setImmediate2'); &#125;);&#125;, 0);//then setTimeout2 nextTick setImmediate1 setImmediate2 setTimeout1 step1：初始化阶段 setImmediate进入check phase、Promise.resolve().then进入微任务event queue、setTimeout进入timer phase。 没有process.nextTick 执行microtask，输出then 结束该阶段 step2：进入Timer phase（或者poll phase？） 执行setTimeout 执行console.log(&#39;setTimeout2&#39;)，输出setTimeout2 setImmediate进入check phase 有process.nextTick，输出nextTick step3：进入check phase 执行第一个setImmediate，输出setImmediate1，将setTimeout进入Timer phase 执行第二个setImmediate，输出setImmediate2 step4：下一个循环，进入Timer phase 执行setTimeout，输出setTimeout1 参考： https://juejin.im/post/5b61d8e3e51d45191d7a28a8 https://www.jianshu.com/p/906eafb41ea6","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Vue项目中如何用Node作后端代理获取接口数据","slug":"Vue项目中如何用Node作后端代理获取接口数据","date":"2020-04-06T02:12:17.000Z","updated":"2020-04-06T02:37:40.638Z","comments":true,"path":"2020/04/06/Vue项目中如何用Node作后端代理获取接口数据/","link":"","permalink":"http://delaprada.com/2020/04/06/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%A8Node%E4%BD%9C%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%90%86%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/","excerpt":"","text":"在做音乐APP项目的时候，发觉QQ音乐的有些接口是没有办法直接获取其中的数据的，因为它指定了请求的host和referer，所以我们需要用Node在其中做一层代理，去“欺骗”QQ，这样就能够获取数据。有点像跨域的思想，只不过跨域是用代理作为跳板，转发请求，不存在跨域问题；这里是用Node Server发起请求，将请求的referer和host改为接口允许访问的referer和host，来“欺骗”QQ。 怎么配置Node代理我们使用Vue.cli搭项目的脚手架的时候，build/webpack.dev.conf.js文件中有个devServer这里就可以用来配置。以前是有单独的文件dev-server.js，最新版本的Vue.cli放弃了这个。 首先要在devServer中添加before(app){}，将我们的操作放在before(app){}中。webpack 3 内置了 express，app 就是 express() 返回的对象。 123456789101112131415161718devServer: &#123; before(app)&#123; app.get('/api/getDiscList',function(req,res)&#123; const url='https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'; axios.get(url,&#123; headers:&#123; referer:'https://c.y.qq.com', host:'c.y.qq.com' &#125;, params:req.query &#125;).then((response)=&gt;&#123; res.json(response.data) &#125;).catch((e)=&gt;&#123; console.log(e); &#125;) &#125;)...&#125; 当Node服务器接收到来自/api/getDiscList的get请求时，就会执行后面的回调函数，用axios向QQ的URL发起请求，关键是要指定请求的头部headers，设定referer和host，这个referer和host是URL &lt;’https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg&#39;&gt; 允许访问的referer和host。 向Node代理服务器发起请求我们使用模块化开发的时候，就可以在方法当中使用axios向Node代理服务器发起请求，返回一个Promise对象。 1234567891011121314151617181920export function getDiscList()&#123; const url='/api/getDiscList'; const data=Object.assign(&#123;&#125;,commonParams,&#123; platform:'yqq', hostUin:0, sin:0, ein:29, sortId:5, needNewCode:0, categoryId:10000000, rnd:Math.random(), format:'json' &#125;) return axios.get(url,&#123; params:data &#125;).then((res)=&gt;&#123; return Promise.resolve(res.data); &#125;)&#125; 组件当中的设置首先是要导入方法： 1import &#123;getDiscList&#125; from 'api/recommend' 我们在created生命周期阶段执行方法： 1234created()&#123; this._getRecommend(); this._getDiscList();&#125; 获取到数据： 123456789methods:&#123; _getDiscList()&#123; getDiscList().then((res)=&gt;&#123; if(res.code===ERR_OK)&#123; console.log(res.data.list); &#125; &#125;) &#125;&#125; 执行npm run dev，可在控制台看到数据：","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——Connect和Express","slug":"Node——Connect和Express","date":"2020-04-05T06:03:20.000Z","updated":"2020-04-05T07:56:24.980Z","comments":true,"path":"2020/04/05/Node——Connect和Express/","link":"","permalink":"http://delaprada.com/2020/04/05/Node%E2%80%94%E2%80%94Connect%E5%92%8CExpress/","excerpt":"","text":"前言Connect和Express是两个热门的Node模块。Express就是在Connect的基础上，通过添加高层糖衣扩展和搭建出来的。 Connect创建简单的Connect程序指令： 1npm install connect@3.4.0 在要安装的模块后加@可以指定版本号 简单的Connect程序应该是这样的： 12345const app&#x3D;require(&#39;connect&#39;)();app.use((req,res,next)&#x3D;&gt;&#123; res.end(&#39;Hello, world!&#39;);&#125;);app.listen(3000); 这个程序会用Hello, World!做出响应。也就是访问http://localhost:3000的时候，页面显示Hello, world!。传给app.use的函数是个中间件，它以文本Hello, world!作为响应结束了请求处理过程。中间件是所有Connect和Express程序的基础。 Connect中间件的工作机制Connect中间件就是JavaScript函数。这个函数一般会有三个参数：请求对象、响应对象、以及一个名为next的回调函数。一个中间件完成自己的工作，要执行后续的中间件时，可以调用这个next回调函数。 在中间件运行之前，Connect会用分派器接管请求对象，然后交给程序中的第一个中间件。 借助中间件API，可以把一些小的构件块组合到一起，实现复杂的处理逻辑。 组合中间件Connect中的use方法就是用来组合中间件的。我们先来定义两个中间件函数，然后把它们都添加到程序中。 12345678910111213const connect=require('connect');function logger(req,res,next)&#123; console.log('%s %s', req.method, req.url); next();&#125;function hello(req,res)&#123; res.setHeader('Content-Type', 'text/plain'); res.end('hello world');&#125;connect() .use(logger) .use(hello) .listen(3000); 这两个中间件的名称签名不一样：一个有next，一个没有。因为后面这个中间件完成了HTTP响应，再也不需要把控制权交还给分派器了。 use()函数返回的是Connect程序的实例，支持方法链。也可以不写成链式调用的形式： 1234const app=connect();app.use(logger);app.use(hello);app.listen(3000); 需要注意的是，如果某个中间件不调用next()，那链在它后面的中间件就不会被调用。所以如果logger和hello两个函数的调用顺序反过来，则logger是不会执行的。 使用错误处理中间件Connect中有一种用来处理错误的中间件变体。跟常规的中间件相比，除了请求和响应对象外，错误处理中间件的参数中还多了一个错误对象。 1234567891011121314151617//Connect中的错误处理中间件const env=process.env.NODE_ENV||'development';function errorHandler(err,req,res,next)&#123; res.statusCode=500; switch(env)&#123; //开发模式和生产模式的响应不同 case 'development': console.error('Error:'); console.error(err); res.setHeader('Content-Type','application/json'); res.end(JSON.stringify(err)); break; default: res.end('Server error'); &#125;&#125;module.exports=errorHandler; 开发环境（development）：开发同学开发时使用的环境，每位开发同学在自己的dev分支上工作，开发到一定程度后，各位同学会合并代码，进行联调。 生产环境（production）：线上环境，用户使用的环境。由特定人员来维护。 设置环境变量 UNIX系统中设置环境变量的指令：$ NODE_ENV=production node app Windows中用这个： $ set NODE_ENV=production $ node app 产品在开发环境中运行时，你可能想要看到尽可能详细的日志；但在生产环境中，你可能想让日志尽量精简，可能还要用gzip进行压缩。 用NODE_ENV设定程序的模式，Connect一般会根据环境变量NODE_ENV(process.env.NODE_ENV)来切换不同服务器环境（比如生产环境和开发环境）下的行为。 当Connect遇到错误时，它会切换，只去调用错误处理中间件。 假设有一个允许用户登录到管理区域的博客程序。如果负责用户路由的中间件引发了一个错误，则中间件blog和admin都会被跳过，因为它们不是错误处理中间件（只有三个参数）。然后Connect看到接受错误参数的errorHandler，就会调用它。中间件看起来像下面这样： 12345connect() .use(router(require('./routes/user'))) .use(router(require('./routes/blog'))) //跳过 .use(router(require('./routes/admin'))) //跳过 .use(errorHandler); ExpressExpress是非常流行的Web框架，以前是在Connect的基础上搭建的。尽管提供了一些基本的功能，比如静态文件服务、URL路由和程序配置等，但它依然是极简的Web框架。 简单的Express程序 12345678const express=require('express');const app=express();app.get('/',(req,res)=&gt;&#123; res.send('Hello');&#125;);app.listen(3000); 生成程序框架安装指令： 1npm install -g express-generator 生成程序 用-e或（--ejs）指定要使用的模板引擎是EJS（EJS是一个嵌入JavaScript模板引擎，通过编译生成HTML代码）。执行express -e shoutbox，shoutbox是文件名。一个功能完备的程序会出现在shoutbox目录中。其中会有描述项目和依赖项的package.json文件、程序主文件、public目录，以及一个放路由处理器的目录。 Express路由入门根据官网定义： Routing refers to determining how an application responds to a client request to a particular endpoint, which is a URI (or path) and a specific HTTP request method (GET, POST, and so on). 路由的定义： 1app.METHOD(PATH, HANDLER) app是express的一个实例 METHOD是HTTP请求方法（小写） PATH是服务器上的路径 HANDLER是在这个路径上发起HTTP请求时执行的回调函数 Respond with Hello World! on the homepage: 123app.get('/', function (req, res) &#123; res.send('Hello World!')&#125;) Respond to POST request on the root route (/), the application’s home page: 123app.post('/', function (req, res) &#123; res.send('Got a POST request')&#125;) Respond to a PUT request to the /user route: 123app.put('/user', function (req, res) &#123; res.send('Got a PUT request at /user')&#125;) Respond to a DELETE request to the /user route: 123app.delete('/user', function (req, res) &#123; res.send('Got a DELETE request at /user')&#125;) 做个简单的留言板程序效果： 步骤： 创建消息模型 添加与消息相关的路由 创建消息表单 添加业务逻辑，用提交上来的表单数据创建消息 创建消息模型在创建消息模型之前，需要先安装Node redis模块。执行命令npm install --save redis。而且要安装Redis，Windows系统可以使用Redis Chocolately。 安装教程：https://www.cnblogs.com/julyluo/p/6646155.html 官网没有windows版本，github下载速度太慢。 Redis就是一个数据库，可以将我们post的留言存储起来。 创建保存在线留言板消息条目的模型。 创建models/entry.js文件： 12345678910111213141516171819202122232425262728293031323334353637383940'use strict';const redis = require('redis');const db = redis.createClient();class Entry &#123; constructor(obj) &#123; for (let key in obj) &#123; this[key] = obj[key]; &#125; &#125; static getRange(from, to, cb) &#123; db.lrange('entries', from, to, (err, items) =&gt; &#123; if (err) return cb(err); let entries = []; items.forEach((item) =&gt; &#123; entries.push(JSON.parse(item)); &#125;); cb(null, entries); &#125;); &#125; save(cb) &#123; const entryJSON = JSON.stringify(this); db.lpush( 'entries', entryJSON, (err) =&gt; &#123; if (err) return cb(err); cb(); &#125; ); &#125; static count(cb) &#123; db.llen('entries', cb); &#125;&#125;module.exports = Entry; 创建消息表单 在app.js中添加如下路由部分 12app.get('/post', entries.form);app.post('/post', entries.submit); 即：使用get向/post发起http请求时，执行entries.form回调函数。使用post向/post发起http请求时，执行entries.submit回调。 这个`entries`是从`routes`中导入的模块。看一下定义： 表单模块部分： 1234//routes/entries.jsexports.form = (req, res) =&gt; &#123; res.render('post', &#123; title: 'Post' &#125;);&#125;; 这里是用views/post.ejs，即表单，去渲染页面。 123456789101112131415161718192021222324&#x2F;&#x2F;views&#x2F;post.ejs&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt; &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;h1&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h1&gt; &lt;p&gt;Fill in the form below to add a new post.&lt;&#x2F;p&gt; &lt;form action&#x3D;&#39;&#x2F;post&#39; method&#x3D;&#39;post&#39;&gt; &lt;p&gt; &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;entry[title]&#39; placeholder&#x3D;&#39;Title&#39; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;p&gt; &lt;textarea name&#x3D;&#39;entry[body]&#39; placeholder&#x3D;&#39;Body&#39;&gt;&lt;&#x2F;textarea&gt; &lt;&#x2F;p&gt; &lt;p&gt; &lt;input type&#x3D;&#39;submit&#39; value&#x3D;&#39;Post&#39; &#x2F;&gt; &lt;&#x2F;p&gt; &lt;&#x2F;form&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 表单中用了形如entry[title]之类的输入控件名称，需要用扩展的消息体解析器来解析。找到app.js将 1app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); 改为： 1app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); 实现消息提交功能 123456789101112131415//将代码添加到文件routes/entries.js中，实现用表单提交上来的数据创建消息exports.submit = (req, res, next) =&gt; &#123; const data = req.body.entry; const user = res.locals.user; const username = user ? user.name : null; const entry = new Entry(&#123; username: username, title: data.title, body: data.body &#125;); entry.save((err) =&gt; &#123; if (err) return next(err); res.redirect('/'); &#125;);&#125;; 这里使用了Common JS进行模块化开发 添加显示消息的首页 在routes/entries.js中添加： 123456789101112const Entry = require('../models/entry');exports.list = (req, res, next) =&gt; &#123; const page = req.page; Entry.getRange(0, -1, (err, entries) =&gt; &#123; if (err) return next(err); res.render('entries', &#123; title: 'Entries', entries: entries &#125;); &#125;);&#125;; 视图entries.ejs 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;title&gt; &lt;link rel&#x3D;&#39;stylesheet&#39; href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39; &#x2F;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;% include menu %&gt; &lt;% entries.forEach((entry) &#x3D;&gt; &#123; %&gt; &lt;div class&#x3D;&#39;entry&#39;&gt; &lt;h3&gt;&lt;%&#x3D; entry.title %&gt;&lt;&#x2F;h3&gt; &lt;p&gt;&lt;%&#x3D; entry.body %&gt;&lt;&#x2F;p&gt; &lt;p&gt;Posted by &lt;%&#x3D; entry.username %&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;% &#125;) %&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 在程序运行之前先在同一目录下创建menu.ejs创建菜单模板文件，后续会用到。目前空白着先。 添加与消息相关的路由 在app.js中： 1const entries = require('./routes/entries'); 添加路由： 1app.get('/', entries.list); 运行程序 先以管理员身份进入CMD，运行redis-server启用Redis。 在terminal中运行npm start，访问http://localhost:3000/post 点击post后跳转到首页： 完成。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——Gulp基于流的自动化构建工具","slug":"Node——Gulp基于流的自动化构建工具","date":"2020-04-03T02:59:55.000Z","updated":"2020-04-03T04:01:47.163Z","comments":true,"path":"2020/04/03/Node——Gulp基于流的自动化构建工具/","link":"","permalink":"http://delaprada.com/2020/04/03/Node%E2%80%94%E2%80%94Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/","excerpt":"","text":"用Gulp实现自动化Gulp是基于流的构建系统。我们可以通过对这些流的引导来创建构建过程，除了转译和缩码，还能做很多事情。 Gulp之所以能实现高度重用，主要归功于两项技术：使用插件和自定义构建任务。Gulp的构建过程是一个流，所以这些任务和插件是可以一个接一个拼在一起的。 把Gulp添加到项目中添加Gulp需要用npm安装gulp-cli和gulp两个包。下面这段代码中，全局安装gulp-cli，并创建一个带有Gulp开发依赖项的新Node项目。 123npm i --global gulp-clinpm init -ynpm i -save-dev gulp 接着创建gulpfile.js 1touch gulpfile.js touch为linux指令 现在用Gulp构建一个小型的React项目。这里会用到gulp-babel、gulp-sourcemaps和gulp-concat： 12npm i --save-dev gulp-sourcemaps gulp-babel babel-preset-es2015npm i --save-dev gulp-concat react react-dom babel-preset-react 这里要注意的是，安装gulp-babel的时候要安装7版本的，后续还要安装babel-core。如果直接安装，是安装8版本，babel-core是7，就会出错。 Gulp任务的创建及运行创建Gulp任务需要在gulpfile.js中编写Node代码，调用Gulp的API。Gulp的API可以做很多事情，比如查找文件，把对文件进行某种转换的插件拼到一起等。 打开gulpfile.js设置一个构建任务，用gulp.src查找JSX文件，用Babel处理ES6和React，然后把这些文件拼到一起。 gulpfile.js 123456789101112131415const gulp=require('gulp');const sourcemaps=require('gulp-sourcemaps');const babel=require('gulp-babel');const concat=require('gulp-concat');gulp.task('default',()=&gt;&#123; return gulp.src('app/*.jsx') .pipe(sourcemaps.init()) .pipe(babel(&#123; presets:['es2015','react'] &#125;)) .pipe(concat('all.js')) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('dist'));&#125;) gulp.src：Gulp自带的文件聚集工具，查找所有的React jsx文件 sourcemaps.init()：开始监视源文件，为调试构建源码映射 concat(&#39;all.js&#39;)：把所有源码文件拼到一个all.js中 soucemaps.write(&#39;.&#39;)：单独写入源码映射文件 gulp.dest(&#39;dist&#39;)：将所有文件放到dist/目录下 创建一个名为app/index.jsx的文件，就可以试验一下Gulp了。可以用下面这段JSX代码： 1234567import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello,world!&lt;/h1&gt;, document.getElementById('example')) 在终端运行gulp： 123[10:21:44] Using gulpfile ~\\Desktop\\大三\\实习\\笔记\\Node.js\\gulp_test\\gulpfile.js[10:21:44] Starting &#39;default&#39;...[10:21:44] Finished &#39;default&#39; after 213 ms 目录： 打包生成的all.js： 123456789101112131415161718'use strict';var _react = require('react');var _react2 = _interopRequireDefault(_react);var _reactDom = require('react-dom');var _reactDom2 = _interopRequireDefault(_reactDom);function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;_reactDom2.default.render(_react2.default.createElement( 'h1', null, 'Hello,world'), document.getElementById('example'));//# sourceMappingURL=all.js.map 总结在Gulp中，用JavaScript表示构建阶段很容易。并且我们可以用gulp.task()往这个文件里添加自己的任务。这些任务通常都遵循相同的模式。 源文件：收集输入文件 转译：让它们依次通过一个个对它们进行转换的插件 合并：把这些文件合到一起，创建一个整体构建文件 输出：设定文件的目标地址或移动输出文件 在前面那个例子中，sourcemaps是个特例，因为它需要两次pipe：第一次是配置，最后一次是输出文件。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"Node——串行化/并行化流程控制","slug":"Node——串行化-并行化流程控制","date":"2020-04-01T03:15:11.000Z","updated":"2020-04-01T04:05:56.067Z","comments":true,"path":"2020/04/01/Node——串行化-并行化流程控制/","link":"","permalink":"http://delaprada.com/2020/04/01/Node%E2%80%94%E2%80%94%E4%B8%B2%E8%A1%8C%E5%8C%96-%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"异步逻辑的顺序化在异步程序的执行过程中，有些任务可能会随时发生，跟程序中的其他部分在做什么没关系，什么时候做这些任务都不会出问题。但有些任务只能在某些特定的任务之前或之后做。 让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类：串行和并行。 串行任务：需要一个接着一个执行的任务 并行任务：不需要一个接着一个执行的任务。这些任务彼此之间开始和结束时间并不重要，但在后续逻辑执行前它们应该全部执行完成。 实现串行化流程控制为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放到一个数组中。这个数组起到队列的作用：完成一个任务后按顺序从数组中取出下一个。 实例做一个小程序，让它从一个随机选择的RSS预订源中获取一篇文章的标题和URL，并显示出来。RSS预订源列表放在一个文本文件中。 例如： 123&#x2F;&#x2F;rss_feeds.txthttp:&#x2F;&#x2F;www.read.org.cn&#x2F;feedhttps:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;feed&#x2F;blog.xml 这个rss_feeds.txt放在文件夹sequence中。 从npm存储库中下载两个辅助模块。在sequence文件目录下，terminal中输入： 123npm init -ynpm install --save request@2.60.0npm install --save htmlparser@1.7.7 request模块是个经过简化的HTTP客户端，你可以用它获取RSS数据。htmlparser模块能把原始的RSS数据转换成JavaScript数据结构。 然后再目录下创建index.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const fs=require('fs');const request=require('request');const htmlparser=require('htmlparser');const configFilename='./rss_feeds.txt';//确保包含RSS预订源URL列表的文件存在function checkForRSSFile()&#123; fs.exists(configFilename,(exists)=&gt;&#123; if(!exists)&#123; return next(new Error(`Missing RSS file:$&#123;configFilename&#125;`)); &#125; next(null,configFilename); &#125;)&#125;//读取并解析包含预订源URL的文件function readRSSFile(configFilename)&#123; fs.readFile(configFilename,(err,feedList)=&gt;&#123; if(err)&#123; return next(err); &#125; feedList=feedList.toString().replace(/^\\s+|\\s+$/g,'').split('\\n'); //从预订源URL数组中随机选择一个预订源URL const random=Math.floor(Math.random()*feedList.length); next(null,feedList[random]); &#125;)&#125;//向选定的预订源发送HTTP请求以获取数据function downloadRSSFeed(feedUrl)&#123; request(&#123;uri:feedUrl&#125;,(err,res,body)=&gt;&#123; if(err) return next(err); if(res.statusCode!==200)&#123; return next(new Error('Abnormal response status code')); &#125; next(null,body); &#125;)&#125;//将预订源数据解析到一个条目数组中function parseRSSFeed(rss)&#123; const handler=new htmlparser.RssHandler(); const parser=new htmlparser.Parser(handler); parser.parseComplete(rss); if(!handler.dom.items.length)&#123; return next(new Error('No RSS items found')); &#125; const item=handler.dom.items.shift(); //如果有数据，显示第一个预订源条目的标题和URL console.log(item.title); console.log(item.link);&#125;//把所有要做的任务按执行顺序添加到一个数组中const tasks=[ checkForRSSFile, readRSSFile, downloadRSSFeed, parseRSSFeed];//负责执行任务的next函数function next(err,result)&#123; if(err)&#123; throw err; &#125; const currentTask=tasks.shift(); //从任务数组中取出下个任务 if(currentTask)&#123; currentTask(result); &#125;&#125;next(); //开始执行 串行化执行的实现是通过一个数组tasks去承载要执行的任务。首先通过tasks.shift()方法从tasks数组中取出第一个任务checkForRSSFile，在执行这个任务的时候，它内部又调用了next方法，使得我们能够执行下一个任务，以此类推。这个负责执行任务的next函数会多次执行。 执行node index.js，输出结果： 12《聪明人用方格笔记术》“黄金三分法”http:&#x2F;&#x2F;www.read.org.cn&#x2F;html&#x2F;2438-cong-ming-ren-yong-fang-ge-bi-ji-shu-huang-jin-san-fen-fa.html 实现并行化流程控制为了让异步任务并行执行，仍然是要把任务放在数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续逻辑。 这里的例子就做一个简单的程序，读取几个文本文件的内容，并输出单词在整个文件中出现的次数。我们会用异步的readFile函数读取文本文件的内容，所以几个文件的读取可以并行执行。 这是目录组成： 1.txt： 1do you love me 2.txt： 1yes i do love you word_count.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const fs=require('fs');const tasks=[];const wordCounts=&#123;&#125;;const filesDir='../text';let completedTasks=0;function checkIfComplete()&#123; completedTasks++; if(completedTasks===tasks.length)&#123; for(let index in wordCounts)&#123; console.log(`$&#123;index&#125;:$&#123;wordCounts[index]&#125;`); &#125; &#125;&#125;function addWordCount(word)&#123; wordCounts[word]=(wordCounts[word])?wordCounts[word]+1:1;&#125;function countWordsInText(text)&#123; const words=text.toString().toLowerCase().split(/\\W+/).sort(); words.filter(word=&gt;word).forEach(word=&gt;addWordCount(word));&#125;fs.readdir(filesDir,(err,files)=&gt;&#123; if(err)&#123; throw err; &#125; files.forEach(file=&gt;&#123; //task函数声明，是立即执行的，获取filename const task=(file=&gt;&#123; return ()=&gt;&#123; fs.readFile(file,(err,text)=&gt;&#123; if(err)&#123; throw err; &#125; countWordsInText(text); checkIfComplete(); &#125;) &#125; &#125;)(`$&#123;filesDir&#125;/$&#123;file&#125;`); //将当前tast push到tasks数组中 tasks.push(task); &#125;) //开始并行执行所有任务 tasks.forEach(task=&gt;task());&#125;) 执行node word_count.js： 123456do:2i:1love:2yes:1you:2me:1","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://delaprada.com/tags/Node-js/"}]},{"title":"虚拟DOM","slug":"虚拟DOM","date":"2020-03-31T08:37:58.000Z","updated":"2020-03-31T09:24:53.071Z","comments":true,"path":"2020/03/31/虚拟DOM/","link":"","permalink":"http://delaprada.com/2020/03/31/%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"昨天面试的时候，面试官问到虚拟DOM的原理，被问到的时候，就把自己之前的理解说了一通，因为之前面试的时候也被问到过，觉得应该没问题。后来面试官质问了一下：“虚拟DOM最终也是使用DOM API去操作DOM，它的性能就一定会更好么 ? ” 然后就懵了….后来在网上搜了些资料，又有了些新的见解。 虚拟DOM的含义虚拟DOM是使用JS去模拟真实的DOM。DOM树上的结构、属性信息我们都可以使用JavaScript对象表示出来： 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 1\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 2\"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: [\"Item 3\"]&#125;, ]&#125; 上面对应的HTML写法是： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 用JS操作真实DOM的操作：状态变更-&gt;重新渲染整个视图的方式，可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：虚拟DOM是局部更新的。虽然视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方，减少了不必要的调用DOM API去操作DOM的操作。 算法实现步骤一：用JS对象模拟真实DOM用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js 123456789function Element (tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children&#125;module.exports = function (tagName, props, children) &#123; return new Element(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element') //模块化导入Element函数var ul = el('ul', &#123;id: 'list'&#125;, [ el('li', &#123;class: 'item'&#125;, ['Item 1']), el('li', &#123;class: 'item'&#125;, ['Item 2']), el('li', &#123;class: 'item'&#125;, ['Item 3'])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的&lt;ul&gt;： 1234567891011121314151617181920Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) &#123; // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的&lt;ul&gt;的DOM结构： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 步骤二：比较两棵虚拟DOM树的差异当我们要做出修改的时候，首先是要创建一个新的结点，然后使用diff算法去对比新旧节点的不同，这种对比只会在同层级进行，不会跨层进行，此处是使用深度优先遍历算法，然后将差异记录在patches对象当中。 同层级比较的话算法复杂度更低，降到O(n)。 深度优先遍历，记录差异： 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 1234567891011121314151617181920212223242526272829// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是0，那么： 1patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 差异类型： 上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;] 如果给div新增了属性id为container，就记录下： 123456789patches[0] &#x3D; [&#123; type: REPALCE, node: newNode &#x2F;&#x2F; el(&#39;section&#39;, props, children)&#125;, &#123; type: PROPS, props: &#123; id: &quot;container&quot; &#125;&#125;] 如果是文本节点，如上面的文本节点2，就记录下： 1234patches[2] = [&#123; type: TEXT, content: \"Virtual DOM2\"&#125;] 那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这就涉及到两个列表的对比算法，其实可以抽象出来是最小编辑距离问题（动态规划思想）。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： 1234patches[0] = [&#123; type: REORDER, moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]&#125;] 步骤三：把差异应用到真正的DOM树上因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。 使用patch方法将对象patches当中记录的更改应用到真实DOM上。 123456789101112131415161718192021function patch (node, patches) &#123; var walker = &#123;index: 0&#125; dfsWalk(node, walker, patches)&#125;function dfsWalk (node, walker, patches) &#123; var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i &lt; len; i++) &#123; // 深度遍历子节点 var child = node.childNodes[i] walker.index++ dfsWalk(child, walker, patches) &#125; if (currentPatches) &#123; applyPatches(node, currentPatches) // 对当前节点进行DOM操作 &#125;&#125; applyPatches，根据不同类型的差异对当前节点进行 DOM 操作： 1234567891011121314151617181920function applyPatches (node, currentPatches) &#123; currentPatches.forEach(function (currentPatch) &#123; switch (currentPatch.type) &#123; case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) &#125; &#125;)&#125; 总结虚拟DOM的优缺点优点： 很多 DOM API 的读写都涉及页面布局的“重新计算”，以确保返回值的准确，涉及样式、结构的还会触发页面“重新绘制”，更耗性能。 综上，单次 DOM API 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。 虚拟DOM实际上最终还是会调用DOM API，但它能够减少不必要的DOM API调用。虚拟DOM遵循“在JS中缓存必要数据，计算界面更新时的阶段数据差异，只提交最终差集”的基本思路。 缺点： 使用JS去模拟真实DOM，会占用一定内存 diff算法，有计算方面的额外开销 参考： &lt;https://www.zhihu.com/search?type=content&amp;q=%E8%99%9A%E6%8B%9Fdom&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"使用JSONP实现跨域","slug":"使用JSONP实现跨域","date":"2020-03-29T07:23:53.000Z","updated":"2020-03-30T07:11:36.322Z","comments":true,"path":"2020/03/29/使用JSONP实现跨域/","link":"","permalink":"http://delaprada.com/2020/03/29/%E4%BD%BF%E7%94%A8JSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"同源策略 同源策略是浏览器的一个安全功能 同源指的是：协议，域名，端口号都相同 同源策略规定：不同源的客户端脚本（在没有明确授权的情况下）不能读写对方的资源 同源策略限制的内容有： cookie、localStorage等存储性内容 DOM节点 AJAX请求发送后，非同源会被浏览器拦截 但是有三个标签时允许跨域加载资源的： &lt;img src=XXX&gt; &lt;link href=XXX&gt; &lt;script src=XXX&gt; 这就是JSONP的来源 JSONP实现跨域基本思想：网页通过添加一个&lt;script&gt;元素（因为src属性），向服务器请求json数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。但只支持GET请求。 实践代码： 创建一个JSONP文件夹，在其中添加template.html以及server.js。 template.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;jsonp testing&lt;/p&gt;&lt;/body&gt;&lt;script&gt; function jsonp(&#123;url,params,callback&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let script=document.createElement('script'); params=JSON.parse(JSON.stringify(params)); let arrs=[]; for(let key in params)&#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; arrs.push(`callback=$&#123;callback&#125;`); script.src=`$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;`; document.body.appendChild(script); window[callback]=function(data)&#123; resolve(data); document.body.removeChild(script); &#125; &#125;) &#125; jsonp(&#123; url:'http://localhost:3000/say', params:&#123; wd:'I love you' &#125;, callback:'show' &#125;).then(data=&gt;&#123; console.log(data); &#125;)&lt;/script&gt;&lt;/html&gt; server.js 123456789101112131415161718var express = require('express');var router = express.Router();var app = express();router.get('/say',function(req,res,next) &#123; //要响应回去的数据 let data = &#123; username : 'zs', password : 123456 &#125; let &#123;wd , callback&#125; = req.query; console.log(wd); console.log(callback); // 调用回调函数 , 并响应 res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`);&#125;)app.use(router);app.listen(3000); 上述代码实现的就是我们的html文档，使用jsonp方法向http://localhost:3000/say发起请求。当服务器监听到请求之后，将响应的数据放在指定名字的回调函数中传回来，然后调用callback回调函数执行resolve(data)。因为jsonp函数返回的是一个Promise对象，所以之后可以调用.then执行后续的console.log操作。 结果： 如果是AJAX请求： 12345678var xhr=new XMLHttpRequest();xhr.onReadyStateChange=function()&#123; if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; alert(xhr.responseText); &#125;&#125;xhr.open('get','http://localhost:3000/say',true);xhr.send(); 就会报跨域的错误：","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"乱序数组的三种方法","slug":"乱序数组的三种方法","date":"2020-03-28T05:27:18.000Z","updated":"2020-03-30T01:49:58.115Z","comments":true,"path":"2020/03/28/乱序数组的三种方法/","link":"","permalink":"http://delaprada.com/2020/03/28/%E4%B9%B1%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"今天面试的时候被问到实现乱序数组的最简便的方法，自己只知道使用Math.random()和结果数组的笨方法…总结一下。 sort()方法数组的sort()方法是按照return的值的正负来去做排序判定，所以实现的思路可以是使得返回的值随机正负。 12345function randArr(arr)&#123; return arr.sort(()=&gt;&#123; return (Math.random()-0.5); &#125;)&#125; Math.random()是生成0.0（包含）~1.0（不包含）之间的随机数。 但这么做是一个伪排序。参考：https://zhuanlan.zhihu.com/p/33260052 有大神做过测试，进行10000次乱序操作后，元素大概率停留在自己的初始位置上。 洗牌算法思路是： 找到数组的最后一个元素 从数组开头到最后一个元素之间，找到随机的一个数 交换两个元素的位置 此时最后一个元素已经是乱序后的结果 指向最后一个元素的索引前移 直到指向索引为0 1234567891011//洗牌算法function randArr3(arr)&#123; var length=arr.length; var r=length; var rand=0; while(r)&#123; rand=Math.floor(Math.random()*(r--)); [arr[r],arr[rand]]=[arr[rand],arr[r]]; &#125; return arr;&#125; Math.random()+结果数组12345678910function randArr2(arr)&#123; var res=[]; var len=arr.length; for(var i=0;i&lt;len;++i)&#123; var index=Math.floor(Math.random()*arr.length); res.push(arr[index]); arr.splice(index,1); &#125; return res;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"每日一题——单词的压缩编码","slug":"每日一题——单词的压缩编码","date":"2020-03-28T01:18:31.000Z","updated":"2020-03-28T01:25:53.258Z","comments":true,"path":"2020/03/28/每日一题——单词的压缩编码/","link":"","permalink":"http://delaprada.com/2020/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/","excerpt":"","text":"单词的压缩编码给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。 例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。 对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。 那么成功对给定单词列表进行编码的最小字符串长度是多少呢？ 示例： 123输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]输出: 10说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。 提示： 1231 &lt;&#x3D; words.length &lt;&#x3D; 20001 &lt;&#x3D; words[i].length &lt;&#x3D; 7每个单词都是小写字母 。 思路： 首先要先读懂题意，如果是单词之间的覆盖，只能是后缀覆盖，而不能是中间覆盖；其次，不一定是相邻的单词之间会出现覆盖，有可能像[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;, &quot;atime&quot;]跨着来覆盖。 所以我们先按单词的长度进行降序排列，这样先将最大的添加到结果字符串中，后续判断较小的单词只需要使用indexOf方法，就能够判断是否在结果字符串中。 需要注意的是，单词之间的覆盖只能是后缀覆盖，所以使用indexOf判断的时候要加上“#”。 题解： 123456789101112131415161718/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var minimumLengthEncoding = function(words) &#123; words.sort(function(a,b)&#123; return b.length-a.length; &#125;) var res=\"\"; res+=words[0]+\"#\"; for(var i=1;i&lt;words.length;++i)&#123; //加上#号就控制必须是后缀部分 if(res.indexOf(words[i]+\"#\")===-1)&#123; res+=words[i]+\"#\"; &#125; &#125; return res.length;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——合并区间","slug":"每日一题——合并区间","date":"2020-03-26T07:16:28.000Z","updated":"2020-03-26T07:22:58.815Z","comments":true,"path":"2020/03/26/每日一题——合并区间/","link":"","permalink":"http://delaprada.com/2020/03/26/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","excerpt":"","text":"合并区间给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路： 将每个区间的第一个数字放入start数组中，将每个区间的第二个数字放入end数组中，对start数组和end数组进行排序。判断start[i+1]和end[i]的大小，如果前者小，则说明区间有覆盖，i++；如果前者大，说明区间没有覆盖，可以将这个结果push进结果数组res中，同时j=i+1（j最开始为0）。 题解： 123456789101112131415161718192021222324252627282930/** * @param &#123;number[][]&#125; intervals * @return &#123;number[][]&#125; */var merge = function(intervals) &#123; var start=[]; var end=[]; var res=[]; for(var i=0;i&lt;intervals.length;++i)&#123; start.push(intervals[i][0]); end.push(intervals[i][1]); &#125; start.sort(function(a,b)&#123; return a-b; &#125;) end.sort(function(a,b)&#123; return a-b; &#125;) for(var n=0,m=0;n&lt;intervals.length;++n)&#123; if(n==intervals.length-1||start[n+1]&gt;end[n])&#123; res.push([start[m],end[n]]); m=n+1; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——编辑距离","slug":"每日一题——编辑距离","date":"2020-03-25T02:15:59.000Z","updated":"2020-03-25T02:44:32.174Z","comments":true,"path":"2020/03/25/每日一题——编辑距离/","link":"","permalink":"http://delaprada.com/2020/03/25/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","excerpt":"","text":"编辑距离给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符 示例 1: 123456输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 示例 2: 12345678输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;) 思路： 动态规划的思想。 如果word1[i]===word2[j]，dp[i][j]=dp[i-1][j-1]，也就是说word1的第i个单词和word2的第j个单词相同的话，那word1前i个单词要变为word2前j个单词的编辑次数就会等于word1前i-1和单词变为word2前j-1个单词的编辑次数。 如果word1[i]!=word2[j]，那dp[i][j]=Math.min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1 dp[i-1][j-1]表示替换操作，也就是将word1[i]替换为word2[j]，那dp[i][j]就等于dp[i-1][j-1]+1，也就是将word1前i-1个单词变为word2前j-1个单词所要执行的编辑次数+1（一次替换操作）。 dp[i-1][j]表示删除操作，就是将word1前i-1个字符变为word2前j个字符所要执行的操作+1（一次删除操作，即将word1的第i个字符删掉） dp[i][j-1]表示插入操作，就是将word1前i个字符变为word2前j-1个字符所要执行的操作+1（一次插入操作，在word1插入一个和word2第j个字符一样的字符） 题解： 12345678910111213141516171819202122232425262728293031/** * @param &#123;string&#125; word1 * @param &#123;string&#125; word2 * @return &#123;number&#125; */var minDistance = function(word1, word2) &#123; var dp=[]; var len1=word1.length; var len2=word2.length; for(var i=0;i&lt;=len1;++i)&#123; dp[i]=new Array(); &#125; for(var j=0;j&lt;=len1;++j)&#123; dp[j][0]=j; &#125; for(var k=0;k&lt;=len2;++k)&#123; dp[0][k]=k; &#125; for(var n=1;n&lt;=len1;++n)&#123; for(var m=1;m&lt;=len2;++m)&#123; //这里表示的是word1[n]==word2[m],但是因为n和m是从1开始取的,所以比较的时候要-1 if(word1[n-1]==word2[m-1])&#123; dp[n][m]=dp[n-1][m-1]; &#125; else&#123; dp[n][m]=Math.min(dp[n-1][m-1],dp[n][m-1],dp[n-1][m])+1; &#125; &#125; &#125; return dp[len1][len2];&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——按摩师","slug":"每日一题——按摩师","date":"2020-03-24T08:57:23.000Z","updated":"2020-03-24T08:58:20.779Z","comments":true,"path":"2020/03/24/每日一题——按摩师/","link":"","permalink":"http://delaprada.com/2020/03/24/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%8C%89%E6%91%A9%E5%B8%88/","excerpt":"","text":"面试题 17.16. 按摩师一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1： 123输入： [1,2,3,1]输出： 4解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。 示例 2： 123输入： [2,7,9,3,1]输出： 12解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。 示例 3： 123输入： [2,1,4,5,3,1,1,3]输出： 12解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。 思路： 动态规划的思想。但是这题和最大上升子序列的动态规划思想不同。这题与背包问题都是要求一个对于整体来说最大的和，但是最大上升子序列是求一个最长的上升子序列，之前的数要比当前的数小才能做一次计算，和是否相邻无关，所以最大上升子序列还需要在内层加多一层循环。 题解： 最初想的方案： 内层多了一个循环。 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var massage = function(nums) &#123; var F=[]; if(nums.length==1)&#123; return nums[0]; &#125; for(var m=0;m&lt;nums.length;++m)&#123; F[m]=0; &#125; F[0]=nums[0]; F[1]=nums[1]; for(var i=2;i&lt;nums.length;++i)&#123; for(var j=0;j&lt;=i-2;++j)&#123; F[i]=Math.max(F[j]+nums[i],F[i]); &#125; &#125; var max=0; for(var t=0;t&lt;F.length;++t)&#123; if(F[t]&gt;max)&#123; max=F[t]; &#125; &#125; return max;&#125;; 后来看评论优化的题解： dp思想：F[i]=Math.max(F[i-1],F[i-2]+nums[i]); 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var massage = function(nums) &#123; var F=[]; if(nums.length==0)&#123; return 0; &#125; if(nums.length==1)&#123; return nums[0]; &#125; for(var m=0;m&lt;nums.length;++m)&#123; F[m]=0; &#125; F[0]=nums[0]; F[1]=Math.max(nums[0],nums[1]); for(var i=2;i&lt;nums.length;++i)&#123; F[i]=Math.max(F[i-1],F[i-2]+nums[i]); &#125; return F[nums.length-1];&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"由instanceof原生实现理解__proto__和prototype的区别","slug":"由instanceof原生实现理解-proto-和prototype的区别","date":"2020-03-24T08:04:15.000Z","updated":"2020-03-24T08:55:41.494Z","comments":true,"path":"2020/03/24/由instanceof原生实现理解-proto-和prototype的区别/","link":"","permalink":"http://delaprada.com/2020/03/24/%E7%94%B1instanceof%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-proto-%E5%92%8Cprototype%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"前几天面试的时候被问到instanceof的原生实现，当时对__proto__和prototype的区别理解不是很透彻，一直记得的是几个月前在网上的某篇博客上看到的结论：“__proto__：和prototype其实是一个东西，prototype是官方所定义的属性，__proto__是浏览器自己对prototype所做的实现。”后来仔细再查了些文章发现似乎并不是这样。 __proto__和prototype的区别原型prototype原型的定义：每个js对象（除了null）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。 比如我们定义一个构造函数Person： 123function Person(name)&#123; this.name=name;&#125; 这样我们就创建了一个对象（function也是对象），那这个Person构造函数是有它的prototype的。这个Person prototype的构造函数constructor就是这个Person构造函数。我们还可以在这个Person prototype上去定义一些共享的属性和方法。 1234567function Person(name)&#123; this.name=name;&#125;Person.prototype.name=\"Alice\";Person.prototype.sayHello=function()&#123; console.log(\"Hello \"+this.name);&#125; 这样写就在Person prototype上定义了公用的属性name和sayHello。 现在创建两个对象实例： 12345var person1=new Person();var person2=new Person();person1.name=\"Emma\";console.log(person1.name); //Emmaconsole.log(person2.name); //Alice 我们为这个person1定义了它的实例属性name为”Emma”，那person2没有定义它的实例属性，所以它会沿着原型链去找它的原型去找是否有这个属性，因为Person.prototype里定义了name属性，所以输出Alice。 如果Person.prototype中没有定义name属性，那person2.name输出的是undefined，构造函数里的this.name是不起作用的。 __proto__ 以上这幅图大致可以说明__proto__和prototype的关系。 现在来说一下我们使用new去创建一个构造函数实例的时候做了些什么： new的原生实现： 123456function new(Parent,...args)&#123; var obj=&#123;&#125;; obj.__proto__=Parent.prototype; var res=Parent.apply(obj,args); return typeof res==\"object\"?res:obj;&#125; 我们使用new创建一个实例的时候，我们将这个实例的__proto__指向构造函数的原型。 __proto__和prototype并不是一样的： constructor1234function Person()&#123;&#125;Person.prototype.constructor===Person; //true 这个由上图可以看出。 12345function Person()&#123;&#125;var person1=new Person();person1.constructor===Person; //true 但是person1是没有constructor属性的，而是通过原型链去找到Person.prototype上的constructor属性。 Object.prototypeObject.prototype是没有原型的，Object.prototype就是尽头。 instanceof的原生实现instanceof在MDN当中的定义就是object instanceof constructor，判断这个constructor的prototype是否在object的原型链上。object原型链上的原型我们可以通过__proto__来去获取。 12345678910111213function myinstanceof(left,right)&#123; var leftval=left.__proto__; //实例用__proto__ var rightval=right.prototype; //构造函数用prototype while(true)&#123; if(leftval==null)&#123; return false; //Object.prototype.__proto__为null &#125; if(leftval==rightval)&#123; return true; &#125; leftval=leftval.__proto__; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Promise实现任务顺序执行&并行执行&发起ajax请求","slug":"Promise实现任务顺序执行和并行执行","date":"2020-03-21T13:46:14.000Z","updated":"2020-03-24T01:17:01.763Z","comments":true,"path":"2020/03/21/Promise实现任务顺序执行和并行执行/","link":"","permalink":"http://delaprada.com/2020/03/21/Promise%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C/","excerpt":"","text":"Promise实现任务并行执行使用Promise.all方法： 123456789101112var p1=new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;)p1.then(result=&gt;result);var p2=new Promise((resolve,reject)=&gt;&#123; resolve('hi');&#125;)p1.then(result=&gt;result);var p=Promise.all([p1,p2]);p.then(result=&gt;console.log(result)); Promise实现任务顺序执行在.then里要return一个new Promise，这样后续才能继续使用.then执行后续操作： 1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) 输出： Promise封装ajax请求123456789101112131415161718192021222324252627282930function myHttpClient(method,url,data)&#123; return new Promise(function(resolve,reject)&#123; var xhr; if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125; else&#123; xhr=new ActiveXObject('Microsoft XMLHttp'); &#125; var method=method||'GET'; var data=data||null; xhr.open(method,url,true); xhr.onReadyStateChange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;=300)||xhr.status==304)&#123; resolve(xhr.responseText); &#125; else&#123; reject(new Error(xhr.statusText)); &#125; &#125; &#125; xhr.send(data); &#125;)&#125;myHttpClient('GET',url,null).then(function(data)&#123; console.log(data);&#125;,function(error)&#123; console.log(error);&#125;) 思想就是：将整个使用XMLHttpRequest去发起异步网络请求的操作封装在new Promise当中，执行函数返回一个Promise，那后续可以使用.then来执行后续的操作。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"设置display:none对DOM树和渲染树的影响","slug":"设置display-none对DOM树和渲染树的影响","date":"2020-03-21T01:50:17.000Z","updated":"2020-03-30T03:38:27.569Z","comments":true,"path":"2020/03/21/设置display-none对DOM树和渲染树的影响/","link":"","permalink":"http://delaprada.com/2020/03/21/%E8%AE%BE%E7%BD%AEdisplay-none%E5%AF%B9DOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D/","excerpt":"","text":"原本的样式12345678910111213141516171819&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .main&#123; width:100px; height:100px; background-color: lightyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"main\"&gt; display属性testing &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置display:none对渲染树的影响在原本的style中添加上display:none： 12345678&lt;style&gt; .main&#123; width:100px; height:100px; background-color: lightyellow; display:none; &#125;&lt;/style&gt; 页面上没有显示任何东西： 所以设置display:none是会将节点从渲染树中摘除的。 设置display:none对DOM树的影响我们在刚才的代码中添加上一段js代码： 1234&lt;script&gt; var node=document.getElementsByClassName(\"main\")[0]; console.log(node.innerText);&lt;/script&gt; 控制台输出： 说明DOM树中该节点并没有消失，否则不会获取到DOM上的信息。 设置display:none对CSS规则树的影响我们在div当中添加style样式： 123&lt;div class=\"main\" style=\"width:100px\"&gt; display属性testing&lt;/div&gt; 在script中添加： 1console.log(node.style.width); 控制台输出： 说明CSS规则树中该节点的样式没有消失。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"每日一题——水壶问题","slug":"每日一题——水壶问题","date":"2020-03-21T00:37:01.000Z","updated":"2020-03-21T00:43:46.398Z","comments":true,"path":"2020/03/21/每日一题——水壶问题/","link":"","permalink":"http://delaprada.com/2020/03/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/","excerpt":"","text":"有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: (From the famous *”Die Hard”* example) 12输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4输出: True 示例 2: 12输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5输出: False 思路： 当x=3,y=5,z=4的时候怎么倒出4L水： 首先装满x，将x中的3L水倒入y中， 然后再装满x，将x的水倒入y中，此时只能倒2L，那x中就剩下1L水 将y中的水倒掉，将x中的1L水倒入 x再装满3L水，倒入y中，此时y就有4L水 它的思路就是：x和y的最大公约数是否能够被z整除。与此同时要考虑，x和y加起来的大小是否比z要小，如果小的话就不可能装得下。还要考虑，两个壶为0的情况，因为mod操作是不能mod0的。 题解： 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number&#125; x * @param &#123;number&#125; y * @param &#123;number&#125; z * @return &#123;boolean&#125; */var canMeasureWater = function(x, y, z) &#123; var temp; if(x&gt;y)&#123; temp=x; x=y; y=temp; &#125; if(x+y&lt;z)&#123; return false; &#125; while(x!=0)&#123; temp=y; y=x; x=temp%x; &#125; if(y==0&amp;&amp;z==0)&#123; return true; &#125; else if(y==0&amp;&amp;z!=0)&#123; return false; &#125; else&#123; if(z%y==0)&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——矩阵重叠","slug":"每日一题——矩阵重叠","date":"2020-03-18T01:28:56.000Z","updated":"2020-03-18T01:31:05.226Z","comments":true,"path":"2020/03/18/每日一题——矩阵重叠/","link":"","permalink":"http://delaprada.com/2020/03/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E9%87%8D%E5%8F%A0/","excerpt":"","text":"矩形重叠矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 12输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]输出：true 示例 2： 12输入：rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]输出：false 说明： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。矩形中的所有坐标都处于 -10^9 和 10^9 之间。 思路： 两个矩形，我们只需要关注它们离彼此最近的两个点。两个矩阵只要靠左边矩形的右上角的x比右边矩形左下角的x要小（小于等于）的话，就不会重叠；或者是，靠左边矩形的右下角的y比右边矩形右上角y要大（大于等于）的话，也不会重叠。因为rec1和rec2的顺序不一定就是rec1在左，rec2在右，所以要考虑反过来情况。 题解： 12345678/** * @param &#123;number[]&#125; rec1 * @param &#123;number[]&#125; rec2 * @return &#123;boolean&#125; */var isRectangleOverlap = function(rec1, rec2) &#123; return !(rec1[2]&lt;=rec2[0]||rec2[2]&lt;=rec1[0]||rec1[1]&gt;=rec2[3]||rec2[1]&gt;=rec1[3]);&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——岛屿的最大面积","slug":"每日一题——岛屿的最大面积","date":"2020-03-15T01:13:59.000Z","updated":"2020-03-15T01:20:00.660Z","comments":true,"path":"2020/03/15/每日一题——岛屿的最大面积/","link":"","permalink":"http://delaprada.com/2020/03/15/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/","excerpt":"","text":"岛屿的最大面积给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: 12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: 1[[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 思路：和腐烂的橘子的思想类似，使用广度优先遍历，然后queue来实现（JS中用普通数组，使用shift来获取列头元素，不要写错成pop()，c++中队列的pop()和JS中普通数组的shift()才是对应的）。而且要另外维护一个flag数组，用来记录每个数组中的元素是否已经判断过了，如果判断过了的话，就要将flag变为true，下一次不用再去判断。 用JS声明二维数组的方式： 12345678var a = new Array();for(var i=0;i&lt;3;i++)&#123; //一维长度为3 a[i] = new Array(); for(var j=0;j&lt;5;j++)&#123; //二维长度为5 a[i][j] = i+j; &#125;&#125; 题解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var maxAreaOfIsland = function(grid) &#123; var q=[]; var res=0; var count=0; var step=[[-1,0],[1,0],[0,1],[0,-1]]; //用来进行广度遍历 var flag=new Array(); for(var n=0;n&lt;grid.length;++n)&#123; flag[n]=new Array(); for(var m=0;m&lt;grid[0].length;++m)&#123; flag[n][m]=false; &#125; &#125; for(var i=0;i&lt;grid.length;++i)&#123; for(var j=0;j&lt;grid[0].length;++j)&#123; if(grid[i][j]==1&amp;&amp;flag[i][j]==false)&#123; count++; q.push([i,j]); flag[i][j]=true; while(q.length!==0)&#123; var temp=q.shift(); for(var k=0;k&lt;step.length;++k)&#123; var x=temp[0]+step[k][0]; var y=temp[1]+step[k][1]; if(x&gt;=0&amp;&amp;x&lt;grid.length&amp;&amp;y&gt;=0&amp;&amp;y&lt;grid[0].length)&#123; if(grid[x][y]==1&amp;&amp;flag[x][y]==false)&#123; q.push([x,y]); flag[x][y]=true; count++; &#125; &#125; &#125; &#125; if(count&gt;res)&#123; res=count; &#125; count=0; &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——最大上升子序列","slug":"最大上升子序列","date":"2020-03-14T03:11:50.000Z","updated":"2020-03-14T03:13:45.148Z","comments":true,"path":"2020/03/14/最大上升子序列/","link":"","permalink":"http://delaprada.com/2020/03/14/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长上升子序列给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 思路： 动态规划的思想。先初始化每个元素的最大上升子序列长度为1。当前元素的最大上升子序列数应为在它前面比该元素小的元素的最大上升子序列数的最大值+1。 题解： 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var lengthOfLIS = function(nums) &#123; if(nums.length==0)&#123; return 0; &#125; var dp=[]; for(var i=0;i&lt;nums.length;++i)&#123; dp[i]=1; &#125; for(var j=0;j&lt;nums.length;++j)&#123; for(var k=0;k&lt;j;++k)&#123; if(nums[j]&gt;nums[k])&#123; dp[j]=Math.max(dp[k]+1,dp[j]); &#125; &#125; &#125; var res=1; for(var p=0;p&lt;nums.length;++p)&#123; if(dp[p]&gt;res)&#123; res=dp[p]; &#125; &#125; return res;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"如何理解异步","slug":"如何理解异步","date":"2020-03-13T02:59:49.000Z","updated":"2020-03-13T03:03:10.481Z","comments":true,"path":"2020/03/13/如何理解异步/","link":"","permalink":"http://delaprada.com/2020/03/13/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/","excerpt":"","text":"什么是异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。 例如： 1234setTimeout(function()&#123; XXX;&#125;,1000)console.log(\"XXX\"); setTimeout就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。setTimeout是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行setTimeout任务的第二部分，执行XXX。 如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。 异步编程的解决方案回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。callback的意思就是“重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 PromisePromise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function (data) &#123; console.log(data.toString());&#125;).then(function () &#123; return readFile(fileB);&#125;).then(function (data) &#123; console.log(data.toString());&#125;).catch(function (err) &#123; console.log(err);&#125;); 上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。 Promise的话任务也是分为两个部分，new Promise作为第一部分立即执行，然后将执行权交给其他任务，当执行完毕后才会执行event queue当中的回调函数。 Promise的最大问题是代码冗余：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 Generator协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 12345function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125; 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 （其他代码部分属于一个协程，中间的yield部分属于另一个协程） 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 1234567var fetch = require('node-fetch');function* gen()&#123; var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 12345678var g = gen();var result = g.next();result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; g.next(data);&#125;); 执行gen（）的时候，它执行了var url = &#39;https://api.github.com/users/github&#39;;操作，因为遇到了yield，所以交出了当前异步任务的执行权。执行.next()方法的时候才会执行fetch(url)操作，fetch(url)任务执行完毕之后，才会将执行权交还给异步任务，去执行异步任务的第二部分。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"每日一题——零钱兑换","slug":"每日一题——零钱兑换","date":"2020-03-08T00:33:18.000Z","updated":"2020-03-08T00:38:37.811Z","comments":true,"path":"2020/03/08/每日一题——零钱兑换/","link":"","permalink":"http://delaprada.com/2020/03/08/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/","excerpt":"","text":"零钱兑换给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11输出: 3 解释: 11 &#x3D; 5 + 5 + 1 示例 2: 12输入: coins &#x3D; [2], amount &#x3D; 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 思路：动态规划的思想，每种硬币都找到当前自身的最优解，从而求出结果为amount时的最优解。在初始化的时候，要为每种金额的硬币声明一个初始的解，这个解应该是个比amount要大的值（因为解最大为amount）。这样我们在做结果判断的时候就可以知道，如果当前解是amount+1就说明没有组合能组成总金额。 题解： 123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; coins * @param &#123;number&#125; amount * @return &#123;number&#125; */var coinChange = function(coins, amount) &#123; coins.sort(function(a,b)&#123; return a-b; &#125;) console.log(coins); var F=[]; for(var i=0;i&lt;=amount;++i)&#123; F[i]=amount+1; &#125; F[0]=0; for(var j=0;j&lt;=amount;++j)&#123; for(var k=0;k&lt;coins.length;++k)&#123; if(j&lt;coins[k])&#123; break; &#125; else&#123; F[j]=Math.min(F[j-coins[k]]+1,F[j]); //注意此处是F[j] &#125; &#125; &#125; return F[amount]!==amount+1?F[amount]:-1;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——腐烂的橘子","slug":"每日一题——腐烂的橘子","date":"2020-03-04T01:47:21.000Z","updated":"2020-03-04T07:26:47.849Z","comments":true,"path":"2020/03/04/每日一题——腐烂的橘子/","link":"","permalink":"http://delaprada.com/2020/03/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","excerpt":"","text":"在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 123456789101112输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4示例 2：输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。示例 3：输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1231 &lt;&#x3D; grid.length &lt;&#x3D; 101 &lt;&#x3D; grid[0].length &lt;&#x3D; 10grid&#96;[i][j]&#96; 仅为 0、1 或 2 思路： 广度优先搜索。广度优先搜索的话一般会使用队列的思想，深度优先搜索使用栈的思想。最主要还有如何去控制节点去上下左右遍历，所以我们要设置一个locs数组为：[[0,-1],[0,1],[1,0],[-1,0]]，在遍历每个队列元素时，都让它去和locs数组的每个元素进行相加减，得到这个元素上下左右的元素，将为1的元素（即新鲜橙子），变为2（即腐烂橙子）。因为我们要计算时间，但又不能将循环次数用来计时，所以我们将时间和节点的x，y坐标一齐作为一个元素进入队列。 题解： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var orangesRotting = function(grid) &#123; var row=grid.length; var col=grid[0].length; var queue=[]; var locs=[[0,-1],[0,1],[1,0],[-1,0]]; var time=0; var x,y; for(var i=0;i&lt;row;++i)&#123; for(var j=0;j&lt;col;++j)&#123; if(grid[i][j]==2)&#123; queue.push([i,j,time]); &#125; &#125; &#125; while(queue.length!==0)&#123; //这是queue！！不要写成stack,先进先出是用shift [x,y,time]=queue.shift(); for(var t=0;t&lt;locs.length;++t)&#123; var new_x=x+locs[t][0]; var new_y=y+locs[t][1]; if(new_x&gt;=0&amp;&amp;new_x&lt;row&amp;&amp;new_y&gt;=0&amp;&amp;new_y&lt;col)&#123; if(grid[new_x][new_y]===1)&#123; queue.push([new_x,new_y,time+1]); grid[new_x][new_y]=2; &#125; &#125; &#125; &#125; for(var p=0;p&lt;row;++p)&#123; for(var q=0;q&lt;col;++q)&#123; if(grid[p][q]==1)&#123; return -1; &#125; &#125; &#125; return time;&#125;;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"每日一题——版本号比较 随机生成字符串 类型比较","slug":"每日一题——版本号比较-随机生成字符串","date":"2020-03-03T09:01:38.000Z","updated":"2020-03-03T14:14:37.536Z","comments":true,"path":"2020/03/03/每日一题——版本号比较-随机生成字符串/","link":"","permalink":"http://delaprada.com/2020/03/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83-%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"版本号比较比较版本号 （类似1.0.1/1.2.0/1.2/0.1）实现一个方法，用于比较两个版本号（version1、version2）如果version1 &gt; version2，返回1；如果version1 &lt; version2，返回-1，其他情况返回0。版本号规则x.y.z，xyz均为大于等于0的整数，至少有x位 123456789101112131415161718192021222324252627282930313233function compare(str1,str2)&#123; str1=str1.split(\".\"); str2=str2.split(\".\"); str1=str1.map(Number); str2=str2.map(Number); var len; var len1=str1.length; var len2=str2.length; if(len1&gt;len2)&#123; len=len2; &#125; else&#123; len=len1; &#125; for(var i=0;i&lt;len;++i)&#123; if(str1[i]&gt;str2[i])&#123; return 1; &#125; else if(str1[i]&lt;str2[i])&#123; return -1; &#125; &#125; if(len1===len2)&#123; return 0; &#125; else if(len1&gt;len2)&#123; return 1; &#125; else&#123; return -1; &#125;&#125;console.log(compare('1.0.1','1.0')); 随机生成字符串随机生成字符串实现一个随机符串生成函数 randomStr()，要求如下：生成的随机的字符串应该以字母开头，并包含 [a-z][0-9] 这些字符。生成的字符串长度为 8。生成的字符串不能够在程序运行的生命周期中存在重复的情形。 1234567891011121314function randomString(len,chars)&#123; var res=''; for(var i=0;i&lt;len;++i)&#123; //因为Math.random()包括0但不包括1，所以可以直接乘上chars.length if(i==0)&#123; res+=chars[Math.floor(Math.random()*26)]; &#125; else&#123; res+=chars[Math.floor(Math.random()*chars.length)]; &#125; &#125; return res;&#125;console.log(randomString(8,'abcdefghijklmnopqrstuvwxyz0123456789')); 隐式类型转换下面代码中 a 在什么情况下会打印 1？1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 题解： 123456789var a=&#123; i:1, toString()&#123; return this.i++; &#125;&#125;if(a==1&amp;&amp;a==2&amp;&amp;a==3)&#123; console.log(1);&#125;","categories":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"http://delaprada.com/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"易混淆JS题目——this指向 闭包","slug":"易混淆JS题目——this指向-闭包","date":"2020-02-18T02:23:00.000Z","updated":"2020-02-18T02:24:06.154Z","comments":true,"path":"2020/02/18/易混淆JS题目——this指向-闭包/","link":"","permalink":"http://delaprada.com/2020/02/18/%E6%98%93%E6%B7%B7%E6%B7%86JS%E9%A2%98%E7%9B%AE%E2%80%94%E2%80%94this%E6%8C%87%E5%90%91-%E9%97%AD%E5%8C%85/","excerpt":"","text":"Q：代码运行结果 1234567var a = function () &#123; this.b = 3; &#125;var c = new a();a.prototype.b = 9;var b = 7;a();console.log(b);console.log(c.b); 解： 整个代码在变量提升之后可以写为： 123456789101112var a;var c;var b;a=function()&#123; this.b=3;&#125;c=new a();a.prototype.b=9;b=7;a();console.log(b);console.log(c.b); 注意：函数声明的时候还没有执行！不要弄混了。当执行c=new a()的时候，会将函数a内部的this指向c，所以c.b此时就是3。a.prototype.b=9没有什么影响。b=7;表示将全局变量b赋值为7。此后执行了函数a()，要注意在默认情况下，函数中this的指向是指向全局作用域的，所以执行函数a()的话是把全局变量b的值变为3。所以输出的是3 3。 Q：以最小的改动解决以下代码的错误（可以使用es6） 123456789101112131415const obj = &#123;name: \" jsCoder\",skill: [\"es6\", \"react\", \"angular\"],say: function () &#123; for(var i = 0, len = this.skill.length; i&lt; len; i++)&#123; setTimeout(function()&#123; console.log('No.' + i + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i); &#125;&#125;&#125;;obj.say(); 解： 第一点：for循环当中有个异步函数，而且异步函数根据for循环i的值依次输出No.1，No.2，No.3，这样的话for循环中i必须使用let去声明，因为使用let才能让异步函数记住每一轮i的值，得到相应的输出结果。 第二点：在对象函数say中，有一个异步函数，它使用了this。源代码的意图是想让这个this表示对象obj，但是对象的方法say的this指向的是obj，但是这个方法内部的函数（使用了闭包）是指向全局变量的！这么写是得不到想要的结果的。所以要将setTimeout函数改为箭头函数，因为箭头函数它会继承上一层作用域的this，所以它会继承say函数的this，就会指向obj了。 修改后的代码为： 12345678910111213141516const obj = &#123; name: \" jsCoder\", skill: [\"es6\", \"react\", \"angular\"], say: function () &#123; for(let i = 0,len=this.skill.length; i&lt;len; i++)&#123; //闭包！！ setTimeout(()=&gt;&#123; console.log('No.' + (i+1) + this.name); console.log(this.skill[i]); console.log('--------------------------'); &#125;, 0); console.log(i+1); &#125; &#125;&#125;;obj.say(); Q：repeat 实现，使用JS实现一个repeat方法，调用这个 repeatedFunc(“helloworld”)，会alert4次 helloworld, 每次间隔3秒 1234function repeat(func, times, wait) &#123;&#125;const repeatFunc = repeat(alert, 4, 3000)repearFunc(\"helloworld\"); 解： 这种问题一般要结合闭包来实现。 1234567891011121314function repeat(func, times, wait)&#123; var count=0; var timer=null; return function()&#123; var args=[].slice.call(arguments); timer=setInterval(function()&#123; if(count==(times-1))&#123; clearTimeout(timer); &#125; func(args.join(\"\")); count++; &#125;,wait) &#125;&#125; 题目中说，调用repeatedFunc(&quot;helloworld&quot;)会有相关的结果，所以它应该是在函数中还有一个函数的，所以应该有个闭包。通过闭包可以记住count的值。注意clearTimeout要写在setInterval函数当中，这个和防抖节流不同，因为它只执行了一次函数，它是通过setInterval函数的循环才会输出多次结果，所以要写在里面才能够判断count的值是否已经到达输出次数。 Q：实现每隔1s输出一个数组的元素及其索引 解： 这题和上一题的思路类似，但是它没有需要说要调用的时候再去执行，那就不需要写return functionf(){}了。因为setInterval函数已经是output函数的内部函数，有闭包能够记住count的值了。 123456789101112131415function output(arr) &#123; var length = arr.length; var count = 0; var timer = null; timer = setInterval(function() &#123; if (count == length - 1) &#123; clearTimeout(timer); &#125; console.log(arr[count]); console.log(count); count++; &#125;, 1000);&#125;output([1, 2, 3, 4, 5]);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Vue之计算属性的应用","slug":"Vue之计算属性的应用","date":"2020-02-17T02:52:19.000Z","updated":"2020-02-17T02:54:22.665Z","comments":true,"path":"2020/02/17/Vue之计算属性的应用/","link":"","permalink":"http://delaprada.com/2020/02/17/Vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"昨天面试的时候被问到了Vue计算属性相关的代码题，又是一脸懵逼呀…赶紧来总结一下。 面试官先出了第一道题，点击div时输出是什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 输出是3。 首先，computed中的属性都是以函数的形式声明的，看看官网的例子： 结果是： 123Original message: &quot;Hello&quot;Computed reversed message: &quot;olleH&quot; computed属性它所依赖的数据是data当中的，是要使用this来去获取的。所以计算属性c中的this.b和this.a其实是data当中的属性值。执行点击事件之后，b是会发生变化的，所以在计算属性c中输出this.b是会发生变化的，所以在控制台会输出3。因为计算属性creturn的是this.a，所以的值是不变的，是1。 接着面试官又出了第二道题，此时又输出什么？（其实面试官人真的好好，他的表述是此时会输出么？他这么问的话我就会倾向于回答不会输出） 1234567891011121314151617181920&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;&#123;&#123;c&#125;&#125;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; if(false)&#123; console.log(this.b); return this.a; &#125; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 答案是不输出。此时c连渲染都不会发生。 最后面试官又问了第三道题，此时会输出什么？ 123456789101112131415161718&lt;body&gt; &lt;div id=\"app\" @click=\"b += 1\"&gt;absdflj&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: \"#app\", data() &#123; return &#123; a: 1, b: 2 &#125;; &#125;, computed: &#123; c() &#123; console.log(this.b); return this.a; &#125;, &#125; &#125;); &lt;/script&gt;&lt;/body&gt; 此时这个计算属性并没有写在页面上，所以是不会监听c的值，此时控制台没有输出，页面显示的是：absdflj。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://delaprada.com/tags/Vue/"}]},{"title":"JavaScript之变量提升","slug":"JavaScript之变量提升","date":"2020-02-17T01:58:59.000Z","updated":"2020-02-17T02:32:12.967Z","comments":true,"path":"2020/02/17/JavaScript之变量提升/","link":"","permalink":"http://delaprada.com/2020/02/17/JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","excerpt":"","text":"今天面试的时候被问到了变量提升的问题，一脸懵逼，掌握得不够熟练，写篇博客来总结一下。 JS代码解析规则 第一步为解释：先扫描所有的JS代码，把所有声明提升到顶端。 第二步为执行：执行就是操作一类的。 变量提升例一： 12console.log(a); //undefinedvar a=10; 因为有变量提升，上面的代码相当于： 123var a;console.log(a);a=10; 函数提升函数声明的两种方式 函数声明式 1function bar()&#123; &#125; 函数字面量式 1var bar=function()&#123; &#125; 注意：函数字面量式的提升和变量提升一样，都是只提升声明，不提升赋值，比如上面代码中函数字面量式，只会把var bar提升上去，但是函数声明式是会将整个函数体都提升上去。 例二： 1234foo(); //aaafunction foo()&#123; console.log(\"aaa\");&#125; 因为存在函数声明提升，函数声明提升会直接把整个函数提升到执行环境的最顶端。相当于： 1234function foo()&#123; console.log(\"aaa\");&#125;foo(); 注意：变量提升只提升变量名，而函数提升是会提升整个函数体。函数提升在变量提升之前。 例三： 1234foo(); //foo is not a functionvar foo = function()&#123; console.log(\"aaa\");&#125; 因为进行了变量提升（函数字面量式），上面的代码相当于： 12345var foo;foo();foo=function()&#123; console.log(\"aaa\");&#125; JS解析在遇到foo()时会默认当做函数来解析，所以会输出foo is not a function。 例四： 1234567console.log(foo);var foo=10;console.log(foo);function foo()&#123; console.log(10);&#125;console.log(foo); 输出： 上面的代码相当于： 12345678function foo()&#123; console.log(10);&#125;var foo;console.log(foo); //foo()&#123;console.log(10);&#125;foo=10;console.log(foo); //10console.log(foo); //10 第一个console.log(foo)之所以输出函数体，是因为var foo只是声明（提升了的声明），并没有赋值，所以它会调用上面的函数体。 面试题先看一道经典面试题： 123456789console.log(v1);var v1 = 100;function foo() &#123; console.log(v1); var v1 = 200; console.log(v1);&#125;foo();console.log(v1); 输出是： 1234&#x2F;&#x2F;undefined&#x2F;&#x2F;undefined&#x2F;&#x2F;200&#x2F;&#x2F;100 上面的代码相当于： 1234567891011var v1;console.log(v1); //undefinedv1=100;function foo()&#123; var v1; console.log(v1); //undefined v1=200; console.log(v1); //200&#125;foo();console.log(v1); //100 注意，如果内部没有声明v1的时候，函数才会到全局作用域去查找变量的赋值。但是如果函数作用域内部定义了的话，就不会到全局作用域去找。参照作用域链的定义。 看一道字节面试时候的题目： 1234567891011var a = 'byte'function foo() &#123; if (a === undefined) &#123; var a = 'dance' &#125; else &#123; a = 'bytedance' &#125; return a;&#125;console.log(foo());console.log(a); 输出为： 12&#x2F;&#x2F;dance&#x2F;&#x2F;byte 上面代码实际效果是： 1234567891011121314function foo()&#123; var a; if(a===undefined)&#123; a='dance'; &#125; else&#123; a='bytedance'; &#125; return a;&#125;var a;a='byte';console.log(foo());console.log(a); 在当前作用域有对变量进行声明的时候，是不会去上一级作用域去寻找变量的声明的。 因为console.log(a)在当前函数作用域找到了var a;，即a的定义，所以它不会去全局作用域去找a的声明（及值）。 上面的代码也是这个道理，a===undefined会找到当前函数作用域的var a;的定义，所以a的值为undefined。 参考：https://blog.csdn.net/qq_39712029/article/details/80951958 ​ https://blog.csdn.net/Demo_18/article/details/78493489","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"Math.floor()和~~运算符的异同","slug":"Math-floor-和-的异同","date":"2020-02-10T03:14:06.000Z","updated":"2020-02-10T03:30:38.297Z","comments":true,"path":"2020/02/10/Math-floor-和-的异同/","link":"","permalink":"http://delaprada.com/2020/02/10/Math-floor-%E5%92%8C-%E7%9A%84%E5%BC%82%E5%90%8C/","excerpt":"","text":"今天在用JavaScript实现大数相加的时候，发现网上的解法当中有使用~~运算符，之前没有见过。在网上一查，说是Math.floor()的更好的一种表示方法，运行速度更快。但是将大数相加的代码中的~~换成Math.floor()发觉得不到正确的答案，所以想来分析一下异同。 ~和~~~运算符用于将整数变为-(N+1)。 例如： 1234~2 &#x3D;&#x3D;&#x3D; -3; &#x2F;&#x2F;true~1 &#x3D;&#x3D;&#x3D; -2; &#x2F;&#x2F;true~0 &#x3D;&#x3D;&#x3D; -1; &#x2F;&#x2F;true~-1 &#x3D;&#x3D;&#x3D; 0; &#x2F;&#x2F;true ~~运算符~~是Math.floor()的一个替代，相同的操作但是更快。可以使用它将任何浮点数转换为整数（下取整）。 例如： 123~~2 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~2.4 &#x3D;&#x3D;&#x3D; Math.floor(2); &#x2F;&#x2F;true, 2~~3.9 &#x3D;&#x3D;&#x3D; Math.floor(3); &#x2F;&#x2F;true, 3 ~~和Math.floor()在性能上的不同： # Browser Math.floor() Bitwise double NOT ~~ #1 Firefox 7.0.1 42ms 29ms #2 Firefox 7.0.1 44ms 28ms #3 Chrome 15 63ms 64ms #4 Chrome 15 63ms 68ms #5 IE8 265ms 192ms #6 IE8 324ms 190ms 大数相加在大数相加时，使用~~能够的到正确的结果： 但是使用Math.floor()时，结果是： 主要是因为当a数组已经pop完毕之后，再对a执行pop操作时，输出的是undefined。而~~操作undefined和Math.floor()操作undefined是会得出不同的结果的： 所以才会导致上面的结果。 参考：http://rocha.la/JavaScript-bitwise-operators-in-practice","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2020-02-04T10:17:33.000Z","updated":"2020-02-17T10:17:45.311Z","comments":true,"path":"2020/02/04/浏览器缓存/","link":"","permalink":"http://delaprada.com/2020/02/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/","excerpt":"","text":"缓存过程分析： 浏览器每次发起请求，都会先在浏览器缓存中查找请求的结果以及缓存标识 如果没有该请求的缓存结果和缓存标识的话，浏览器会向服务器发起http请求，服务器返回该请求结果和缓存规则 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 强缓存和协商缓存浏览器缓存分为：强缓存和协商缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源。可以通过设置两种http header实现：Expires和Cache-Control。 Expires是http/1的产物。它用来指定资源到期的时间，Expires是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间之前浏览器可以直接从浏览器缓存取数据，而无需再次请求。 1Expires: Thu, 10 Nov 2017 08:45:11 GMT 这个字段设置时有两个缺点： 由于是绝对时间，用户可能会将客户端本地的时间修改，而导致浏览器判断缓存失效，重新请求该资源。 写法太复杂，表示时间的字符串多个空格，少个字母都会导致非法属性从而失效 Cache-control是http/1.1的产物。和Expires的差别在于，Expires是绝对时间，Cache-control表示的是相对时间 1Cache-control: max-age=2592000 Cache-control字段常用的值： max-age：即最大有效时间 must-revalidate：如果超过了max-age的时间，浏览器必须向服务器发送请求，验证资源是否还有效 no-cache：不是不缓存的意思！表示可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用。 no-store：彻底禁用缓存，本地和代理服务器都不缓存，每次都从服务器获取 public：所有内容都可以被缓存（包括客户端和代理服务器，如CDN） private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。 自从http/1.1开始，Expires逐渐被Cache-control取代。Cache-control是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。而且Cache-control的可配置性比较强大。 强缓存判断是否缓存的依据来自于是否超出某个时间或者时间段，而不关心服务器端文件是否已经更新，这可能导致加载文件不是服务器端最新的内容。那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。 协商缓存：是由服务器来确定缓存资源是否可用，所以客户端与服务器端需要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 主要有以下两种标识： Last-Modified和If-Modified-Since： Last-Modified：浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加Last-Modified的header，值是这个资源在服务器端的最后修改时间。 If-Modified-Since：浏览器下一次请求这个资源，浏览器检测有Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值。服务器再次收到这个资源的请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，可以直接从缓存读取。如果服务器端这个资源在If-Modified-Since之后被修改了，说明文件有更新，返回新的资源文件和200。 Etag和If-None-Match: Etag和If-None-Match返回的是一个校验码。Etag可以保证每一个资源是唯一的，资源变化都会导致Etag变化。 当浏览器第一次请求资源的时候，服务器会在响应报文中添加Etag（表示资源的标签）。当浏览器再次发起请求的时候，请求报文中会添加If-None-Match字段，其值是上一次响应报文中Etag的值。服务器收到请求报文的时候，会检查If-None-Match的值与当前资源Etag的值是否匹配。如果匹配，也就是资源没有被修改，返回304；如果不匹配，也就是服务器端资源被修改了，返回200，并返回新的资源。 为什么有了Last-Modified和If-Modified-Since还要Etag和If-None-Match呢？ 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用 某些文件修改非常频繁，比如在秒以下级别的时间内进行修改（比如1s内修改了N次），If-Modified-Since能检查到的粒度只能是秒级别的，这种修改无法判断。 协商缓存生效：返回304和Not Modified。即服务器端资源并没有更新，可以继续使用浏览器缓存中的结果。 协商缓存失败，返回200和请求结果。即服务器端资源更新了，获取服务器端的返回结果，并把请求结果和缓存标识存入浏览器缓存中 总结缓存机制： 强制缓存优先于协商缓存进行 若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match) 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。 Last-Modified/If-Modified-Since 和 Etag/If-None-Match的主要区别就是一个是通过时间判断资源是否已被更改，一个是通过Etag来判断。Etag/If-None-Match相比于Last-Modified/If-Modified-Since来说更好。 摘自：https://www.cnblogs.com/yayaxuping/p/9707471.html ​ https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651229883&amp;idx=1&amp;sn=0a775144fc84fc16c0ce581b80ab2a6c&amp;chksm=bd49573f8a3ede2957d0074c8fe047bdeff7614e6439d9077e15d0864eb90b8ae7e25abf2a1b&amp;scene=21#wechat_redirect","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器渲染过程","slug":"浏览器渲染过程","date":"2020-01-31T01:50:01.000Z","updated":"2020-02-18T03:29:31.895Z","comments":true,"path":"2020/01/31/浏览器渲染过程/","link":"","permalink":"http://delaprada.com/2020/01/31/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","excerpt":"","text":"浏览器渲染的过程主要包括以下5步 浏览器将获取的HTML文档解析为DOM树 处理CSS标记，构成CSS规则树 将DOM树和CSS规则树合并为渲染树（rendering tree），生成渲染树 渲染树布局，确定每个节点对象在页面上的确切大小和位置 将渲染树的各个节点绘制到屏幕上 具体流程构建DOM树当浏览器接受到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。注意：DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞。 构建CSS规则树浏览器解析CSS文件并生成CSS规则树。注意：CSS解析可以与DOM解析同时执行，但与script的执行互斥。 构建渲染树（Render Tree）通过DOM树和CSS规则树，浏览器可以通过它们构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。 渲染树生成后，还不能渲染到屏幕上。因为渲染到屏幕上需要得到各个节点的位置信息，这就需要布局的处理。 渲染树布局布局阶段从渲染树的根节点开始遍历，渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。浏览器通过这些样式信息来确定每个节点对象在页面上的确切大小和位置。 渲染树绘制将渲染树绘制到浏览器上。 主流的一些浏览器排版（渲染）引擎 浏览器 排版引擎 Chrome Opera Blink Firefox Gecko IE Trident Safari WebKit 渲染阻塞渲染阻塞的原因：由于JavaScript可以操作DOM来修改DOM结构，可以操作CSS规则树来修改节点样式，这就导致浏览器在遇到&lt;script&gt;标签时，DOM构建将暂停，直到脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。 现在可以通过在&lt;script&gt;标签上增加属性defer或者async，解决上述问题。这两个属性使得script标签不会阻塞DOM的渲染，能够异步加载script脚本，不阻塞DOM渲染。 defer如果script标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行） 使用方法： asyncasync的设置，会使得script脚本异步加载。async的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。 用图表来展示： 文档渲染 应该为 文档解析 普通的script文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载。 资源的下载是在解析过程中进行的，虽说script1脚本会很快的加载完毕，但是他前边的script2并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待script2执行完毕后再执行。当这两个脚本都执行完毕后，才会继续解析页面。 defer文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。 asyncasync脚本会在加载完毕后执行。async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的。 浏览器的回流与重绘回流：对于整个网页重新渲染一遍。 会导致回流的操作有： 页面首次渲染 浏览器窗口大小发生变化 元素尺寸或位置发生变化 元素内容发生变化（文字数量或图片大小等） 元素字体大小变化 添加或删除可见的DOM元素 激活css伪类（例如:hover） 重绘：浏览器只需要对某个元素进行重新绘制即可 会导致重绘的操作有： 修改color/background-color/visibility 由上述可见，其实回流对浏览器性能的消耗是高于重绘的，而且回流操作一定会伴随重绘，重绘却不一定伴随回流。 那么如何针对回流和重绘写出性能更好的代码呢？ CSS： 避免使用table布局 尽可能在DOM树的最末端改变class 避免设置多层内联样式 将动画效果应用到position属性为absolute或fixed的元素上 避免使用css表达式（例如：calc()） JavaScript 避免频繁操作样式 避免频繁操作DOM。创建一个documentFragment，在它上面应用所有的DOM操作，最后再把它添加到文档中 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 DOM CSS JS之间的关系 CSS是不会阻塞DOM的解析的，JS是会阻塞DOM的解析的 CSS是会阻塞DOM的渲染的。如果没有这个策略的话，页面首先会呈现一个原始的模样，待CSS下载完后又变成另一个模样，这样会导致用户体验变差而且渲染是有成本的。 JS是会等待CSS加载完才会执行的（如果CSS文件在JS文件之前声明的话，那JS需要等待CSS文件加载完毕后才会执行）。 原因：因为JS有时需要查询（获取）元素的一些样式，这些样式是定义在CSS文件里的，所以CSS加载完之后再去执行JS会更好一些。 所以&lt;script&gt;最好放在底部，&lt;link&gt;最好放在头部，是因为JS会阻塞DOM树的解析，CSS不会阻塞DOM树的解析。 如果头部同时有&lt;script&gt;和&lt;link&gt;的情况下，最好将&lt;script&gt;放在&lt;link&gt;上面，是因为JS会等待CSS加载完毕后才会执行，但是放在头部的JS一般不会对样式进行查询修改，所以放在前面没有太大影响（比如说引入VUE的CDN的js代码就会在头部，但是和CSS样式是无关的） 参考： https://www.cnblogs.com/jiasm/p/7683930.html https://www.jianshu.com/p/e6252dc9be32","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://delaprada.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"什么是哈希hash","slug":"什么是哈希hash","date":"2020-01-29T10:55:11.000Z","updated":"2020-01-30T09:36:28.293Z","comments":true,"path":"2020/01/29/什么是哈希hash/","link":"","permalink":"http://delaprada.com/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8Chash/","excerpt":"","text":"哈希Hash什么是Hash通过一些计算，把关键码值映射到数组中的位置来访问记录，这个过程称为散列（hash）。 重要组成： hash函数：把关键码值映射到位置的函数称为散列函数。用h表示。 hash表：存放记录的数组称为散列表。用HT表示。 槽（slot）：散列表中的一个位置称为一个槽。 设计hash表的目标是：使得对于任何关键码值K和某个散列函数h，i=h(K)是表中满足0&lt;=h(K)&lt;M（M为HT中槽的数目）的一个槽，并且记录在HT[i]存储的关键码值与K相等。 冲突解决在实际情况中，我们根据散列方法组织的数据库必须把存储的记录存放在不大的散列表中，以避免浪费过多的空间。这样的话，有可能有多个关键码值计算出来的h(K)是一样的，但又不能同时放在同一个槽中，此时就要使用冲突解决策略。 冲突解决策略冲突解决策略一般分为两类： 开散列方法（open hashing；也称为单链方法） 闭散列方法（closed hashing；也称为开地址方法） 开散列方法开散列方法的最简单形式把散列表中的每个槽定义为一个链表的表头，散列到一个槽的所有记录都放在这个槽的链表内。 闭散列方法闭散列方法把所有记录直接存储到散列表中。每条关键码值标记为kR，记录R有一个基槽，就是h(kR)，即由散列函数计算出来的槽。如果要插入一条记录R，而另一条记录已经占据了R的基槽，那么就把R存储在表的其他槽内。 桶式散列 一种实现闭散列的方法是把散列表中的槽分成多个桶(bucket)。把散列表中的M个槽分成B个桶，每个桶中包含M/B个槽。 散列函数把每一条记录分配到某个桶的第一个槽中。 如果这个槽已经被占用，那么就顺序地沿着桶查找，直到找到一个空槽。 如果一个桶全部被占满了，那么就把这条记录存储在表后具有无限容量的溢出桶（overflow bucket）中。 线性探查最常用的散列方法。当发生冲突时，从当前基槽开始往后查找，有空位则将记录放进去。例如，2037原本应放在7的槽中，但是7已经被占用，所以往后查找空位，8是空的，于是将2037放进去。 但是这种方法会导致基本聚集。例如在上例中，下一条记录放到第2个槽的概率就是6/10了，因为取模后值为7,8,9,0,1,2都会放到第2个槽中。在理想情况下，表中的每个空槽都应该有相同的机会接受到下一个要插入的记录。 改进的冲突解决方法如何避免基本聚集呢？ 一种可能的改进方式是仍然使用线性探查，但是跳过一些槽，而且每次跳过常数c个而不是1个槽。这会生成探查函数：P(K,i)=ci。 例如，如果常数c是2的话：如果基槽被占用的话，第一次会找基槽+2的位置，看是否被占用，如果被占用了，第二次会找基槽+4的位置，如果还是被占用，则找基槽+6的位置，以此类推。即从基槽开始的偏移量将会为2,4,6。 另一种方法是使用二次探查函数（对于某些常数c1,c2,c3）：p(K,i)=c1i&lt;sup&gt;2&lt;/sup&gt;+c2i+c3。一个最简单的变体就是p(K,i)=i&lt;sup&gt;2&lt;/sup&gt;。 例如，对于一个长度M=101的散列表，假定对于关键码k1和k2，h(k1)=30，h(k2)=29。k1的探查序列为30,31,34,39；k2的探查序列为29,30,33,38。这样，尽管k2会在第二步探查k1的基槽，这两个关键码的探查序列此后就立即分开了。 双散列方法即由两个散列函数，一个散列函数用于计算基槽，另一个散列函数用于确定线性探查中的常数。即线性探查此时的形式为：p(K,i)=i*h2(K)。 例如，假定散列表的长度是M=101，有3个关键码k1，k2，k3，h(k1)=30，h(k2)=28，h(k3)=30，h2(k1)=2，h2(k2)=5，h2(k3)=5。那么k1的探查序列为：30,32,34,36等；k2的探查序列为：28,33,38,43等；k3的探查序列为：30,35,40,45等。这样关键码之间就不会共享同一段探查序列了。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://delaprada.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"事件绑定 事件监听 事件委托","slug":"事件绑定-事件监听-事件委托","date":"2020-01-18T08:58:07.000Z","updated":"2020-02-05T12:49:30.054Z","comments":true,"path":"2020/01/18/事件绑定-事件监听-事件委托/","link":"","permalink":"http://delaprada.com/2020/01/18/%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","excerpt":"","text":"事件绑定为了让JavaScript对用户的操作作出响应，首先要对DOM元素绑定事件处理函数。 三种常用的绑定事件的方法： 在DOM元素中直接绑定 在JavaScript代码中绑定 绑定事件监听函数 在DOM元素中直接绑定我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等。 123456&lt;input type=\"button\" value=\"click me\" onclick=\"hello()\"&gt;&lt;script&gt;function hello()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 在JavaScript代码中绑定事件在JavaScript代码中（即script标签内）绑定事件可以使JavaScript代码与HTML标签分离，文档结构清晰，便于管理和开发。 123456&lt;input type=\"button\" value=\"click me\" id=\"btn\"&gt;&lt;script&gt;document.getElementById(\"btn\").onclick = function()&#123; alert(\"hello world!\");&#125;&lt;/script&gt; 使用事件监听绑定事件绑定事件的另一种方法是用 addEventListener() 或 attachEvent()来绑定事件监听函数。 事件监听的优点： 可以绑定多个事件 常规的事件绑定（例如onclick）只执行最后绑定的事件，会产生事件覆盖。 12345678910&lt;input type=\"button\" value=\"click me\" id=\"btn3\"&gt;&lt;script&gt;var btn3 = document.getElementById(\"btn3\");btn3.onclick = function()&#123; alert(\"hello 1\"); //不执行&#125;btn3.onclick = function()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 使用addEventListener的话两个事件都会执行： 123456789101112&lt;input type=\"button\" value=\"click me\" id=\"btn4\"&gt;&lt;script&gt;var btn4 = document.getElementById(\"btn4\");btn4.addEventListener(\"click\",hello1);btn4.addEventListener(\"click\",hello2);function hello1()&#123; alert(\"hello 1\"); //执行&#125;function hello2()&#123; alert(\"hello 2\"); //执行&#125;&lt;/script&gt; 关于事件监听，有3个事件阶段（事件流包括三个状态）：捕获阶段，目标阶段，冒泡阶段。这三个阶段也叫作事件流。 事件捕获当一个事件触发后，从window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点，都会触发对应事件。 事件冒泡当事件到达目标节点后，会沿着捕获阶段路线原路返回。同样，所有经过的节点，都会触发对应的事件。 通过栗子来理解两个事件机制： 假设有body和body节点下的div1均有绑定了一个点击事件。 效果： 当为事件捕获(useCapture:true)时,先执行body的事件,再执行div的事件 当为事件冒泡(useCapture:false)时,先执行div的事件,再执行body的事件（默认是false，在事件冒泡阶段执行） useCapture：用于指定事件是否在捕获或冒泡阶段执行 12345678910111213141516171819//当useCapture为默认false时,为事件冒泡&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印div1 打印body 1234567891011121314151617//当useCapture为true时,为事件捕获&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function()&#123; let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function()&#123; console.log('打印body') &#125;,true) div1.addEventListener('click',function()&#123; console.log('打印div1') &#125;)&#125;&lt;/script&gt;//结果:打印body 打印div1 事件委托利用冒泡原理，把事件加到父元素或祖先元素上，触发执行效果。 12345678910111213141516171819202122&lt;script&gt; window.onload = function()&#123; let div = document.getElementById('div'); div.addEventListener('click',function(e)&#123; console.log(e.target) &#125;) let div3 = document.createElement('div'); div3.setAttribute('class','div3') div3.innerHTML = 'div3'; div.appendChild(div3) &#125;&lt;/script&gt;&lt;body&gt; &lt;div id=\"div\"&gt; &lt;div class=\"div1\"&gt;div1&lt;/div&gt; &lt;div class=\"div2\"&gt;div2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 虽然没有给div1和div2添加点击事件，但是无论是点击div1还是div2都会打印当前节点（console.log(e.target)）。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。 举个栗子： 分别点击div1、div2、div3： 无论后代新增了多少个节点，一样具有点击事件的功能。但是如果是传统的事件绑定的话无法对动态添加的元素而动态地添加事件。 事件委托的优点 提高性能：每一个函数都会占用内存空间。只需要添加一个事件处理程序代理所有事件，所占用的内存空间更少。 动态监听：使用事件委托可以自动绑定动态添加的元素。即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。 参考：https://www.cnblogs.com/soyxiaobi/p/9498357.html ​ http://blog.xieliqun.com/2016/08/12/event-delegate/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"分析parseInt()","slug":"分析parseInt","date":"2020-01-18T03:56:24.000Z","updated":"2020-01-18T07:05:51.564Z","comments":true,"path":"2020/01/18/分析parseInt/","link":"","permalink":"http://delaprada.com/2020/01/18/%E5%88%86%E6%9E%90parseInt/","excerpt":"","text":"parseInt()公式1parseInt(string, radix) 参数 描述 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。 parseInt(071)和parseInt(&quot;071&quot;)的区别parseInt(&quot;071&quot;)就是简单将字符串转换为数字： 如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。 以0开头也是转换为十进制。也有说转换为十六进制或者八进制，但是在chrome中实践是十进制。 parseInt(071)就是将071用八进制进行转换： 判断[‘1’,’2’,’3’].map(parseInt)的输出你可能觉得会是[1,2,3]，但实际上是[1,NaN,NaN]。我们来仔细分析一下： map的函数格式 1map((item, index, thisArr) &#x3D;&gt; ( newArr )) 参数解析： item: callback 的第一个参数，数组中正在处理的当前元素 index: callback 的第二个参数，数组中正在处理的当前元素的索引 thisArr: callback 的第三个参数，map 方法被调用的数组 parseInt的格式 上面讲到： 1parseInt(string, radix) 通过上述对 map 和 parseInt 函数的分析可以知道，执行方法时，map给parseInt传递了三个参数: 1parseInt(item, index, thisArr) 因此，索引index会传入parseInt函数当做基数radix。 其中第三个参数会被 parseInt 忽略，因此会依次执行： 123456parseInt('1', 0)// radix 为 0，默认以十进制解析字符串，返回 1parseInt('2', 1)// radix 为 1，不在 2 ~ 36 之间，返回 NaNparseInt('3', 2)// radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN 参考：https://www.cnblogs.com/wx1993/p/8417817.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"防抖与节流","slug":"防抖与节流","date":"2020-01-17T02:31:56.000Z","updated":"2020-01-17T02:35:23.204Z","comments":true,"path":"2020/01/17/防抖与节流/","link":"","permalink":"http://delaprada.com/2020/01/17/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/","excerpt":"","text":"防抖和节流如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用防抖（debounce）和节流（throttle）的方式来减少调用频率，同时又不影响实际效果。 防抖含义：当持续触发事件时，一定时间段内没有在触发事件，事件处理函数才会执行一次；如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 代码实现： 123456789101112131415function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 防抖是通过闭包实现的，所以timeout是会被缓存的。如果在频繁触发事件之后的一段时间内，又再次触发了事件，那就会使用clearTimeout清除setTimout设置的timout，重新计时。 具体完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function debounce(fn, wait) &#123; var timeout = null; return function() &#123; //取消由 setTimeout() 方法设置的 timeout if(timeout!==null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125; &#125; // 处理函数 function handle() &#123; console.log(Math.random()); &#125; // 滚动事件 window.addEventListener('scroll', debounce(handle, 1000)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;防抖演示1&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示2&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示3&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示4&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示5&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示6&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示7&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示8&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示9&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示10&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示11&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示12&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示13&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示14&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示15&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;防抖演示16&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在网页运行的时候我们会看到，当在滚动页面操作停止后1s，控制台会有输出。这就是防抖。 节流当持续触发事件时，保证每隔一定时间段内只调用一次事件处理函数。 用定时器实现节流： 1234567891011121314151617var throttle=function(func,delay)&#123; var timer=null; return function()&#123; var context=this; var args=arguments; if(!timer)&#123; timer=setTimeout(function()&#123; func.apply(context,args); timer=null; &#125;,delay); &#125; &#125;&#125;function handle()&#123; console.log(Math.random());&#125;window.addEventListener('scroll',throttle(handle,1000)); 节流也是通过闭包实现的。所以会把timer缓存起来，但是由于每次执行setTimeout函数时都设置timer为null，所以每次调用都可以执行if语句当中的内容。同时，下一次滚动事件不会影响上一次的事件处理函数，所以不会重新计时。 将节流代码放入上个例子的具体实现中会发现，执行滚动页面操作后，都会以同一频率在控制台中输出值。 参考：https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"https SSL/TLS握手过程","slug":"https-SSL-TLS握手过程","date":"2020-01-16T13:00:04.000Z","updated":"2020-01-16T13:05:07.058Z","comments":true,"path":"2020/01/16/https-SSL-TLS握手过程/","link":"","permalink":"http://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/","excerpt":"","text":"SSL/TLS 握手过程详解http协议是明文传输，不确认通信方，不保证传输数据完整的协议。它带来了三大风险： （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。 （2） 篡改风险（tampering）：第三方可以修改通信内容。 （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 http协议是明文传输，在安全性方面比较差。https协议使用了SSL/TLS协议来进行加密。SSL/TLS握手是为了安全地协商出一份对称加密的秘钥。 SSL/TLS握手过程 Client Hello 握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。 Server Hello 第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。 注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。 Certificate 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。 Server Hello Done Server Hello Done通知客户端Server Hello过程结束。 Certificate Verify 客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。 https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的 Client Key Exchange 上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。 至此，客户端和服务端都拥有Random1+Random2+Random3，那么两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。 为什么要使用三个随机数？ 这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。 最重要理解前六步 Change Cipher Spec（Client） 这一步客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，这是一条事件消息。 Encrypted Handshake Message(Client) 这一步对应的是Client Finish消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发送的第一条加密消息。服务端接收后会用私钥解密，能解出来则说明前面的协商出来的秘钥是一致的。 Change Cipher Spec(Server) 这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。 Encrypted Handshake Message(Server) 这一步对应的是Server Finish消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。 Application Data 到这里，双方已安全协商出同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过TCP进行可靠传输。 参考：http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html ​ https://juejin.im/post/584b76d3a22b9d0058d5036f","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://delaprada.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CSS 圣杯布局和双飞翼布局","slug":"CSS-圣杯布局和双飞翼布局","date":"2020-01-15T08:49:17.000Z","updated":"2020-01-15T12:46:08.385Z","comments":true,"path":"2020/01/15/CSS-圣杯布局和双飞翼布局/","link":"","permalink":"http://delaprada.com/2020/01/15/CSS-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"CSS 圣杯布局和双飞翼布局两个常见的前端布局。圣杯布局和双飞翼布局作为经典的三栏式布局是面试中的常客。两种布局达到效果上基本相同，都是两边两栏宽度固定，中间栏宽度自适应。在HTML结构上中间栏在最前面保证了最先渲染中间提升性能（因为这两种布局都比较老，我认为在现代浏览器中这点儿性能优化效果并不是很大），并且兼容性良好。两种布局的实现方法前半部分相同，后半部分的实现各有利弊，下面会简单介绍两者的区别。 圣杯布局代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; background-color: skyblue; height:60px; line-height:60px; /*文字水平垂直居中*/ &#125; .container&#123; overflow:hidden; /*因为内部都是浮动元素，所以要设置overflow来撑起父元素*/ padding:0 100px; /*左右内边距为100px*/ &#125; .main&#123; width:100%; background-color: peachpuff; height:100px; line-height: 100px; float:left; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; float:left; margin-left:-100%; /*让left前移一行*/ position:relative; left:-100px; &#125; .right&#123; background-color: pink; width:100px; height:100px; line-height:100px; float:left; margin-left:-100px; /*right只需要前移right的宽度即可*/ position:relative; /*container设置了padding,所以要相对定位移动才能将left和right移动到对应的位置*/ right:-100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 设置父元素container为overflow:hidden，撑起父元素，子元素main、left、right均设为float:left，浮动起来。效果如下： 为了让main模块自适应，将其设为100% 为了让left和right模块跑上去，设置left模块的margin:-100%，可以理解为：负的话就是向上前进，正值的话就是直接的间隔；right模块就设置为margin:-100px，大小为right模块的宽度 为了使main模块往里收，设置.container{ padding: 0 100px}，即设置左右内边距。 利用相对定位移动left和right 双飞翼布局代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; text-align:center; &#125; .header, .footer&#123; height:60px; background-color: skyblue; line-height:60px; &#125; .container&#123; overflow:hidden; &#125; .main&#123; width:100%; height:100px; line-height:100px; float:left; background-color: peachpuff; &#125; .inner-main&#123; margin-left:100px; /*通过在main内部再设置一个div来进行左右模块的间隔布局*/ margin-right:100px; &#125; .left&#123; background-color: lightgreen; width:100px; height:100px; line-height:100px; margin-left:-100%; float:left; &#125; .right&#123; background-color: yellow; width:100px; height:100px; line-height:100px; margin-left:-100px; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"header\"&gt;header&lt;/div&gt; &lt;div class=\"container\"&gt; &lt;div class=\"main\"&gt; &lt;div class=\"inner-main\"&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果图： 实现原理： 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算。 圣杯布局和双飞翼布局的主要区别： 圣杯布局是设置container的padding属性以及left和right模块的position:relative，left:-100px或right:-100px 双飞翼布局则不设置container里的padding属性，而是通过在main模块中添加inner-main模块，然后对这个div进行margin-left和margin-right计算 参考：https://segmentfault.com/a/1190000004579886","categories":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://delaprada.com/tags/CSS/"}]},{"title":"JavaScript模块化编程","slug":"JavaScript模块化编程","date":"2020-01-14T15:10:50.000Z","updated":"2020-01-14T15:11:30.414Z","comments":true,"path":"2020/01/14/JavaScript模块化编程/","link":"","permalink":"http://delaprada.com/2020/01/14/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B/","excerpt":"","text":"模块化编程目录： AMD CMD commom.js ES6 Module AMDAMD是依赖前置，提前执行。AMD一开始是CommonJS规范中的一个草案，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。 AMD的基本语法通过define来定义一个模块，使用require可以导入定义的模块。 用define定义无依赖的模块： 12345//a.js//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数define(function()&#123; return 1;&#125;) 用define定义有依赖的模块： 1234567define([\"alpha\"], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 用require进行模块加载： 123require(['math'], function(math) &#123; math.add(2, 3);&#125;); AMD的特点对于依赖的模块，AMD推崇依赖前置，提前执行。也就是定义模块和加载模块都要在一开始就把依赖写好。例如define函数当中的[&quot;alpha&quot;]，就是定义模块当中的依赖；require函数当中的[&quot;math&quot;]是加载模块当中的依赖。 CMDCMD是依赖就近，延迟执行。 1234567891011121314151617181920212223//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;); //CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); CMD是在用到了某个模块的时候再去require，类似按需加载。 CMD的特点对于依赖的模块，CMD推崇依赖就近，延迟执行。也就是说，只有到require时依赖模块才执行。 摘自：https://segmentfault.com/a/1190000004873947 CommonJS基本用法 通过module.exports或者exports来输出模块 通过require来导入模块 1234567891011121314151617181920//a.jsmodule.exports = function () &#123; console.log(\"hello world\")&#125;//b.jsvar a = require('./a');a();//\"hello world\"//或者//a2.jsexports.num = 1;exports.obj = &#123;xx: 2&#125;;//b2.jsvar a2 = require('./a2');console.log(a2);//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125; CommonJS的特点 所有代码都运行在模块作用域，不会污染全局作用域 模块都是同步加载的，即只有加载完成，才能执行后面的操作 模块在首次执行后就会缓存，再次加载只返回缓存结果。如果想要再次执行，可清楚缓存 require返回的值是被输出的值的拷贝，模块内部的变化不会影响这个值 ES6 Module基本用法： export或export default来输出模块 import来导入模块 （export default就是能够为导入的模块自定义名称，这样就不用知道模块在原本的js文件当中的名字，按名字导入了） 1234567891011//a.jsvar name = 'lin';var age = 13;var job = 'ninja';export &#123; name, age, job&#125;;//b.jsimport &#123; name, age, job&#125; from './a.js';console.log(name, age, job);// lin 13 ninja 12345678//a2.jsexport default function () &#123; console.log('default ');&#125;//b2.jsimport customName from './a2.js';customName(); // 'default' ES6 Module的特点（对比CommonJS） CommonJS模块是运行时加载，ES6 Module是编译时输出接口； CommonJS加载的是整个模块，将所有的接口全部加载进来，ES6 Module可以单独加载其中的某个接口（对应名字单独加载，加载这个模块想=需要的）； CommonJS输出是值的拷贝，ES6 Module输出的是值的引用，被输出模块的内部的改变会影响引用的改变； CommonJS this指向当前模块，ES6 Module this指向undefined; 参考：https://juejin.im/post/5db95e3a6fb9a020704bcd8d","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"异步以及异步编程解决方案","slug":"Generator函数-async函数","date":"2020-01-14T12:43:59.000Z","updated":"2020-04-02T01:03:23.205Z","comments":true,"path":"2020/01/14/Generator函数-async函数/","link":"","permalink":"http://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/","excerpt":"","text":"什么是异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务。 例如： 1234setTimeout(function()&#123; XXX;&#125;,1000)console.log(\"XXX\"); setTimeout就是一个异步任务，任务分为两个部分，一个部分是延迟1000ms，另一个部分是执行XXX。setTimeout是先执行1000ms的延迟，然后再延迟期间将执行权交给了console.log，输出了“XXX”之后，再去执行setTimeout任务的第二部分，执行XXX。 如果是同步的话，它会等到1000ms过去，执行XXX之后，再输出”XXX”，显然JavaScript不想这样浪费时间。 异步编程方案异步编程也有多种解决方案，其演变过程是：回调函数—》Promise—》Generator—》async/await，每个演变都解决了之前的一些痛点。 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。callback的意思就是“重新调用”。 读取文件进行处理，是这样写的。 1234fs.readFile('/etc/passwd', 'utf-8', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 也就是说在执行readFile的时候，执行权交给了主线程执行栈的同步任务，同步任务执行完毕后才会执行这个readFile的回调。 回调函数的缺点回调函数会导致回调地狱。 比如现在有多个异步任务，且任务有依赖关系（一个任务需要拿到另一个任务成功后的结果才能开始执行）的时候，回调的方式写出来的代码就会像这样： 1234567891011getData1(data1 =&gt; &#123; getData2(data1, data2 =&gt; &#123; getData3(data2, data3 =&gt; &#123; getData4(data3, data4 =&gt; &#123; getData5(data4, data5 =&gt; &#123; // 终于取到data5了 &#125;) &#125;) &#125;) &#125;)&#125;) 这种多层嵌套的结构就是回调地狱，这种情况下代码的可读性很差。 Promise因此就出现了Promise。Promise的关键点就是将回调函数的嵌套改为了链式调用。 我们使用new Promise去创建一个Promise实例，这个Promise实例会传入一个函数作为参数，函数又有两个函数作为参数，分别是：resolve、reject。 执行resolve函数，Promise实例的状态会变为fulfilled，后续就会去执行.then回调函数 执行reject函数，Promise实例的状态会变为rejected，后续就会去执行.catch回调函数，或者.then的第二个回调函数。 3种状态Promise实例有三种状态： pending（进行中） fulfilled（已成功） rejected（已失败） fulfilled和rejected有可以说是已成功和已失败，这两种状态又归为已完成状态 resolve和reject调用resolve和reject能将分别将promise实例的状态变成fulfilled和rejected，只有状态变成已完成（即fulfilled和rejected之一），才能触发状态的回调。resolve和reject两种函数只会执行一种，执行了其中一个之后就不会执行另一个了。 基本结构123456789101112131415let p = new Promise((resolve,reject)=&gt;&#123; //做一些事情 //然后在某些条件下resolve，或者reject（以下代码） if(/* 条件随便写 */)&#123; resolve() &#125; else&#123; reject() &#125;&#125;)p.then(()=&gt;&#123; //如果p的状态被resolve了，就进入这里&#125;,()=&gt;&#123; //如果p的状态被reject&#125;) 简单来说，这种.then.then.then的编码方式，就是Promise。 它的异步体现在，new Promise部分是立即执行的，那执行完毕后，就会将执行权交给主线程执行栈的同步任务，同步任务执行完毕后才会去执行.then回调。这里涉及JavaScript事件执行机制Eventloop。 Promise实现多任务顺序执行1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) 需要注意的是：每个.then中要返回一个new Promise对象，把任务放在Promise中，后续才能继续使用.then去执行后续操作。 Promise实现多任务并行（即A、B任务都执行完毕了才能执行C任务）：123456789101112var p1=new Promise((resolve,reject)=&gt;&#123; resolve('hello');&#125;)p1.then(result=&gt;result);var p2=new Promise((resolve,reject)=&gt;&#123; resolve('hi');&#125;)p1.then(result=&gt;result);var p=Promise.all([p1,p2]);p.then(result=&gt;console.log(result)); 这里主要用到Promise.all这种结构。Promise.all([p1,p2])接受一个数组作为参数，数组的元素都是Promise实例，只有当数组中所有Promise实例的状态都变为fulfilled的时候，这个Promise.all的实例才会变为fulfilled，才能执行后续的.then操作。 和Promise.all相关的还有Promise.race，那Promise.race实例的状态是等于其参数中第一个执行完毕的Promise实例的状态，它有可能是rejected，也有可能是fulfilled。 Promise的缺点Promise的最大问题是代码冗余：原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 GeneratorGenerator 函数是 ES6 提供的一种异步编程解决方案,Generator就能够解决上述Promise代码冗余的问题。它能够以一种类似同步的写法来执行一些异步操作。 形式上Generator函数是一个普通函数，有两个特征：1）function关键字与函数名之间有个星号； 2）函数内部使用yield表达式，定义不同的内部状态 执行Generator函数会返回一个遍历器对象 调用Generator函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象 必须调用遍历器对象的next方法，使得指针移向下一个状态，输出返回的结果 Generator函数的写法1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); 1234567891011hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 异步应用因为yield能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序。 例如有两个异步的函数 A 和 B, 并且 B 的参数是 A 的返回值，也就是说，如果 A 没有执行结束，我们不能执行 B。 那这时候我们写一段伪代码： 12345function* effect() &#123; const &#123; param &#125; = yield A(); const &#123; result &#125; = yield B(param); console.table(result);&#125; 这时候我们如果需要得到 result 那么我们就需要: 123const iterator = effect()iterator.next()iterator.next() co库可以用来每次执行A()/b()的请求结束之后，都会自动执行next()方法。 使用Generator去实现Promise的任务顺序执行：我们再回顾一下Promise版本： 1234567891011121314var result=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"one\"); &#125;,3000)&#125;).then(function(data)&#123; console.log(data); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(\"two\"); &#125;,3000) &#125;)&#125;).then(function(data)&#123; console.log(data);&#125;) Generator版本： 123456789101112131415161718192021function f1() &#123; setTimeout(function() &#123; g.next(\"one\"); //将参数传给data1 &#125;, 3000);&#125;function f2(data1) &#123; console.log(\"接收到了\" + data1); setTimeout(function()&#123; g.next(\"two\"); //将参数传给data2 &#125;,3000)&#125;function* mygenerator() &#123; var data1 = yield f1(); var data2=yield f2(data1); console.log(data2);&#125;var g = mygenerator();g.next(); 看起来就很像同步操作。 这里需要注意的是：执行yield f1()的时候是不会将返回的结果返回给data1的。next方法可以接受参数，这是向 Generator 函数体内输入数据。 第二个next的时候传入参数，就能被变量data1就能够接收到。 而且不能在f1中直接调用g.next()，要在异步函数内调用（这里还不是很懂为什么…）。 执行顺序如下： 再看个栗子理解： 12345678910111213function* G() &#123; const a = yield 100 console.log('a', a) // a aaa const b = yield 200 console.log('b', b) // b bbb const c = yield 300 console.log('c', c) // c ccc&#125;const g = G()g.next() // value: 100, done: falseg.next('aaa') // a aaa value: 200, done: false g.next('bbb') // b bbb value: 300, done: falseg.next('ccc') //c ccc value: undefined, done: true 捕获错误12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw('出错了');// 出错了 使用try...catch。 async和awaitasync函数就是Generator的语法糖。 形式上的不同： async函数将Generator函数的星号（*）替换成async 将yield替换成await async函数对Generator函数的改进体现在以下3点： 内置执行器 也就是说async函数的执行，和普通函数一样，只需要一行就可以。不用像Generator函数需要调用next方法才能真正执行。 例如对于一个async函数来说： 123456const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 调用时只需要： 1asyncReadFile(); 更好的语义 async和await比起星号和yield，语义更加清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 返回值是Promise async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 async函数基本用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName('goog').then(function (result) &#123; console.log(result);&#125;); 先执行了第一个await后的getStockSymbol(name)函数；得到了股票的名称symbol后，将symbol传给第二个await后面的getStockPrice(symbol)作为参数；最后返回股票价格stockPrice。 async/await错误处理try/catch 使用try将await语句包含起来，如果await后的语句执行错误，则错误会被catch捕获： 123456789run();async function run() &#123; try &#123; await Promise.reject(new Error(\"Oops!\")); &#125; catch (error) &#123; error.message; // \"Oops!\" &#125;&#125; 123456789101112run();async function run() &#123; const v = null; try &#123; await Promise.resolve(\"foo\"); v.thisWillThrow; &#125; catch (error) &#123; // \"TypeError: Cannot read property 'thisWillThrow' of null\" error.message; &#125;&#125; 参考：https://blog.fundebug.com/2019/07/24/async-await-error-handling-in-js/ ​ https://segmentfault.com/a/1190000012767617 执行顺序问题1234567891011121314async function async1()&#123; console.log('async1 start'); await async2(); console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start');async1();console.log('script end')// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end 当async函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了async函数体。 1234567891011121314151617181920async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 执行顺序为： 执行async1的时候遇到await先去执行async2，然后跳出了函数体，去执行后续的代码，然后再回到当前async1函数当中执行await后续语句。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"函数柯里化","slug":"函数柯里化","date":"2020-01-14T06:27:55.000Z","updated":"2020-02-18T07:59:41.485Z","comments":true,"path":"2020/01/14/函数柯里化/","link":"","permalink":"http://delaprada.com/2020/01/14/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"函数柯里化柯里化的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 看一个栗子： 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 我们定义了一个add函数，它接受一个参数并返回一个新的函数。调用了add之后，返回的函数就通过闭包的方式记住了add的第一个参数。 因为一次性地调用它有点繁琐，所以使用一个特殊的curry帮助函数使得这类函数的定义和调用更加容易。 一些柯里函数实例： 12345var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;); 12345match(/\\s+/g, \"hello world\");// [ ' ' ]match(/\\s+/g)(\"hello world\");// [ ' ' ] 以上两种方法都可以执行。第二种方法是比较常见的柯里化方法。先传递一部分参数（题目中为正则表达式）来调用函数，然后返回一个函数（题目中为str.match()来处理剩下的函数）。（题目中是匹配空格） 以上的形式可以更加具体化： 12345var hasSpaces = match(/\\s+/g);// function(x) &#123; return x.match(/\\s+/g) &#125;hasSpaces(\"hello world\");// [ ' ' ] 这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 再举一个非常常见的例子： 如果我们想要验证一串数字是否是正确的手机号，按照普通的思路来做，大家可能是这样封装，如下： 123function checkPhone(phoneNumber) &#123; return /^1[34578]\\d&#123;9&#125;$/.test(phoneNumber);&#125; 而如果想要验证是否是邮箱呢？这么封装： 123function checkEmail(email) &#123; return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(email);&#125; 我们还可能会遇到验证身份证号，验证密码等各种验证信息，因此在实践中，为了统一逻辑，我们就会封装一个更为通用的函数，将用于验证的正则与将要被验证的字符串作为参数传入： 123function check(targetString, reg) &#123; return reg.test(targetString);&#125; 但是这样封装之后，在使用时又会稍微麻烦一点，因为会总是输入一串正则，这样就导致了使用时的效率低下： 12check(/^1[34578]\\d&#123;9&#125;$/, '14900000088');check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, 'test@163.com'); 这个时候，我们就可以借助柯里化，在check的基础上再做一层封装，以简化使用： 1234var _check = createCurry(check);var checkPhone = _check(/^1[34578]\\d&#123;9&#125;$/);var checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/); 最后在使用的时候就会变得更加直观与简洁了： 12checkPhone('183888888');checkEmail('xxxxx@test.com'); 再看一个前端面试中常考的题目： 1如何实现add(2)(3)(4) &#x3D; 9 函数柯里化解决这个问题： 12345678910111213141516171819let myAdd = (a, b, c) =&gt; a+b+c;function curry(fn, args)&#123; let len = fn.length; let _this = this; let _args = args || []; return function()&#123; let args = Array.prototype.slice.apply(arguments); args = Array.prototype.concat.call(_args, args); // 当接收到的参数小于fn所需参数个数时，继续接收参数 if(args.length &lt; len)&#123; return curry.call(_this, fn, args); &#125; return fn.apply(this, args); &#125;&#125;let add = curry(myAdd);console.log(add(2)(3)(4)); // 9console.loh(add(2,3)(4)); // 9console.log(add(2,3,4)); // 9 但是这个例子不具有普遍性。如果传入的参数不是3个的话不能这么用。 所以有了下面的进化之后的代码： 1234567891011121314151617181920212223function add() &#123; // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() &#123; _args.push(...arguments); return _adder; &#125;; // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; return _adder;&#125;add(1)(2)(3).toString() // 6add(1, 2, 3)(4).toString() // 10add(1)(2)(3)(4)(5).toString() // 15add(2, 6)(1).toString() // 9 参考的博客说隐式转换的原因是因为函数进行计算的时候会变为字符串，但理解了代码之后觉得并不是这么回事。每次调用函数的时候执行的是这个语句体： 1234var _adder = function() &#123; _args.push(...arguments); return _adder;&#125;; 这个语句体实际上是用于将所有传入的实参放进数组args中。最后执行toString方法的时候是将数组args的每个元素通过reduce函数求和，返回求和的值。单纯执行_adder函数和执行toString()函数做的事情是不一样的。 看到一个面试题目： 实现一个sum函数使得sum(1, 2, 3).valueOf()和sum(1)(2)(3).valueOf()执行输出的结果都等于6 。 解法和上面一致，只需要把toString()改为valueOf()就可以了。 1234567891011121314151617var sum=function()&#123; var args=[].slice.call(arguments); var _adder=function()&#123; args.push(...arguments); return _adder; &#125; _adder.valueOf=function()&#123; return args.reduce(function(a,b)&#123; return a+b; &#125;); &#125; return _adder;&#125;console.log(sum(1,2,3).valueOf());console.log(sum(1)(2)(3).valueOf()); 为什么要进行隐式转化？ 因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。 12function fn() &#123; return 20 &#125;console.log(fn + 10); // 输出结果 function fn() &#123; return 20 &#125;10 我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果： 1234function fn() &#123; return 20; &#125;fn.toString = function() &#123; return 30 &#125;console.log(fn + 10); // 40 除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果： 1234function fn() &#123; return 20; &#125;fn.valueOf = function() &#123; return 60 &#125;console.log(fn + 10); // 70 参考博客： https://www.jianshu.com/p/5e1899fe7d6b https://www.cnblogs.com/hmchen/p/11564394.html https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html#%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%8F%8C%E5%85%B3%E8%AF%AD%E5%92%96%E5%96%B1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript this解析","slug":"JavaScript-this全面解析","date":"2020-01-13T03:12:48.000Z","updated":"2020-03-07T12:09:22.112Z","comments":true,"path":"2020/01/13/JavaScript-this全面解析/","link":"","permalink":"http://delaprada.com/2020/01/13/JavaScript-this%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/","excerpt":"","text":"为什么要使用thisthis提供了一种更优雅的方式来隐式“传递”一个对象引用。 看下面的例子： 没有使用this的情况下： 1234567891011121314151617var me=&#123; name:\"Kyle\"&#125;var you=&#123; name:\"Reader\"&#125;function identify(context)&#123; return context.name.toUpperCase();&#125;function speak(context)&#123; var greeting=\"Hello, I'm \"+identify(context); console.log(greeting);&#125;identify(you); //READERspeak(me); //hello, I'm KYLE 使用了this的情况： 123456789101112function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greeting=\"Hello, I'm \"+identify.call(this); console.log(greeting);&#125;identify.call(me); //KYLEidentify.call(you); //READERspeak.call(me); //Hello, I'm KYLEspeak.call(you); //Hello, I'm READER 表达上更加的简洁。如果不使用this的话，就需要给identify()和speak()显式传入一个上下文对象。 this绑定对象的规则我们可以顺序应用下面四条规则来判断this的绑定对象： 如果是由new调用，绑定到新创建的对象。 如果是由call或者apply、bind调用，绑定到指定的对象上。 如果是由上下文对象调用（即this是对象中的方法里使用的），绑定到那个上下文对象上。 如果是默认情况下，严格模式绑定到undefined，否则绑定到全局对象上。 但是ES6中的箭头函数并不会使用者四条标准的绑定规则。箭头函数会继承外层函数调用的this绑定。 new绑定12345function foo(a)&#123; this.a=a;&#125;var bar=new foo(2);console.log(bar.a); //2 我们使用new来调用foo(…)时，会构造一个新对象并把它绑定到foo(…)调用中的this上。 显式绑定call、apply、bind1234567function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2;&#125;;foo.call(obj); //2 call用来将函数foo中的this绑定到obj上。 隐式绑定（上下文对象调用）如果this所在的函数是对象中的方法的话，this就会指向这个对象。 12345678function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;obj.foo(); //2 foo此时是obj对象的一个方法，所以this就会指向obj。 但是对象属性引用链中只有上一层或者说最后一层在调用位置中起作用： 123456789101112function foo()&#123; console.log(this.a);&#125;var obj2=&#123; a:42, foo:foo&#125;;var obj1=&#123; a:2, obj2:obj2&#125;;obj1.obj2.foo(); //42 隐式丢失也是this隐式绑定中常见的问题： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;;var bar=obj.foo; //函数别名！var a=\"oops, global\"; //a是全局对象的属性bar(); //“oops, global” 此时bar是obj.foo的一个引用，但实际上它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 回调函数丢失this绑定是也是非常常见的问题： 123456789101112function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn(); //调用位置&#125;var obj=&#123; a:2, foo:foo&#125;;var a=\"oops global\"; //全局对象属性doFoo(obj.foo); //\"oops global\" 函数doFoo传入了函数作为参数，并在doFoo中调用。我们可以把它看做将函数copy到了doFoo函数体中，调用的时候this指向的是全局作用域。 隐式丢失一个最常见的this绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。 例一： 12345678910function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo:foo&#125;var bar=obj.foo; //函数别名！把函数体赋值了var a=\"oops,global\"; //a是全局对象的属性bar(); \"oops, global\" bar实际上它引用的是foo函数本身。 例二： 123456789101112131415function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;var obj=&#123; a:2, foo:foo&#125;var a=\"oops, global\"; //a是全局对象的属性doFoo(obj.foo); //\"oops, global\" 参数传递实际上是一种隐式赋值，因此我们传入函数时也会被隐式赋值。 例三： 123456789function foo()&#123; console.log(this.a);&#125;var obj=&#123; a:2, foo: foo&#125;var a=\"oops, global\";setTimeout(obj.foo,100); //\"oops, global\" 回调函数丢失this绑定是非常常见的！ 栗子： 123456789var obj = &#123; id: \"a\", cool: function coolFn() &#123; console.log( this.id ); &#125;&#125;;var id = \"b\"obj.cool(); // asetTimeout( obj.cool, 100 ); // b 默认绑定12345function foo()&#123; console.log(this.a);&#125;var a=2;foo(); //2 在这个例子中，函数调用应用了this的默认绑定，this指向全局对象。 如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，this会绑定到undefined。 123456function foo()&#123; \"use strict\"; console.log(this.a);&#125;var a=2;foo(); //TypeError: this is undefined 箭头函数中的this箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。 12345678910111213function foo()&#123; return (a)=&gt;&#123; console.log(this.a); &#125;&#125;var obj1=&#123; a:2&#125;;var obj2=&#123; a:3&#125;;var bar=foo.call(obj1);bar.call(obj2); //2,不是3！ foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，所以bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。 再看一个例子： 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 foo调用时传入的是什么对象，this就指向谁。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21（严格模式则输出undefined）。 如果foo函数内部是普通函数的话： 由此可以看出，foo函数的this是指向call传入的对象{id:42}，但是foo函数内部的setTimeout函数中的this是指向全局的。 参考书籍：《你不知道的JavaScript》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"JavaScript基本知识","slug":"JavaScript基本知识","date":"2019-12-30T02:14:24.000Z","updated":"2019-12-30T02:30:31.762Z","comments":true,"path":"2019/12/30/JavaScript基本知识/","link":"","permalink":"http://delaprada.com/2019/12/30/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","excerpt":"","text":"JavaScriptES6和JavaScript的关系ES6的全称为ECMAScript 6.0，是JavaScript语言下一代的标准，是使得JavaScript可以用来编写复杂的大型应用程序，称为企业级开发语言。ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。 JavaScript前言JavaScript是世界上最流行的脚本语言，是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。 JavaScript引入 用直接包含js代码 把js代码放到一个单独的.js文件，在html中通过引入这个文件，这么做更有利于代码维护 JavaScript基本语法 JavaScript的语法和Java类似，每个语句以；结束 JavaScript严格区分大小写 JavaScript的数据类型基本数据类型：Number, String, Boolean, null, undefined, Symbol（ES6中新添加的类型，一种实例是唯一且不可改变的数据类型） NumberJavaScript不区分整数和浮点数，统一用Number表示。可以表示 整数 浮点数 科学计数法 负数 NaN（表示Not a Number，当无法计算结果时用NaN表示） Infinity（表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity） String字符串是以单引号或双引号括起来的文本。 模板字符串要把多个字符串连接起来，可以用+号连接： 1234var name = '小明';var age = 20;var message = '你好, ' + name + ', 你今年' + age + '岁了!';alert(message); 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： 1234var name = '小明';var age = 20;var message = `你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!`;alert(message); 操作字符串获取字符串长度： 12var s = 'Hello, world!';s.length; // 13 要获取字符串某个指定位置的字符，使用类似Array的下标操作，索引号从0开始： 1234567var s = 'Hello, world!';s[0]; // 'H's[6]; // ' 's[7]; // 'w's[12]; // '!'s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果： 123var s = 'Test';s[0] = 'X';alert(s); // s仍然为'Test' 字符串常用方法：注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： toUpperCase： toUpperCase()把一个字符串全部变为大写： 12var s = 'Hello';s.toUpperCase(); // 返回'HELLO' toLowerCase： toLowerCase()把一个字符串全部变为小写： 123var s = 'Hello';var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lowerlower; // 'hello' substring: substring()返回指定索引区间的子串： 123var s = 'hello, world's.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello's.substring(7); // 从索引7开始到结束，返回'world' Booleantrue或者false 比较运算符当我们对Number做比较时，可以通过比较运算符得到一个布尔值，要特别注意比较运算符==和===： ==比较：它会自动转换数据类型再比较，很多时候会得到很奇怪的结果 ===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN===NaN //false 唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN) //true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： 1Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true null和undefined null表示一个“空”的值、表示“无”的对象，转为数值是为0；undefined是一个表示“无”的原始值，转为数值是NaN，当声明的变量还未被初始化时，变量的默认值为undefined。 Null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 Undefined表示”缺少值”,就是此处应该有一个值,但是还没有定义，典型用法是： 变量被声明了，但没有赋值时，就等于undefined 调用函数时，应该提供的参数没有提供，该参数等于undefined 对象没有赋值属性，该属性的值为undefined 函数没有返回值时，默认返回undefined null表示”没有对象”，即该处不应该有值。典型用法是： 作为函数的参数，表示该函数的参数不是对象 作为对象原型链的终点 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如： 1[1, 2, 3.14, &#39;Hello&#39;, null, true]; 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过Array()函数实现： 1new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用[]。 数组的元素可以通过索引来访问。请注意，索引的起始值为0： 1234var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即truearr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined 要取得Array的长度，直接访问length属性： 12var arr = [1, 2, 3.14, 'Hello', null, true];arr.length; // 6 请注意，直接给Array的length赋一个新的值会导致Array大小的变化： 123456var arr = [1, 2, 3];arr.length; // 3arr.length = 6;arr; // arr变为[1, 2, 3, undefined, undefined, undefined]arr.length = 2;arr; // arr变为[1, 2] Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array： 123var arr = ['A', 'B', 'C'];arr[1] = 99;arr; // arr现在变为['A', 99, 'C'] (注意此处与String的不同，String是不可变的) 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： 123var arr = [1, 2, 3];arr[5] = 'x';arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 12345var arr = [10, 20, '30', 'xyz'];arr.indexOf(10); // 元素10的索引为0arr.indexOf(20); // 元素20的索引为1arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字30和字符串&#39;30&#39;是不同的元素。 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array： 123var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array： 1234var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false push和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： 123456789var arr = [1, 2];arr.push('A', 'B'); // 返回Array新的长度: 4arr; // [1, 2, 'A', 'B']arr.pop(); // pop()返回'B'arr; // [1, 2, 'A']arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次arr; // []arr.pop(); // 空数组继续pop不会报错，而是返回undefinedarr; // [] unshift和shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： 123456789var arr = [1, 2];arr.unshift('A', 'B'); // 返回Array新的长度: 4arr; // ['A', 'B', 1, 2]arr.shift(); // 'A'arr; // ['B', 1, 2]arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次arr; // []arr.shift(); // 空数组继续shift不会报错，而是返回undefinedarr; // [] sort 123var arr = ['B', 'C', 'A'];arr.sort();arr; // ['A', 'B', 'C'] reverse reverse()把整个Array的元素给掉个个，也就是反转： 123var arr = ['one', 'two', 'three'];arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： 12345678910var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']// 只删除,不添加:arr.splice(2, 2); // ['Google', 'Facebook']arr; // ['Microsoft', 'Apple', 'Oracle']// 只添加,不删除:arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] concat concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array： 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] 请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。 实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里： 12var arr = ['A', 'B', 'C'];arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 12var arr = ['A', 'B', 'C', 1, 2, 3];arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 对象JavaScript的对象是一组由键-值组成的无序集合，用一个{...}表示一个对象，例如： 12345678var person = &#123; name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null&#125;; 注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为&#39;Bob&#39;，zipcode属性为null。 要获取一个对象的属性，我们用对象变量.属性名的方式： 12person.name; // 'Bob'person.zipcode; // null 访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用&#39;&#39;括起来： 1234var xiaohong = &#123; name: '小红', 'middle-school': 'No.1 Middle School'&#125;; xiaohong的属性名middle-school不是一个有效的变量，就需要用&#39;&#39;括起来。访问这个属性也无法使用.操作符，必须用[&#39;xxx&#39;]来访问： 123xiaohong['middle-school']; // 'No.1 Middle School'xiaohong['name']; // '小红'xiaohong.name; // '小红' 实际上JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。 如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性： 1234567891011var xiaoming = &#123; name: '小明'&#125;;xiaoming.age; // undefinedxiaoming.age = 18; // 新增一个age属性xiaoming.age; // 18delete xiaoming.age; // 删除age属性xiaoming.age; // undefineddelete xiaoming['name']; // 删除name属性xiaoming.name; // undefineddelete xiaoming.school; // 删除一个不存在的school属性也不会报错 如果我们要检测xiaoming是否拥有某一属性，可以用in操作符： 12345678910var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;;'name' in xiaoming; // true'grade' in xiaoming; // false 不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的： 1'toString' in xiaoming; // true 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。 要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法： 12345var xiaoming = &#123; name: '小明'&#125;;xiaoming.hasOwnProperty('name'); // truexiaoming.hasOwnProperty('toString'); // false 变量变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如： 12345var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefinedvar $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值truevar t &#x3D; null; &#x2F;&#x2F; t的值是null 在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var申明一次，例如： 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言（例如int） 使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。 循环for…infor循环的一个变体是for ... in循环，它可以把一个对象的所有属性依次循环出来： 12345678var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; console.log(key); // 'name', 'age', 'city'&#125; 要过滤掉对象继承的属性，用hasOwnProperty()来实现： 12345678910var o = &#123; name: 'Jack', age: 20, city: 'Beijing'&#125;;for (var key in o) &#123; if (o.hasOwnProperty(key)) &#123; console.log(key); // 'name', 'age', 'city' &#125;&#125; 由于Array也是对象，而它的每个元素的索引被视为对象的属性，因此，for ... in循环可以直接循环出Array的索引： 12345var a = ['A', 'B', 'C'];for (var i in a) &#123; console.log(i); // '0', '1', '2' console.log(a[i]); // 'A', 'B', 'C'&#125; 请注意，for ... in对Array的循环得到的是String而不是Number。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy'];var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。 如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map(); // 空Mapm.set('Adam', 67); // 添加新的key-valuem.set('Bob', 59);m.has('Adam'); // 是否存在key 'Adam': truem.get('Adam'); // 67m.delete('Adam'); // 删除key 'Adam'm.get('Adam'); // undefined 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉： 1234var m = new Map();m.set('Adam', 67);m.set('Adam', 88);m.get('Adam'); // 88 SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.add(4);s; // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s = new Set([1, 2, 3]);s; // Set &#123;1, 2, 3&#125;s.delete(3);s; // Set &#123;1, 2&#125; iterable遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的for ... of循环来遍历。 for...in和for...of的区别： for in 循环的是对象的属性（普通数组的属性就是index） for of 循环的是迭代器中的每一个元素 用for ... of循环遍历集合，用法如下： 123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125; 你可能会有疑问，for ... of循环和for ... in循环有何区别？ 当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125; for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： 12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x of a) &#123; console.log(x); // 'A', 'B', 'C'&#125; 然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例： 12345678'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;); Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身： 1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;); Map的回调函数参数依次为value、key和map本身： 1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;); 如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element： 1234var a = ['A', 'B', 'C'];a.forEach(function (element) &#123; console.log(element);&#125;); 参考基本数据类型和引用数据类型的区别：https://www.cnblogs.com/c2016c/articles/9328725.html","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://delaprada.com/tags/JavaScript/"}]},{"title":"hexo常用指令及美化博客页面","slug":"hexo常用指令及美化博客页面","date":"2019-12-26T09:54:44.000Z","updated":"2020-01-15T12:46:56.095Z","comments":true,"path":"2019/12/26/hexo常用指令及美化博客页面/","link":"","permalink":"http://delaprada.com/2019/12/26/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"hexo常用命令Hexo的命令总体来说比较简单，安装成功之后只需要记住常用的四种即可。在当前blog文件夹根目录下右键点击git bash： hexo s：server启动服务器 hexo clean：clean清除缓存文件（db.json）和已生成的静态文件（public） hexo generate或hexo g：generate生成静态文件 hexo deploy或hexo d：deploy部署网站，部署网站前需预先生成静态文件 一般更改完后执行三条指令：hexo clean，hexo generate，hexo deploy即可（按顺序） 如果要进行文件压缩，在hexo generate指令后，执行gulp指令。 参考https://yfzhou.coding.me/2018/08/27/Hexo-Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%89/ hexo各种美化新建page1hexo new &quot;文章名称&quot; 会在source文件夹下_post中新建文件夹和.md文件 侧栏增加标签和分类页面创建标签页面 创建标签页面 1hexo new page tags 基本设置 123title: tagsdate: 2017-12-02 21:01:24type: &quot;tags&quot; 创建分类页面 创建分类页面 1hexo new page categories 基本设置 123title: categoriesdate: 2017-12-02 21:01:24type: &quot;categories&quot; 文章中插入图片 将图片放置在页面对应的文件夹中 在文章中引入： 1&#123;% asset_img 图片名称 %&#125; 设置站点图标 先在images文件夹下放入你的图标 在主题配置页面_config.yml中搜索favicon，找到以下位置，并将路径修改为你的图标： 部署之后就可以看到效果了，查看效果：http://delaprada.com 设置头像 在images文件夹中放入你的头像图片 在主题配置页面中修改avatar为你的图片地址： 首页文章不显示全文只显示摘要修改/themes/next/_config.yml主题配置文件中： 1234567scroll_to_more: true #如果文章有摘要,会自动滚动到摘要下面save_scroll: true #通过cookies来缓存阅读进度excerpt_description: true #自动摘录描述作为序言auto_excerpt: #设置阅读全文 enable: true length: 150 #摘要次数read_more_btn: true #阅读全文按钮 修改文章底部的带#的标签修改模板/themes/next/layout/_macro/post.swig，搜索rel=&quot;tag&quot;&gt;#，将#改为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;（如果想换成其他图标可到font-awesome中文网查看） 在每篇文章末尾统一添加“本文结束”标记在\\themes\\next\\layout\\_macro中新建passage-end-tag.swig，并加入以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=\"text-align:center;color: #ccc;font-size:15px;\"&gt;-------本&amp;nbsp;文&amp;nbsp; 结&amp;nbsp;束&amp;nbsp;&amp;nbsp;&lt;i class=\"fa fa-heart\" aria-hidden=\"true\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;感 &amp;nbsp;谢&amp;nbsp;您&amp;nbsp;的&amp;nbsp;阅&amp;nbsp;读-------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\\themes\\next\\layout\\_macro\\post.swig文件，在post-body标签之后，post-footer标签之前，添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &#39;passage-end-tag.swig&#39; %&#125; &#123;% endif %&#125;&lt;&#x2F;div&gt; 修改网页背景颜色和侧栏上方brand的颜色打开themes/next/layout/source/css/_custom/custom.styl，加入以下代码： 12345678910111213141516171819202122&#x2F;&#x2F;修改网页背景颜色body &#123; background-color: #F0F8FF&#125;#footer a &#123; color:#eee;&#125;&#x2F;&#x2F; 修改网站头部颜色.headband &#123; height: 3px; background: #ADD8E6;&#125;.site-meta &#123; padding: 20px 0; color: #fff; background: #ADD8E6;&#125;.site-title &#123; color: #fff;&#125; 侧边栏社交设置和友情链接修改主题配置页面：themes/next/_config.yml： 12345678910111213141516171819202122232425262728293031site_state: true# Social Links# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: CSDN: https://blog.csdn.net/weixin_41973410 || copyright GitHub: https://github.com/delaprada || githubsocial_icons: #这里是上面社交链接的对应图标 enable: true CSDN: copyright Github: github icons_only: false transition: true# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.#github_banner: https://github.com/Fitz1318 || Follow me on GitHub# Blog rolls #这里时设置一些相关链接 我这里设置了一些推荐阅读的网站#links_icon: linklinks_title: 实用网站#links_layout: blocklinks_layout: inlinelinks: W3Cschool: http://www.w3school.com.cn/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"hexo categories和tags页面不显示解决办法","slug":"hexo-categories和tags页面不显示解决办法","date":"2019-12-25T02:53:13.000Z","updated":"2019-12-26T09:55:44.357Z","comments":true,"path":"2019/12/25/hexo-categories和tags页面不显示解决办法/","link":"","permalink":"http://delaprada.com/2019/12/25/hexo-categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"官网也有给出具体步骤，但是有坑Hexo官网教程 第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page指令新建一个页面，命名为 categories ：12cd hexo //根目录hexo new page categories //tags和这个操作一致 第二步 找到新建的页面，添加type新建的页面一般在source/categories/index.md中，添加以下内容： 1234title: categoriesdate: 2019-12-25 09:15:45type: \"categories\"layout: \"categories\" 第三步 给你的页面添加分类找到你的页面，在页面上方添加如下内容 123456title: 利用gitpages+hexo搭建自己的博客date: 2019-12-25 09:12:55categories:- Hexotags:- 前端 但此时部署到github上后，打开网页点击分类和标签页面还是出现404！ 第四步 解决方案实属官方坑人系列！！主题配置文件_config.yml中的menu：把 / 后面的空格全部去掉（刚开始的时候默认后面是加了空格导致点击页面出现404）","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]},{"title":"利用gitpages+hexo搭建自己的博客","slug":"利用gitpages+hexo搭建自己的博客","date":"2019-12-25T01:12:55.000Z","updated":"2020-01-15T12:50:57.057Z","comments":true,"path":"2019/12/25/利用gitpages+hexo搭建自己的博客/","link":"","permalink":"http://delaprada.com/2019/12/25/%E5%88%A9%E7%94%A8gitpages+hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"前言从开始开始着手搭建到完成大概花了一个下午的时间，采坑不少，在此记录一下 第一步 准备工作node.js下载好，github有已注册的账号在github中新建一个repository，命名为：你的github名称.github.io（下面是我的仓库名称）： （有些博客直接让我们fork它们的项目，个人感觉这么做不太好，很多东西自己动手做一遍更好） 第二步 安装HexoHexo就是一个博客框架，官网上也有安装教程Hexo官网 step1：windows系统鼠标右键git bash，输入两个安装指令： 12npm install hexo-cli -g &#x2F;&#x2F;用于安装hexonpm install hexo-deployer-git --save &#x2F;&#x2F;用于安装hexo部署到git page的deployer step2：创建hexo文件夹hexo安装完成之后，在电脑中新建一个hexo文件夹： 右键点击git bash，输入两个命令： 12hexo initnpm install &#x2F;&#x2F;安装所有package.json里的包 执行完成后，hexo文件夹中会多出一些文件： 如果想看本地效果的话，执行以下指令： 12hexo generate &#x2F;&#x2F;自动将md文件生成静态html，css文件hexo server &#x2F;&#x2F;启动本地hexo服务器（localhost:4000） 打开 localhost:4000就可以看到页面啦： （页面会不太一样，我的配了一下主题） 第三步 了解hexo文件夹中的_config.ymlhexo文件夹中比较重要的文件是：_config.yml： 它是一个全局配置文件，包括和github上传链接都在这里配置，例如title之类的： 第四步 本地上传到githubstep1：执行命令，安装deploy.git插件 1npm install hexo-deployer-git --save step2：在主题配置文件_config.yml中修改仓库地址，在_config.yml最下面一行（注意每个冒号后面都有一个空格） step3：配置提交github认证方式执行指令： 1hexo d 直接提交到github仓库中，如果没有认证github和本地的关系，会提示输入用户名和密码 此时打开github的项目会发现原本是空的项目现在有了刚刚上传的文件 第五步 添加域名在阿里云中购买了一个.com的域名（加优惠一年23块，虽然比其他贵一些但是觉得.com好听一些(#^ . ^#)） step1：cmd ping一下github.io获得真实ip地址 step2：然后再域名操作栏点击解析，添加记录 注意要两个都要添加（之前一开始只添加了www不知道为啥就显示不出来） step3：去hexo文件夹的source目录下新建名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www step4：然后部署 1231. hexo clean2. hexo generate3. hexo deploy （每次做出更改建议都部署一遍） step5：点击设置，拉到下面，在custom domain中输入你的域名。如果上面的信息不是显示Your site is published at https://xxx.com/，而是dns的之类的错误，可能是域名还没有实名认证 输入域名，成功：","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://delaprada.com/tags/Hexo/"}]}]}